
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model categorysensors
 * 
 */
export type categorysensors = {
  id: number
  sensor: string | null
}

/**
 * Model sensors
 * 
 */
export type sensors = {
  id: number
  idDistr: number
  idSensor: number
  value: string
}

/**
 * Model categorie
 * 
 */
export type categorie = {
  id: number
  categorie: string | null
}

/**
 * Model categoryrecette
 * 
 */
export type categoryrecette = {
  id: number
  description: string | null
}

/**
 * Model commande
 * 
 */
export type commande = {
  id: number
  idRecette: number
  idIngredient: number | null
  quantity: string
}

/**
 * Model distributeur
 * 
 */
export type distributeur = {
  id: number
  identifiant: string
  capaciteGoblet: number | null
  capaciteSucre: number | null
  capaciteSpoon: number | null
}

/**
 * Model entrepise
 * 
 */
export type entrepise = {
  id: number
  nom: string | null
  adresse: string | null
  mail: string | null
  tel: string | null
  link: string | null
}

/**
 * Model facture
 * 
 */
export type facture = {
  id: number
  idDistr: number | null
  idComm: number | null
  idInfoPaiment: number | null
}

/**
 * Model infopaiment
 * 
 */
export type infopaiment = {
  id: number
  mail: string | null
  cartePaiment: string | null
  ccv: string | null
}

/**
 * Model pack
 * 
 */
export type pack = {
  idDistr: number
  idEntre: number
  codeverou: string | null
  localisation: string | null
  state: string | null
}

/**
 * Model publicite
 * 
 */
export type publicite = {
  id: number
  url: string | null
  idCategorie: number | null
  idCategRecette: number | null
  idAnnonceur: number | null
}

/**
 * Model recette
 * 
 */
export type recette = {
  id: number
  idCategRecette: number | null
  name: string | null
  description: string | null
  price: Prisma.Decimal
  imageLink: string | null
}

/**
 * Model reclamation
 * 
 */
export type reclamation = {
  id: number
  idFacture: number | null
  message: string | null
  isDone: boolean | null
}

/**
 * Model task
 * 
 */
export type task = {
  id: number
  idDistr: number
  idUser: number | null
  idEntre: number
  idType: number
  isDone: boolean
  isOpen: boolean
  date: string
  time: string
  message: string
}

/**
 * Model users
 * 
 */
export type users = {
  id: number
  nom: string | null
  prenom: string | null
  mail: string | null
  mdp: string | null
  tel: string | null
  idRole: number | null
  idCreatedpar: number | null
  idEntreprise: number | null
  isActive: number | null
}

/**
 * Model annonceur
 * 
 */
export type annonceur = {
  id: number
  nom: string | null
  prenom: string | null
  mail: string | null
  tel: string | null
  idCreatedpar: number | null
}

/**
 * Model ingredient
 * 
 */
export type ingredient = {
  id: number
  type: number | null
  description: string | null
  prixUnit: number | null
}

/**
 * Model recetteingr
 * 
 */
export type recetteingr = {
  idRecette: number
  idIngredient: number
  quantity: string | null
}

/**
 * Model role
 * 
 */
export type role = {
  id: number
  description: string | null
}

/**
 * Model typetask
 * 
 */
export type typetask = {
  id: number
  identifiant: string
  description: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categorysensors
 * const categorysensors = await prisma.categorysensors.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categorysensors
   * const categorysensors = await prisma.categorysensors.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.categorysensors`: Exposes CRUD operations for the **categorysensors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorysensors
    * const categorysensors = await prisma.categorysensors.findMany()
    * ```
    */
  get categorysensors(): Prisma.categorysensorsDelegate<GlobalReject>;

  /**
   * `prisma.sensors`: Exposes CRUD operations for the **sensors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sensors
    * const sensors = await prisma.sensors.findMany()
    * ```
    */
  get sensors(): Prisma.sensorsDelegate<GlobalReject>;

  /**
   * `prisma.categorie`: Exposes CRUD operations for the **categorie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categorie.findMany()
    * ```
    */
  get categorie(): Prisma.categorieDelegate<GlobalReject>;

  /**
   * `prisma.categoryrecette`: Exposes CRUD operations for the **categoryrecette** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoryrecettes
    * const categoryrecettes = await prisma.categoryrecette.findMany()
    * ```
    */
  get categoryrecette(): Prisma.categoryrecetteDelegate<GlobalReject>;

  /**
   * `prisma.commande`: Exposes CRUD operations for the **commande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commandes
    * const commandes = await prisma.commande.findMany()
    * ```
    */
  get commande(): Prisma.commandeDelegate<GlobalReject>;

  /**
   * `prisma.distributeur`: Exposes CRUD operations for the **distributeur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distributeurs
    * const distributeurs = await prisma.distributeur.findMany()
    * ```
    */
  get distributeur(): Prisma.distributeurDelegate<GlobalReject>;

  /**
   * `prisma.entrepise`: Exposes CRUD operations for the **entrepise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entrepises
    * const entrepises = await prisma.entrepise.findMany()
    * ```
    */
  get entrepise(): Prisma.entrepiseDelegate<GlobalReject>;

  /**
   * `prisma.facture`: Exposes CRUD operations for the **facture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factures
    * const factures = await prisma.facture.findMany()
    * ```
    */
  get facture(): Prisma.factureDelegate<GlobalReject>;

  /**
   * `prisma.infopaiment`: Exposes CRUD operations for the **infopaiment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infopaiments
    * const infopaiments = await prisma.infopaiment.findMany()
    * ```
    */
  get infopaiment(): Prisma.infopaimentDelegate<GlobalReject>;

  /**
   * `prisma.pack`: Exposes CRUD operations for the **pack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packs
    * const packs = await prisma.pack.findMany()
    * ```
    */
  get pack(): Prisma.packDelegate<GlobalReject>;

  /**
   * `prisma.publicite`: Exposes CRUD operations for the **publicite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicites
    * const publicites = await prisma.publicite.findMany()
    * ```
    */
  get publicite(): Prisma.publiciteDelegate<GlobalReject>;

  /**
   * `prisma.recette`: Exposes CRUD operations for the **recette** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recettes
    * const recettes = await prisma.recette.findMany()
    * ```
    */
  get recette(): Prisma.recetteDelegate<GlobalReject>;

  /**
   * `prisma.reclamation`: Exposes CRUD operations for the **reclamation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reclamations
    * const reclamations = await prisma.reclamation.findMany()
    * ```
    */
  get reclamation(): Prisma.reclamationDelegate<GlobalReject>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.taskDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.annonceur`: Exposes CRUD operations for the **annonceur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annonceurs
    * const annonceurs = await prisma.annonceur.findMany()
    * ```
    */
  get annonceur(): Prisma.annonceurDelegate<GlobalReject>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.ingredientDelegate<GlobalReject>;

  /**
   * `prisma.recetteingr`: Exposes CRUD operations for the **recetteingr** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recetteingrs
    * const recetteingrs = await prisma.recetteingr.findMany()
    * ```
    */
  get recetteingr(): Prisma.recetteingrDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<GlobalReject>;

  /**
   * `prisma.typetask`: Exposes CRUD operations for the **typetask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Typetasks
    * const typetasks = await prisma.typetask.findMany()
    * ```
    */
  get typetask(): Prisma.typetaskDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    categorysensors: 'categorysensors',
    sensors: 'sensors',
    categorie: 'categorie',
    categoryrecette: 'categoryrecette',
    commande: 'commande',
    distributeur: 'distributeur',
    entrepise: 'entrepise',
    facture: 'facture',
    infopaiment: 'infopaiment',
    pack: 'pack',
    publicite: 'publicite',
    recette: 'recette',
    reclamation: 'reclamation',
    task: 'task',
    users: 'users',
    annonceur: 'annonceur',
    ingredient: 'ingredient',
    recetteingr: 'recetteingr',
    role: 'role',
    typetask: 'typetask'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategorysensorsCountOutputType
   */


  export type CategorysensorsCountOutputType = {
    sensors: number
  }

  export type CategorysensorsCountOutputTypeSelect = {
    sensors?: boolean
  }

  export type CategorysensorsCountOutputTypeGetPayload<S extends boolean | null | undefined | CategorysensorsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategorysensorsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategorysensorsCountOutputTypeArgs)
    ? CategorysensorsCountOutputType 
    : S extends { select: any } & (CategorysensorsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategorysensorsCountOutputType ? CategorysensorsCountOutputType[P] : never
  } 
      : CategorysensorsCountOutputType




  // Custom InputTypes

  /**
   * CategorysensorsCountOutputType without action
   */
  export type CategorysensorsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategorysensorsCountOutputType
     */
    select?: CategorysensorsCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryrecetteCountOutputType
   */


  export type CategoryrecetteCountOutputType = {
    recette: number
    publicite: number
  }

  export type CategoryrecetteCountOutputTypeSelect = {
    recette?: boolean
    publicite?: boolean
  }

  export type CategoryrecetteCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryrecetteCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryrecetteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryrecetteCountOutputTypeArgs)
    ? CategoryrecetteCountOutputType 
    : S extends { select: any } & (CategoryrecetteCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryrecetteCountOutputType ? CategoryrecetteCountOutputType[P] : never
  } 
      : CategoryrecetteCountOutputType




  // Custom InputTypes

  /**
   * CategoryrecetteCountOutputType without action
   */
  export type CategoryrecetteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryrecetteCountOutputType
     */
    select?: CategoryrecetteCountOutputTypeSelect | null
  }



  /**
   * Count Type DistributeurCountOutputType
   */


  export type DistributeurCountOutputType = {
    sensors: number
  }

  export type DistributeurCountOutputTypeSelect = {
    sensors?: boolean
  }

  export type DistributeurCountOutputTypeGetPayload<S extends boolean | null | undefined | DistributeurCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DistributeurCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DistributeurCountOutputTypeArgs)
    ? DistributeurCountOutputType 
    : S extends { select: any } & (DistributeurCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DistributeurCountOutputType ? DistributeurCountOutputType[P] : never
  } 
      : DistributeurCountOutputType




  // Custom InputTypes

  /**
   * DistributeurCountOutputType without action
   */
  export type DistributeurCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DistributeurCountOutputType
     */
    select?: DistributeurCountOutputTypeSelect | null
  }



  /**
   * Count Type EntrepiseCountOutputType
   */


  export type EntrepiseCountOutputType = {
    pack: number
    users: number
    task: number
  }

  export type EntrepiseCountOutputTypeSelect = {
    pack?: boolean
    users?: boolean
    task?: boolean
  }

  export type EntrepiseCountOutputTypeGetPayload<S extends boolean | null | undefined | EntrepiseCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EntrepiseCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EntrepiseCountOutputTypeArgs)
    ? EntrepiseCountOutputType 
    : S extends { select: any } & (EntrepiseCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EntrepiseCountOutputType ? EntrepiseCountOutputType[P] : never
  } 
      : EntrepiseCountOutputType




  // Custom InputTypes

  /**
   * EntrepiseCountOutputType without action
   */
  export type EntrepiseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EntrepiseCountOutputType
     */
    select?: EntrepiseCountOutputTypeSelect | null
  }



  /**
   * Count Type RecetteCountOutputType
   */


  export type RecetteCountOutputType = {
    commande: number
    recetteingr: number
  }

  export type RecetteCountOutputTypeSelect = {
    commande?: boolean
    recetteingr?: boolean
  }

  export type RecetteCountOutputTypeGetPayload<S extends boolean | null | undefined | RecetteCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RecetteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RecetteCountOutputTypeArgs)
    ? RecetteCountOutputType 
    : S extends { select: any } & (RecetteCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RecetteCountOutputType ? RecetteCountOutputType[P] : never
  } 
      : RecetteCountOutputType




  // Custom InputTypes

  /**
   * RecetteCountOutputType without action
   */
  export type RecetteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RecetteCountOutputType
     */
    select?: RecetteCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    task: number
  }

  export type UsersCountOutputTypeSelect = {
    task?: boolean
  }

  export type UsersCountOutputTypeGetPayload<S extends boolean | null | undefined | UsersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsersCountOutputTypeArgs)
    ? UsersCountOutputType 
    : S extends { select: any } & (UsersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
      : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type TypetaskCountOutputType
   */


  export type TypetaskCountOutputType = {
    task: number
  }

  export type TypetaskCountOutputTypeSelect = {
    task?: boolean
  }

  export type TypetaskCountOutputTypeGetPayload<S extends boolean | null | undefined | TypetaskCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypetaskCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TypetaskCountOutputTypeArgs)
    ? TypetaskCountOutputType 
    : S extends { select: any } & (TypetaskCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypetaskCountOutputType ? TypetaskCountOutputType[P] : never
  } 
      : TypetaskCountOutputType




  // Custom InputTypes

  /**
   * TypetaskCountOutputType without action
   */
  export type TypetaskCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TypetaskCountOutputType
     */
    select?: TypetaskCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model categorysensors
   */


  export type AggregateCategorysensors = {
    _count: CategorysensorsCountAggregateOutputType | null
    _avg: CategorysensorsAvgAggregateOutputType | null
    _sum: CategorysensorsSumAggregateOutputType | null
    _min: CategorysensorsMinAggregateOutputType | null
    _max: CategorysensorsMaxAggregateOutputType | null
  }

  export type CategorysensorsAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorysensorsSumAggregateOutputType = {
    id: number | null
  }

  export type CategorysensorsMinAggregateOutputType = {
    id: number | null
    sensor: string | null
  }

  export type CategorysensorsMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
  }

  export type CategorysensorsCountAggregateOutputType = {
    id: number
    sensor: number
    _all: number
  }


  export type CategorysensorsAvgAggregateInputType = {
    id?: true
  }

  export type CategorysensorsSumAggregateInputType = {
    id?: true
  }

  export type CategorysensorsMinAggregateInputType = {
    id?: true
    sensor?: true
  }

  export type CategorysensorsMaxAggregateInputType = {
    id?: true
    sensor?: true
  }

  export type CategorysensorsCountAggregateInputType = {
    id?: true
    sensor?: true
    _all?: true
  }

  export type CategorysensorsAggregateArgs = {
    /**
     * Filter which categorysensors to aggregate.
     */
    where?: categorysensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorysensors to fetch.
     */
    orderBy?: Enumerable<categorysensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categorysensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorysensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorysensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorysensors
    **/
    _count?: true | CategorysensorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategorysensorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorysensorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategorysensorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategorysensorsMaxAggregateInputType
  }

  export type GetCategorysensorsAggregateType<T extends CategorysensorsAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorysensors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorysensors[P]>
      : GetScalarType<T[P], AggregateCategorysensors[P]>
  }




  export type CategorysensorsGroupByArgs = {
    where?: categorysensorsWhereInput
    orderBy?: Enumerable<categorysensorsOrderByWithAggregationInput>
    by: CategorysensorsScalarFieldEnum[]
    having?: categorysensorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategorysensorsCountAggregateInputType | true
    _avg?: CategorysensorsAvgAggregateInputType
    _sum?: CategorysensorsSumAggregateInputType
    _min?: CategorysensorsMinAggregateInputType
    _max?: CategorysensorsMaxAggregateInputType
  }


  export type CategorysensorsGroupByOutputType = {
    id: number
    sensor: string | null
    _count: CategorysensorsCountAggregateOutputType | null
    _avg: CategorysensorsAvgAggregateOutputType | null
    _sum: CategorysensorsSumAggregateOutputType | null
    _min: CategorysensorsMinAggregateOutputType | null
    _max: CategorysensorsMaxAggregateOutputType | null
  }

  type GetCategorysensorsGroupByPayload<T extends CategorysensorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategorysensorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategorysensorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategorysensorsGroupByOutputType[P]>
            : GetScalarType<T[P], CategorysensorsGroupByOutputType[P]>
        }
      >
    >


  export type categorysensorsSelect = {
    id?: boolean
    sensor?: boolean
    sensors?: boolean | categorysensors$sensorsArgs
    _count?: boolean | CategorysensorsCountOutputTypeArgs
  }


  export type categorysensorsInclude = {
    sensors?: boolean | categorysensors$sensorsArgs
    _count?: boolean | CategorysensorsCountOutputTypeArgs
  }

  export type categorysensorsGetPayload<S extends boolean | null | undefined | categorysensorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? categorysensors :
    S extends undefined ? never :
    S extends { include: any } & (categorysensorsArgs | categorysensorsFindManyArgs)
    ? categorysensors  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sensors' ? Array < sensorsGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategorysensorsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (categorysensorsArgs | categorysensorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sensors' ? Array < sensorsGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategorysensorsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof categorysensors ? categorysensors[P] : never
  } 
      : categorysensors


  type categorysensorsCountArgs = 
    Omit<categorysensorsFindManyArgs, 'select' | 'include'> & {
      select?: CategorysensorsCountAggregateInputType | true
    }

  export interface categorysensorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Categorysensors that matches the filter.
     * @param {categorysensorsFindUniqueArgs} args - Arguments to find a Categorysensors
     * @example
     * // Get one Categorysensors
     * const categorysensors = await prisma.categorysensors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categorysensorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categorysensorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categorysensors'> extends True ? Prisma__categorysensorsClient<categorysensorsGetPayload<T>> : Prisma__categorysensorsClient<categorysensorsGetPayload<T> | null, null>

    /**
     * Find one Categorysensors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categorysensorsFindUniqueOrThrowArgs} args - Arguments to find a Categorysensors
     * @example
     * // Get one Categorysensors
     * const categorysensors = await prisma.categorysensors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categorysensorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categorysensorsFindUniqueOrThrowArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Find the first Categorysensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorysensorsFindFirstArgs} args - Arguments to find a Categorysensors
     * @example
     * // Get one Categorysensors
     * const categorysensors = await prisma.categorysensors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categorysensorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categorysensorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categorysensors'> extends True ? Prisma__categorysensorsClient<categorysensorsGetPayload<T>> : Prisma__categorysensorsClient<categorysensorsGetPayload<T> | null, null>

    /**
     * Find the first Categorysensors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorysensorsFindFirstOrThrowArgs} args - Arguments to find a Categorysensors
     * @example
     * // Get one Categorysensors
     * const categorysensors = await prisma.categorysensors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categorysensorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categorysensorsFindFirstOrThrowArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Find zero or more Categorysensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorysensorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorysensors
     * const categorysensors = await prisma.categorysensors.findMany()
     * 
     * // Get first 10 Categorysensors
     * const categorysensors = await prisma.categorysensors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categorysensorsWithIdOnly = await prisma.categorysensors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categorysensorsFindManyArgs>(
      args?: SelectSubset<T, categorysensorsFindManyArgs>
    ): Prisma.PrismaPromise<Array<categorysensorsGetPayload<T>>>

    /**
     * Create a Categorysensors.
     * @param {categorysensorsCreateArgs} args - Arguments to create a Categorysensors.
     * @example
     * // Create one Categorysensors
     * const Categorysensors = await prisma.categorysensors.create({
     *   data: {
     *     // ... data to create a Categorysensors
     *   }
     * })
     * 
    **/
    create<T extends categorysensorsCreateArgs>(
      args: SelectSubset<T, categorysensorsCreateArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Create many Categorysensors.
     *     @param {categorysensorsCreateManyArgs} args - Arguments to create many Categorysensors.
     *     @example
     *     // Create many Categorysensors
     *     const categorysensors = await prisma.categorysensors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categorysensorsCreateManyArgs>(
      args?: SelectSubset<T, categorysensorsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categorysensors.
     * @param {categorysensorsDeleteArgs} args - Arguments to delete one Categorysensors.
     * @example
     * // Delete one Categorysensors
     * const Categorysensors = await prisma.categorysensors.delete({
     *   where: {
     *     // ... filter to delete one Categorysensors
     *   }
     * })
     * 
    **/
    delete<T extends categorysensorsDeleteArgs>(
      args: SelectSubset<T, categorysensorsDeleteArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Update one Categorysensors.
     * @param {categorysensorsUpdateArgs} args - Arguments to update one Categorysensors.
     * @example
     * // Update one Categorysensors
     * const categorysensors = await prisma.categorysensors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categorysensorsUpdateArgs>(
      args: SelectSubset<T, categorysensorsUpdateArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Delete zero or more Categorysensors.
     * @param {categorysensorsDeleteManyArgs} args - Arguments to filter Categorysensors to delete.
     * @example
     * // Delete a few Categorysensors
     * const { count } = await prisma.categorysensors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categorysensorsDeleteManyArgs>(
      args?: SelectSubset<T, categorysensorsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorysensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorysensorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorysensors
     * const categorysensors = await prisma.categorysensors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categorysensorsUpdateManyArgs>(
      args: SelectSubset<T, categorysensorsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categorysensors.
     * @param {categorysensorsUpsertArgs} args - Arguments to update or create a Categorysensors.
     * @example
     * // Update or create a Categorysensors
     * const categorysensors = await prisma.categorysensors.upsert({
     *   create: {
     *     // ... data to create a Categorysensors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorysensors we want to update
     *   }
     * })
    **/
    upsert<T extends categorysensorsUpsertArgs>(
      args: SelectSubset<T, categorysensorsUpsertArgs>
    ): Prisma__categorysensorsClient<categorysensorsGetPayload<T>>

    /**
     * Count the number of Categorysensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorysensorsCountArgs} args - Arguments to filter Categorysensors to count.
     * @example
     * // Count the number of Categorysensors
     * const count = await prisma.categorysensors.count({
     *   where: {
     *     // ... the filter for the Categorysensors we want to count
     *   }
     * })
    **/
    count<T extends categorysensorsCountArgs>(
      args?: Subset<T, categorysensorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategorysensorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorysensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorysensorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategorysensorsAggregateArgs>(args: Subset<T, CategorysensorsAggregateArgs>): Prisma.PrismaPromise<GetCategorysensorsAggregateType<T>>

    /**
     * Group by Categorysensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorysensorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategorysensorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategorysensorsGroupByArgs['orderBy'] }
        : { orderBy?: CategorysensorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategorysensorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategorysensorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categorysensors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categorysensorsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sensors<T extends categorysensors$sensorsArgs= {}>(args?: Subset<T, categorysensors$sensorsArgs>): Prisma.PrismaPromise<Array<sensorsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categorysensors base type for findUnique actions
   */
  export type categorysensorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter, which categorysensors to fetch.
     */
    where: categorysensorsWhereUniqueInput
  }

  /**
   * categorysensors findUnique
   */
  export interface categorysensorsFindUniqueArgs extends categorysensorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorysensors findUniqueOrThrow
   */
  export type categorysensorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter, which categorysensors to fetch.
     */
    where: categorysensorsWhereUniqueInput
  }


  /**
   * categorysensors base type for findFirst actions
   */
  export type categorysensorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter, which categorysensors to fetch.
     */
    where?: categorysensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorysensors to fetch.
     */
    orderBy?: Enumerable<categorysensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorysensors.
     */
    cursor?: categorysensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorysensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorysensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorysensors.
     */
    distinct?: Enumerable<CategorysensorsScalarFieldEnum>
  }

  /**
   * categorysensors findFirst
   */
  export interface categorysensorsFindFirstArgs extends categorysensorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorysensors findFirstOrThrow
   */
  export type categorysensorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter, which categorysensors to fetch.
     */
    where?: categorysensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorysensors to fetch.
     */
    orderBy?: Enumerable<categorysensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorysensors.
     */
    cursor?: categorysensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorysensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorysensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorysensors.
     */
    distinct?: Enumerable<CategorysensorsScalarFieldEnum>
  }


  /**
   * categorysensors findMany
   */
  export type categorysensorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter, which categorysensors to fetch.
     */
    where?: categorysensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorysensors to fetch.
     */
    orderBy?: Enumerable<categorysensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorysensors.
     */
    cursor?: categorysensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorysensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorysensors.
     */
    skip?: number
    distinct?: Enumerable<CategorysensorsScalarFieldEnum>
  }


  /**
   * categorysensors create
   */
  export type categorysensorsCreateArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * The data needed to create a categorysensors.
     */
    data: XOR<categorysensorsCreateInput, categorysensorsUncheckedCreateInput>
  }


  /**
   * categorysensors createMany
   */
  export type categorysensorsCreateManyArgs = {
    /**
     * The data used to create many categorysensors.
     */
    data: Enumerable<categorysensorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categorysensors update
   */
  export type categorysensorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * The data needed to update a categorysensors.
     */
    data: XOR<categorysensorsUpdateInput, categorysensorsUncheckedUpdateInput>
    /**
     * Choose, which categorysensors to update.
     */
    where: categorysensorsWhereUniqueInput
  }


  /**
   * categorysensors updateMany
   */
  export type categorysensorsUpdateManyArgs = {
    /**
     * The data used to update categorysensors.
     */
    data: XOR<categorysensorsUpdateManyMutationInput, categorysensorsUncheckedUpdateManyInput>
    /**
     * Filter which categorysensors to update
     */
    where?: categorysensorsWhereInput
  }


  /**
   * categorysensors upsert
   */
  export type categorysensorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * The filter to search for the categorysensors to update in case it exists.
     */
    where: categorysensorsWhereUniqueInput
    /**
     * In case the categorysensors found by the `where` argument doesn't exist, create a new categorysensors with this data.
     */
    create: XOR<categorysensorsCreateInput, categorysensorsUncheckedCreateInput>
    /**
     * In case the categorysensors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categorysensorsUpdateInput, categorysensorsUncheckedUpdateInput>
  }


  /**
   * categorysensors delete
   */
  export type categorysensorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
    /**
     * Filter which categorysensors to delete.
     */
    where: categorysensorsWhereUniqueInput
  }


  /**
   * categorysensors deleteMany
   */
  export type categorysensorsDeleteManyArgs = {
    /**
     * Filter which categorysensors to delete
     */
    where?: categorysensorsWhereInput
  }


  /**
   * categorysensors.sensors
   */
  export type categorysensors$sensorsArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    where?: sensorsWhereInput
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    cursor?: sensorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SensorsScalarFieldEnum>
  }


  /**
   * categorysensors without action
   */
  export type categorysensorsArgs = {
    /**
     * Select specific fields to fetch from the categorysensors
     */
    select?: categorysensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categorysensorsInclude | null
  }



  /**
   * Model sensors
   */


  export type AggregateSensors = {
    _count: SensorsCountAggregateOutputType | null
    _avg: SensorsAvgAggregateOutputType | null
    _sum: SensorsSumAggregateOutputType | null
    _min: SensorsMinAggregateOutputType | null
    _max: SensorsMaxAggregateOutputType | null
  }

  export type SensorsAvgAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idSensor: number | null
  }

  export type SensorsSumAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idSensor: number | null
  }

  export type SensorsMinAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idSensor: number | null
    value: string | null
  }

  export type SensorsMaxAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idSensor: number | null
    value: string | null
  }

  export type SensorsCountAggregateOutputType = {
    id: number
    idDistr: number
    idSensor: number
    value: number
    _all: number
  }


  export type SensorsAvgAggregateInputType = {
    id?: true
    idDistr?: true
    idSensor?: true
  }

  export type SensorsSumAggregateInputType = {
    id?: true
    idDistr?: true
    idSensor?: true
  }

  export type SensorsMinAggregateInputType = {
    id?: true
    idDistr?: true
    idSensor?: true
    value?: true
  }

  export type SensorsMaxAggregateInputType = {
    id?: true
    idDistr?: true
    idSensor?: true
    value?: true
  }

  export type SensorsCountAggregateInputType = {
    id?: true
    idDistr?: true
    idSensor?: true
    value?: true
    _all?: true
  }

  export type SensorsAggregateArgs = {
    /**
     * Filter which sensors to aggregate.
     */
    where?: sensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sensors to fetch.
     */
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sensors
    **/
    _count?: true | SensorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorsMaxAggregateInputType
  }

  export type GetSensorsAggregateType<T extends SensorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSensors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensors[P]>
      : GetScalarType<T[P], AggregateSensors[P]>
  }




  export type SensorsGroupByArgs = {
    where?: sensorsWhereInput
    orderBy?: Enumerable<sensorsOrderByWithAggregationInput>
    by: SensorsScalarFieldEnum[]
    having?: sensorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorsCountAggregateInputType | true
    _avg?: SensorsAvgAggregateInputType
    _sum?: SensorsSumAggregateInputType
    _min?: SensorsMinAggregateInputType
    _max?: SensorsMaxAggregateInputType
  }


  export type SensorsGroupByOutputType = {
    id: number
    idDistr: number
    idSensor: number
    value: string
    _count: SensorsCountAggregateOutputType | null
    _avg: SensorsAvgAggregateOutputType | null
    _sum: SensorsSumAggregateOutputType | null
    _min: SensorsMinAggregateOutputType | null
    _max: SensorsMaxAggregateOutputType | null
  }

  type GetSensorsGroupByPayload<T extends SensorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SensorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorsGroupByOutputType[P]>
            : GetScalarType<T[P], SensorsGroupByOutputType[P]>
        }
      >
    >


  export type sensorsSelect = {
    id?: boolean
    idDistr?: boolean
    idSensor?: boolean
    value?: boolean
    distr?: boolean | distributeurArgs
    categorysensors?: boolean | categorysensorsArgs
  }


  export type sensorsInclude = {
    distr?: boolean | distributeurArgs
    categorysensors?: boolean | categorysensorsArgs
  }

  export type sensorsGetPayload<S extends boolean | null | undefined | sensorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sensors :
    S extends undefined ? never :
    S extends { include: any } & (sensorsArgs | sensorsFindManyArgs)
    ? sensors  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'distr' ? distributeurGetPayload<S['include'][P]> :
        P extends 'categorysensors' ? categorysensorsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (sensorsArgs | sensorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'distr' ? distributeurGetPayload<S['select'][P]> :
        P extends 'categorysensors' ? categorysensorsGetPayload<S['select'][P]> :  P extends keyof sensors ? sensors[P] : never
  } 
      : sensors


  type sensorsCountArgs = 
    Omit<sensorsFindManyArgs, 'select' | 'include'> & {
      select?: SensorsCountAggregateInputType | true
    }

  export interface sensorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sensors that matches the filter.
     * @param {sensorsFindUniqueArgs} args - Arguments to find a Sensors
     * @example
     * // Get one Sensors
     * const sensors = await prisma.sensors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sensorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sensorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sensors'> extends True ? Prisma__sensorsClient<sensorsGetPayload<T>> : Prisma__sensorsClient<sensorsGetPayload<T> | null, null>

    /**
     * Find one Sensors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sensorsFindUniqueOrThrowArgs} args - Arguments to find a Sensors
     * @example
     * // Get one Sensors
     * const sensors = await prisma.sensors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sensorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sensorsFindUniqueOrThrowArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Find the first Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sensorsFindFirstArgs} args - Arguments to find a Sensors
     * @example
     * // Get one Sensors
     * const sensors = await prisma.sensors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sensorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sensorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sensors'> extends True ? Prisma__sensorsClient<sensorsGetPayload<T>> : Prisma__sensorsClient<sensorsGetPayload<T> | null, null>

    /**
     * Find the first Sensors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sensorsFindFirstOrThrowArgs} args - Arguments to find a Sensors
     * @example
     * // Get one Sensors
     * const sensors = await prisma.sensors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sensorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sensorsFindFirstOrThrowArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Find zero or more Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sensorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sensors
     * const sensors = await prisma.sensors.findMany()
     * 
     * // Get first 10 Sensors
     * const sensors = await prisma.sensors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorsWithIdOnly = await prisma.sensors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sensorsFindManyArgs>(
      args?: SelectSubset<T, sensorsFindManyArgs>
    ): Prisma.PrismaPromise<Array<sensorsGetPayload<T>>>

    /**
     * Create a Sensors.
     * @param {sensorsCreateArgs} args - Arguments to create a Sensors.
     * @example
     * // Create one Sensors
     * const Sensors = await prisma.sensors.create({
     *   data: {
     *     // ... data to create a Sensors
     *   }
     * })
     * 
    **/
    create<T extends sensorsCreateArgs>(
      args: SelectSubset<T, sensorsCreateArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Create many Sensors.
     *     @param {sensorsCreateManyArgs} args - Arguments to create many Sensors.
     *     @example
     *     // Create many Sensors
     *     const sensors = await prisma.sensors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sensorsCreateManyArgs>(
      args?: SelectSubset<T, sensorsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sensors.
     * @param {sensorsDeleteArgs} args - Arguments to delete one Sensors.
     * @example
     * // Delete one Sensors
     * const Sensors = await prisma.sensors.delete({
     *   where: {
     *     // ... filter to delete one Sensors
     *   }
     * })
     * 
    **/
    delete<T extends sensorsDeleteArgs>(
      args: SelectSubset<T, sensorsDeleteArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Update one Sensors.
     * @param {sensorsUpdateArgs} args - Arguments to update one Sensors.
     * @example
     * // Update one Sensors
     * const sensors = await prisma.sensors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sensorsUpdateArgs>(
      args: SelectSubset<T, sensorsUpdateArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Delete zero or more Sensors.
     * @param {sensorsDeleteManyArgs} args - Arguments to filter Sensors to delete.
     * @example
     * // Delete a few Sensors
     * const { count } = await prisma.sensors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sensorsDeleteManyArgs>(
      args?: SelectSubset<T, sensorsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sensorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sensors
     * const sensors = await prisma.sensors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sensorsUpdateManyArgs>(
      args: SelectSubset<T, sensorsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sensors.
     * @param {sensorsUpsertArgs} args - Arguments to update or create a Sensors.
     * @example
     * // Update or create a Sensors
     * const sensors = await prisma.sensors.upsert({
     *   create: {
     *     // ... data to create a Sensors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sensors we want to update
     *   }
     * })
    **/
    upsert<T extends sensorsUpsertArgs>(
      args: SelectSubset<T, sensorsUpsertArgs>
    ): Prisma__sensorsClient<sensorsGetPayload<T>>

    /**
     * Count the number of Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sensorsCountArgs} args - Arguments to filter Sensors to count.
     * @example
     * // Count the number of Sensors
     * const count = await prisma.sensors.count({
     *   where: {
     *     // ... the filter for the Sensors we want to count
     *   }
     * })
    **/
    count<T extends sensorsCountArgs>(
      args?: Subset<T, sensorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorsAggregateArgs>(args: Subset<T, SensorsAggregateArgs>): Prisma.PrismaPromise<GetSensorsAggregateType<T>>

    /**
     * Group by Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorsGroupByArgs['orderBy'] }
        : { orderBy?: SensorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sensors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sensorsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    distr<T extends distributeurArgs= {}>(args?: Subset<T, distributeurArgs>): Prisma__distributeurClient<distributeurGetPayload<T> | Null>;

    categorysensors<T extends categorysensorsArgs= {}>(args?: Subset<T, categorysensorsArgs>): Prisma__categorysensorsClient<categorysensorsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sensors base type for findUnique actions
   */
  export type sensorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter, which sensors to fetch.
     */
    where: sensorsWhereUniqueInput
  }

  /**
   * sensors findUnique
   */
  export interface sensorsFindUniqueArgs extends sensorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sensors findUniqueOrThrow
   */
  export type sensorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter, which sensors to fetch.
     */
    where: sensorsWhereUniqueInput
  }


  /**
   * sensors base type for findFirst actions
   */
  export type sensorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter, which sensors to fetch.
     */
    where?: sensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sensors to fetch.
     */
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sensors.
     */
    cursor?: sensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sensors.
     */
    distinct?: Enumerable<SensorsScalarFieldEnum>
  }

  /**
   * sensors findFirst
   */
  export interface sensorsFindFirstArgs extends sensorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sensors findFirstOrThrow
   */
  export type sensorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter, which sensors to fetch.
     */
    where?: sensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sensors to fetch.
     */
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sensors.
     */
    cursor?: sensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sensors.
     */
    distinct?: Enumerable<SensorsScalarFieldEnum>
  }


  /**
   * sensors findMany
   */
  export type sensorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter, which sensors to fetch.
     */
    where?: sensorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sensors to fetch.
     */
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sensors.
     */
    cursor?: sensorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sensors.
     */
    skip?: number
    distinct?: Enumerable<SensorsScalarFieldEnum>
  }


  /**
   * sensors create
   */
  export type sensorsCreateArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * The data needed to create a sensors.
     */
    data: XOR<sensorsCreateInput, sensorsUncheckedCreateInput>
  }


  /**
   * sensors createMany
   */
  export type sensorsCreateManyArgs = {
    /**
     * The data used to create many sensors.
     */
    data: Enumerable<sensorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sensors update
   */
  export type sensorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * The data needed to update a sensors.
     */
    data: XOR<sensorsUpdateInput, sensorsUncheckedUpdateInput>
    /**
     * Choose, which sensors to update.
     */
    where: sensorsWhereUniqueInput
  }


  /**
   * sensors updateMany
   */
  export type sensorsUpdateManyArgs = {
    /**
     * The data used to update sensors.
     */
    data: XOR<sensorsUpdateManyMutationInput, sensorsUncheckedUpdateManyInput>
    /**
     * Filter which sensors to update
     */
    where?: sensorsWhereInput
  }


  /**
   * sensors upsert
   */
  export type sensorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * The filter to search for the sensors to update in case it exists.
     */
    where: sensorsWhereUniqueInput
    /**
     * In case the sensors found by the `where` argument doesn't exist, create a new sensors with this data.
     */
    create: XOR<sensorsCreateInput, sensorsUncheckedCreateInput>
    /**
     * In case the sensors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sensorsUpdateInput, sensorsUncheckedUpdateInput>
  }


  /**
   * sensors delete
   */
  export type sensorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    /**
     * Filter which sensors to delete.
     */
    where: sensorsWhereUniqueInput
  }


  /**
   * sensors deleteMany
   */
  export type sensorsDeleteManyArgs = {
    /**
     * Filter which sensors to delete
     */
    where?: sensorsWhereInput
  }


  /**
   * sensors without action
   */
  export type sensorsArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
  }



  /**
   * Model categorie
   */


  export type AggregateCategorie = {
    _count: CategorieCountAggregateOutputType | null
    _avg: CategorieAvgAggregateOutputType | null
    _sum: CategorieSumAggregateOutputType | null
    _min: CategorieMinAggregateOutputType | null
    _max: CategorieMaxAggregateOutputType | null
  }

  export type CategorieAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorieSumAggregateOutputType = {
    id: number | null
  }

  export type CategorieMinAggregateOutputType = {
    id: number | null
    categorie: string | null
  }

  export type CategorieMaxAggregateOutputType = {
    id: number | null
    categorie: string | null
  }

  export type CategorieCountAggregateOutputType = {
    id: number
    categorie: number
    _all: number
  }


  export type CategorieAvgAggregateInputType = {
    id?: true
  }

  export type CategorieSumAggregateInputType = {
    id?: true
  }

  export type CategorieMinAggregateInputType = {
    id?: true
    categorie?: true
  }

  export type CategorieMaxAggregateInputType = {
    id?: true
    categorie?: true
  }

  export type CategorieCountAggregateInputType = {
    id?: true
    categorie?: true
    _all?: true
  }

  export type CategorieAggregateArgs = {
    /**
     * Filter which categorie to aggregate.
     */
    where?: categorieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categorieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categorieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategorieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategorieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategorieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategorieMaxAggregateInputType
  }

  export type GetCategorieAggregateType<T extends CategorieAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorie[P]>
      : GetScalarType<T[P], AggregateCategorie[P]>
  }




  export type CategorieGroupByArgs = {
    where?: categorieWhereInput
    orderBy?: Enumerable<categorieOrderByWithAggregationInput>
    by: CategorieScalarFieldEnum[]
    having?: categorieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategorieCountAggregateInputType | true
    _avg?: CategorieAvgAggregateInputType
    _sum?: CategorieSumAggregateInputType
    _min?: CategorieMinAggregateInputType
    _max?: CategorieMaxAggregateInputType
  }


  export type CategorieGroupByOutputType = {
    id: number
    categorie: string | null
    _count: CategorieCountAggregateOutputType | null
    _avg: CategorieAvgAggregateOutputType | null
    _sum: CategorieSumAggregateOutputType | null
    _min: CategorieMinAggregateOutputType | null
    _max: CategorieMaxAggregateOutputType | null
  }

  type GetCategorieGroupByPayload<T extends CategorieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategorieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategorieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategorieGroupByOutputType[P]>
            : GetScalarType<T[P], CategorieGroupByOutputType[P]>
        }
      >
    >


  export type categorieSelect = {
    id?: boolean
    categorie?: boolean
  }


  export type categorieGetPayload<S extends boolean | null | undefined | categorieArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? categorie :
    S extends undefined ? never :
    S extends { include: any } & (categorieArgs | categorieFindManyArgs)
    ? categorie 
    : S extends { select: any } & (categorieArgs | categorieFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof categorie ? categorie[P] : never
  } 
      : categorie


  type categorieCountArgs = 
    Omit<categorieFindManyArgs, 'select' | 'include'> & {
      select?: CategorieCountAggregateInputType | true
    }

  export interface categorieDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Categorie that matches the filter.
     * @param {categorieFindUniqueArgs} args - Arguments to find a Categorie
     * @example
     * // Get one Categorie
     * const categorie = await prisma.categorie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categorieFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categorieFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categorie'> extends True ? Prisma__categorieClient<categorieGetPayload<T>> : Prisma__categorieClient<categorieGetPayload<T> | null, null>

    /**
     * Find one Categorie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categorieFindUniqueOrThrowArgs} args - Arguments to find a Categorie
     * @example
     * // Get one Categorie
     * const categorie = await prisma.categorie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categorieFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categorieFindUniqueOrThrowArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Find the first Categorie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorieFindFirstArgs} args - Arguments to find a Categorie
     * @example
     * // Get one Categorie
     * const categorie = await prisma.categorie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categorieFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categorieFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categorie'> extends True ? Prisma__categorieClient<categorieGetPayload<T>> : Prisma__categorieClient<categorieGetPayload<T> | null, null>

    /**
     * Find the first Categorie that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorieFindFirstOrThrowArgs} args - Arguments to find a Categorie
     * @example
     * // Get one Categorie
     * const categorie = await prisma.categorie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categorieFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categorieFindFirstOrThrowArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categorie.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categorie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categorieWithIdOnly = await prisma.categorie.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categorieFindManyArgs>(
      args?: SelectSubset<T, categorieFindManyArgs>
    ): Prisma.PrismaPromise<Array<categorieGetPayload<T>>>

    /**
     * Create a Categorie.
     * @param {categorieCreateArgs} args - Arguments to create a Categorie.
     * @example
     * // Create one Categorie
     * const Categorie = await prisma.categorie.create({
     *   data: {
     *     // ... data to create a Categorie
     *   }
     * })
     * 
    **/
    create<T extends categorieCreateArgs>(
      args: SelectSubset<T, categorieCreateArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {categorieCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const categorie = await prisma.categorie.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categorieCreateManyArgs>(
      args?: SelectSubset<T, categorieCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categorie.
     * @param {categorieDeleteArgs} args - Arguments to delete one Categorie.
     * @example
     * // Delete one Categorie
     * const Categorie = await prisma.categorie.delete({
     *   where: {
     *     // ... filter to delete one Categorie
     *   }
     * })
     * 
    **/
    delete<T extends categorieDeleteArgs>(
      args: SelectSubset<T, categorieDeleteArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Update one Categorie.
     * @param {categorieUpdateArgs} args - Arguments to update one Categorie.
     * @example
     * // Update one Categorie
     * const categorie = await prisma.categorie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categorieUpdateArgs>(
      args: SelectSubset<T, categorieUpdateArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {categorieDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categorie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categorieDeleteManyArgs>(
      args?: SelectSubset<T, categorieDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categorie = await prisma.categorie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categorieUpdateManyArgs>(
      args: SelectSubset<T, categorieUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categorie.
     * @param {categorieUpsertArgs} args - Arguments to update or create a Categorie.
     * @example
     * // Update or create a Categorie
     * const categorie = await prisma.categorie.upsert({
     *   create: {
     *     // ... data to create a Categorie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorie we want to update
     *   }
     * })
    **/
    upsert<T extends categorieUpsertArgs>(
      args: SelectSubset<T, categorieUpsertArgs>
    ): Prisma__categorieClient<categorieGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categorieCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categorie.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categorieCountArgs>(
      args?: Subset<T, categorieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategorieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategorieAggregateArgs>(args: Subset<T, CategorieAggregateArgs>): Prisma.PrismaPromise<GetCategorieAggregateType<T>>

    /**
     * Group by Categorie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategorieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategorieGroupByArgs['orderBy'] }
        : { orderBy?: CategorieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategorieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategorieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categorie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categorieClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categorie base type for findUnique actions
   */
  export type categorieFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter, which categorie to fetch.
     */
    where: categorieWhereUniqueInput
  }

  /**
   * categorie findUnique
   */
  export interface categorieFindUniqueArgs extends categorieFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorie findUniqueOrThrow
   */
  export type categorieFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter, which categorie to fetch.
     */
    where: categorieWhereUniqueInput
  }


  /**
   * categorie base type for findFirst actions
   */
  export type categorieFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter, which categorie to fetch.
     */
    where?: categorieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categorieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categorieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: Enumerable<CategorieScalarFieldEnum>
  }

  /**
   * categorie findFirst
   */
  export interface categorieFindFirstArgs extends categorieFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categorie findFirstOrThrow
   */
  export type categorieFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter, which categorie to fetch.
     */
    where?: categorieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categorieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categorieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: Enumerable<CategorieScalarFieldEnum>
  }


  /**
   * categorie findMany
   */
  export type categorieFindManyArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categorieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categorieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categorieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: Enumerable<CategorieScalarFieldEnum>
  }


  /**
   * categorie create
   */
  export type categorieCreateArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * The data needed to create a categorie.
     */
    data: XOR<categorieCreateInput, categorieUncheckedCreateInput>
  }


  /**
   * categorie createMany
   */
  export type categorieCreateManyArgs = {
    /**
     * The data used to create many categories.
     */
    data: Enumerable<categorieCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categorie update
   */
  export type categorieUpdateArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * The data needed to update a categorie.
     */
    data: XOR<categorieUpdateInput, categorieUncheckedUpdateInput>
    /**
     * Choose, which categorie to update.
     */
    where: categorieWhereUniqueInput
  }


  /**
   * categorie updateMany
   */
  export type categorieUpdateManyArgs = {
    /**
     * The data used to update categories.
     */
    data: XOR<categorieUpdateManyMutationInput, categorieUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categorieWhereInput
  }


  /**
   * categorie upsert
   */
  export type categorieUpsertArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * The filter to search for the categorie to update in case it exists.
     */
    where: categorieWhereUniqueInput
    /**
     * In case the categorie found by the `where` argument doesn't exist, create a new categorie with this data.
     */
    create: XOR<categorieCreateInput, categorieUncheckedCreateInput>
    /**
     * In case the categorie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categorieUpdateInput, categorieUncheckedUpdateInput>
  }


  /**
   * categorie delete
   */
  export type categorieDeleteArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
    /**
     * Filter which categorie to delete.
     */
    where: categorieWhereUniqueInput
  }


  /**
   * categorie deleteMany
   */
  export type categorieDeleteManyArgs = {
    /**
     * Filter which categories to delete
     */
    where?: categorieWhereInput
  }


  /**
   * categorie without action
   */
  export type categorieArgs = {
    /**
     * Select specific fields to fetch from the categorie
     */
    select?: categorieSelect | null
  }



  /**
   * Model categoryrecette
   */


  export type AggregateCategoryrecette = {
    _count: CategoryrecetteCountAggregateOutputType | null
    _avg: CategoryrecetteAvgAggregateOutputType | null
    _sum: CategoryrecetteSumAggregateOutputType | null
    _min: CategoryrecetteMinAggregateOutputType | null
    _max: CategoryrecetteMaxAggregateOutputType | null
  }

  export type CategoryrecetteAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoryrecetteSumAggregateOutputType = {
    id: number | null
  }

  export type CategoryrecetteMinAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type CategoryrecetteMaxAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type CategoryrecetteCountAggregateOutputType = {
    id: number
    description: number
    _all: number
  }


  export type CategoryrecetteAvgAggregateInputType = {
    id?: true
  }

  export type CategoryrecetteSumAggregateInputType = {
    id?: true
  }

  export type CategoryrecetteMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type CategoryrecetteMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type CategoryrecetteCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type CategoryrecetteAggregateArgs = {
    /**
     * Filter which categoryrecette to aggregate.
     */
    where?: categoryrecetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryrecettes to fetch.
     */
    orderBy?: Enumerable<categoryrecetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryrecetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryrecettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryrecettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoryrecettes
    **/
    _count?: true | CategoryrecetteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryrecetteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryrecetteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryrecetteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryrecetteMaxAggregateInputType
  }

  export type GetCategoryrecetteAggregateType<T extends CategoryrecetteAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryrecette]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryrecette[P]>
      : GetScalarType<T[P], AggregateCategoryrecette[P]>
  }




  export type CategoryrecetteGroupByArgs = {
    where?: categoryrecetteWhereInput
    orderBy?: Enumerable<categoryrecetteOrderByWithAggregationInput>
    by: CategoryrecetteScalarFieldEnum[]
    having?: categoryrecetteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryrecetteCountAggregateInputType | true
    _avg?: CategoryrecetteAvgAggregateInputType
    _sum?: CategoryrecetteSumAggregateInputType
    _min?: CategoryrecetteMinAggregateInputType
    _max?: CategoryrecetteMaxAggregateInputType
  }


  export type CategoryrecetteGroupByOutputType = {
    id: number
    description: string | null
    _count: CategoryrecetteCountAggregateOutputType | null
    _avg: CategoryrecetteAvgAggregateOutputType | null
    _sum: CategoryrecetteSumAggregateOutputType | null
    _min: CategoryrecetteMinAggregateOutputType | null
    _max: CategoryrecetteMaxAggregateOutputType | null
  }

  type GetCategoryrecetteGroupByPayload<T extends CategoryrecetteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryrecetteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryrecetteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryrecetteGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryrecetteGroupByOutputType[P]>
        }
      >
    >


  export type categoryrecetteSelect = {
    id?: boolean
    description?: boolean
    recette?: boolean | categoryrecette$recetteArgs
    publicite?: boolean | categoryrecette$publiciteArgs
    _count?: boolean | CategoryrecetteCountOutputTypeArgs
  }


  export type categoryrecetteInclude = {
    recette?: boolean | categoryrecette$recetteArgs
    publicite?: boolean | categoryrecette$publiciteArgs
    _count?: boolean | CategoryrecetteCountOutputTypeArgs
  }

  export type categoryrecetteGetPayload<S extends boolean | null | undefined | categoryrecetteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? categoryrecette :
    S extends undefined ? never :
    S extends { include: any } & (categoryrecetteArgs | categoryrecetteFindManyArgs)
    ? categoryrecette  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recette' ? Array < recetteGetPayload<S['include'][P]>>  :
        P extends 'publicite' ? Array < publiciteGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryrecetteCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (categoryrecetteArgs | categoryrecetteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recette' ? Array < recetteGetPayload<S['select'][P]>>  :
        P extends 'publicite' ? Array < publiciteGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryrecetteCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof categoryrecette ? categoryrecette[P] : never
  } 
      : categoryrecette


  type categoryrecetteCountArgs = 
    Omit<categoryrecetteFindManyArgs, 'select' | 'include'> & {
      select?: CategoryrecetteCountAggregateInputType | true
    }

  export interface categoryrecetteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Categoryrecette that matches the filter.
     * @param {categoryrecetteFindUniqueArgs} args - Arguments to find a Categoryrecette
     * @example
     * // Get one Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryrecetteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoryrecetteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categoryrecette'> extends True ? Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>> : Prisma__categoryrecetteClient<categoryrecetteGetPayload<T> | null, null>

    /**
     * Find one Categoryrecette that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoryrecetteFindUniqueOrThrowArgs} args - Arguments to find a Categoryrecette
     * @example
     * // Get one Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryrecetteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categoryrecetteFindUniqueOrThrowArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Find the first Categoryrecette that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryrecetteFindFirstArgs} args - Arguments to find a Categoryrecette
     * @example
     * // Get one Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryrecetteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoryrecetteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categoryrecette'> extends True ? Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>> : Prisma__categoryrecetteClient<categoryrecetteGetPayload<T> | null, null>

    /**
     * Find the first Categoryrecette that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryrecetteFindFirstOrThrowArgs} args - Arguments to find a Categoryrecette
     * @example
     * // Get one Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryrecetteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categoryrecetteFindFirstOrThrowArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Find zero or more Categoryrecettes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryrecetteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoryrecettes
     * const categoryrecettes = await prisma.categoryrecette.findMany()
     * 
     * // Get first 10 Categoryrecettes
     * const categoryrecettes = await prisma.categoryrecette.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryrecetteWithIdOnly = await prisma.categoryrecette.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryrecetteFindManyArgs>(
      args?: SelectSubset<T, categoryrecetteFindManyArgs>
    ): Prisma.PrismaPromise<Array<categoryrecetteGetPayload<T>>>

    /**
     * Create a Categoryrecette.
     * @param {categoryrecetteCreateArgs} args - Arguments to create a Categoryrecette.
     * @example
     * // Create one Categoryrecette
     * const Categoryrecette = await prisma.categoryrecette.create({
     *   data: {
     *     // ... data to create a Categoryrecette
     *   }
     * })
     * 
    **/
    create<T extends categoryrecetteCreateArgs>(
      args: SelectSubset<T, categoryrecetteCreateArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Create many Categoryrecettes.
     *     @param {categoryrecetteCreateManyArgs} args - Arguments to create many Categoryrecettes.
     *     @example
     *     // Create many Categoryrecettes
     *     const categoryrecette = await prisma.categoryrecette.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryrecetteCreateManyArgs>(
      args?: SelectSubset<T, categoryrecetteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoryrecette.
     * @param {categoryrecetteDeleteArgs} args - Arguments to delete one Categoryrecette.
     * @example
     * // Delete one Categoryrecette
     * const Categoryrecette = await prisma.categoryrecette.delete({
     *   where: {
     *     // ... filter to delete one Categoryrecette
     *   }
     * })
     * 
    **/
    delete<T extends categoryrecetteDeleteArgs>(
      args: SelectSubset<T, categoryrecetteDeleteArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Update one Categoryrecette.
     * @param {categoryrecetteUpdateArgs} args - Arguments to update one Categoryrecette.
     * @example
     * // Update one Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryrecetteUpdateArgs>(
      args: SelectSubset<T, categoryrecetteUpdateArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Delete zero or more Categoryrecettes.
     * @param {categoryrecetteDeleteManyArgs} args - Arguments to filter Categoryrecettes to delete.
     * @example
     * // Delete a few Categoryrecettes
     * const { count } = await prisma.categoryrecette.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryrecetteDeleteManyArgs>(
      args?: SelectSubset<T, categoryrecetteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoryrecettes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryrecetteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoryrecettes
     * const categoryrecette = await prisma.categoryrecette.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryrecetteUpdateManyArgs>(
      args: SelectSubset<T, categoryrecetteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoryrecette.
     * @param {categoryrecetteUpsertArgs} args - Arguments to update or create a Categoryrecette.
     * @example
     * // Update or create a Categoryrecette
     * const categoryrecette = await prisma.categoryrecette.upsert({
     *   create: {
     *     // ... data to create a Categoryrecette
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoryrecette we want to update
     *   }
     * })
    **/
    upsert<T extends categoryrecetteUpsertArgs>(
      args: SelectSubset<T, categoryrecetteUpsertArgs>
    ): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T>>

    /**
     * Count the number of Categoryrecettes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryrecetteCountArgs} args - Arguments to filter Categoryrecettes to count.
     * @example
     * // Count the number of Categoryrecettes
     * const count = await prisma.categoryrecette.count({
     *   where: {
     *     // ... the filter for the Categoryrecettes we want to count
     *   }
     * })
    **/
    count<T extends categoryrecetteCountArgs>(
      args?: Subset<T, categoryrecetteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryrecetteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoryrecette.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryrecetteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryrecetteAggregateArgs>(args: Subset<T, CategoryrecetteAggregateArgs>): Prisma.PrismaPromise<GetCategoryrecetteAggregateType<T>>

    /**
     * Group by Categoryrecette.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryrecetteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryrecetteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryrecetteGroupByArgs['orderBy'] }
        : { orderBy?: CategoryrecetteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryrecetteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryrecetteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categoryrecette.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoryrecetteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    recette<T extends categoryrecette$recetteArgs= {}>(args?: Subset<T, categoryrecette$recetteArgs>): Prisma.PrismaPromise<Array<recetteGetPayload<T>>| Null>;

    publicite<T extends categoryrecette$publiciteArgs= {}>(args?: Subset<T, categoryrecette$publiciteArgs>): Prisma.PrismaPromise<Array<publiciteGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categoryrecette base type for findUnique actions
   */
  export type categoryrecetteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter, which categoryrecette to fetch.
     */
    where: categoryrecetteWhereUniqueInput
  }

  /**
   * categoryrecette findUnique
   */
  export interface categoryrecetteFindUniqueArgs extends categoryrecetteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoryrecette findUniqueOrThrow
   */
  export type categoryrecetteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter, which categoryrecette to fetch.
     */
    where: categoryrecetteWhereUniqueInput
  }


  /**
   * categoryrecette base type for findFirst actions
   */
  export type categoryrecetteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter, which categoryrecette to fetch.
     */
    where?: categoryrecetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryrecettes to fetch.
     */
    orderBy?: Enumerable<categoryrecetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoryrecettes.
     */
    cursor?: categoryrecetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryrecettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryrecettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoryrecettes.
     */
    distinct?: Enumerable<CategoryrecetteScalarFieldEnum>
  }

  /**
   * categoryrecette findFirst
   */
  export interface categoryrecetteFindFirstArgs extends categoryrecetteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoryrecette findFirstOrThrow
   */
  export type categoryrecetteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter, which categoryrecette to fetch.
     */
    where?: categoryrecetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryrecettes to fetch.
     */
    orderBy?: Enumerable<categoryrecetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoryrecettes.
     */
    cursor?: categoryrecetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryrecettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryrecettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoryrecettes.
     */
    distinct?: Enumerable<CategoryrecetteScalarFieldEnum>
  }


  /**
   * categoryrecette findMany
   */
  export type categoryrecetteFindManyArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter, which categoryrecettes to fetch.
     */
    where?: categoryrecetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryrecettes to fetch.
     */
    orderBy?: Enumerable<categoryrecetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoryrecettes.
     */
    cursor?: categoryrecetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryrecettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryrecettes.
     */
    skip?: number
    distinct?: Enumerable<CategoryrecetteScalarFieldEnum>
  }


  /**
   * categoryrecette create
   */
  export type categoryrecetteCreateArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * The data needed to create a categoryrecette.
     */
    data: XOR<categoryrecetteCreateInput, categoryrecetteUncheckedCreateInput>
  }


  /**
   * categoryrecette createMany
   */
  export type categoryrecetteCreateManyArgs = {
    /**
     * The data used to create many categoryrecettes.
     */
    data: Enumerable<categoryrecetteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categoryrecette update
   */
  export type categoryrecetteUpdateArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * The data needed to update a categoryrecette.
     */
    data: XOR<categoryrecetteUpdateInput, categoryrecetteUncheckedUpdateInput>
    /**
     * Choose, which categoryrecette to update.
     */
    where: categoryrecetteWhereUniqueInput
  }


  /**
   * categoryrecette updateMany
   */
  export type categoryrecetteUpdateManyArgs = {
    /**
     * The data used to update categoryrecettes.
     */
    data: XOR<categoryrecetteUpdateManyMutationInput, categoryrecetteUncheckedUpdateManyInput>
    /**
     * Filter which categoryrecettes to update
     */
    where?: categoryrecetteWhereInput
  }


  /**
   * categoryrecette upsert
   */
  export type categoryrecetteUpsertArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * The filter to search for the categoryrecette to update in case it exists.
     */
    where: categoryrecetteWhereUniqueInput
    /**
     * In case the categoryrecette found by the `where` argument doesn't exist, create a new categoryrecette with this data.
     */
    create: XOR<categoryrecetteCreateInput, categoryrecetteUncheckedCreateInput>
    /**
     * In case the categoryrecette was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryrecetteUpdateInput, categoryrecetteUncheckedUpdateInput>
  }


  /**
   * categoryrecette delete
   */
  export type categoryrecetteDeleteArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
    /**
     * Filter which categoryrecette to delete.
     */
    where: categoryrecetteWhereUniqueInput
  }


  /**
   * categoryrecette deleteMany
   */
  export type categoryrecetteDeleteManyArgs = {
    /**
     * Filter which categoryrecettes to delete
     */
    where?: categoryrecetteWhereInput
  }


  /**
   * categoryrecette.recette
   */
  export type categoryrecette$recetteArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    where?: recetteWhereInput
    orderBy?: Enumerable<recetteOrderByWithRelationInput>
    cursor?: recetteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RecetteScalarFieldEnum>
  }


  /**
   * categoryrecette.publicite
   */
  export type categoryrecette$publiciteArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    where?: publiciteWhereInput
    orderBy?: Enumerable<publiciteOrderByWithRelationInput>
    cursor?: publiciteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PubliciteScalarFieldEnum>
  }


  /**
   * categoryrecette without action
   */
  export type categoryrecetteArgs = {
    /**
     * Select specific fields to fetch from the categoryrecette
     */
    select?: categoryrecetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryrecetteInclude | null
  }



  /**
   * Model commande
   */


  export type AggregateCommande = {
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  export type CommandeAvgAggregateOutputType = {
    id: number | null
    idRecette: number | null
    idIngredient: number | null
  }

  export type CommandeSumAggregateOutputType = {
    id: number | null
    idRecette: number | null
    idIngredient: number | null
  }

  export type CommandeMinAggregateOutputType = {
    id: number | null
    idRecette: number | null
    idIngredient: number | null
    quantity: string | null
  }

  export type CommandeMaxAggregateOutputType = {
    id: number | null
    idRecette: number | null
    idIngredient: number | null
    quantity: string | null
  }

  export type CommandeCountAggregateOutputType = {
    id: number
    idRecette: number
    idIngredient: number
    quantity: number
    _all: number
  }


  export type CommandeAvgAggregateInputType = {
    id?: true
    idRecette?: true
    idIngredient?: true
  }

  export type CommandeSumAggregateInputType = {
    id?: true
    idRecette?: true
    idIngredient?: true
  }

  export type CommandeMinAggregateInputType = {
    id?: true
    idRecette?: true
    idIngredient?: true
    quantity?: true
  }

  export type CommandeMaxAggregateInputType = {
    id?: true
    idRecette?: true
    idIngredient?: true
    quantity?: true
  }

  export type CommandeCountAggregateInputType = {
    id?: true
    idRecette?: true
    idIngredient?: true
    quantity?: true
    _all?: true
  }

  export type CommandeAggregateArgs = {
    /**
     * Filter which commande to aggregate.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: Enumerable<commandeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commandes
    **/
    _count?: true | CommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeMaxAggregateInputType
  }

  export type GetCommandeAggregateType<T extends CommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommande[P]>
      : GetScalarType<T[P], AggregateCommande[P]>
  }




  export type CommandeGroupByArgs = {
    where?: commandeWhereInput
    orderBy?: Enumerable<commandeOrderByWithAggregationInput>
    by: CommandeScalarFieldEnum[]
    having?: commandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeCountAggregateInputType | true
    _avg?: CommandeAvgAggregateInputType
    _sum?: CommandeSumAggregateInputType
    _min?: CommandeMinAggregateInputType
    _max?: CommandeMaxAggregateInputType
  }


  export type CommandeGroupByOutputType = {
    id: number
    idRecette: number
    idIngredient: number | null
    quantity: string
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  type GetCommandeGroupByPayload<T extends CommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeGroupByOutputType[P]>
        }
      >
    >


  export type commandeSelect = {
    id?: boolean
    idRecette?: boolean
    idIngredient?: boolean
    quantity?: boolean
    recette?: boolean | recetteArgs
  }


  export type commandeInclude = {
    recette?: boolean | recetteArgs
  }

  export type commandeGetPayload<S extends boolean | null | undefined | commandeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? commande :
    S extends undefined ? never :
    S extends { include: any } & (commandeArgs | commandeFindManyArgs)
    ? commande  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recette' ? recetteGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (commandeArgs | commandeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recette' ? recetteGetPayload<S['select'][P]> :  P extends keyof commande ? commande[P] : never
  } 
      : commande


  type commandeCountArgs = 
    Omit<commandeFindManyArgs, 'select' | 'include'> & {
      select?: CommandeCountAggregateInputType | true
    }

  export interface commandeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Commande that matches the filter.
     * @param {commandeFindUniqueArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commandeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, commandeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'commande'> extends True ? Prisma__commandeClient<commandeGetPayload<T>> : Prisma__commandeClient<commandeGetPayload<T> | null, null>

    /**
     * Find one Commande that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commandeFindUniqueOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commandeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, commandeFindUniqueOrThrowArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Find the first Commande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindFirstArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commandeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, commandeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'commande'> extends True ? Prisma__commandeClient<commandeGetPayload<T>> : Prisma__commandeClient<commandeGetPayload<T> | null, null>

    /**
     * Find the first Commande that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindFirstOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commandeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, commandeFindFirstOrThrowArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Find zero or more Commandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commandes
     * const commandes = await prisma.commande.findMany()
     * 
     * // Get first 10 Commandes
     * const commandes = await prisma.commande.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandeWithIdOnly = await prisma.commande.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends commandeFindManyArgs>(
      args?: SelectSubset<T, commandeFindManyArgs>
    ): Prisma.PrismaPromise<Array<commandeGetPayload<T>>>

    /**
     * Create a Commande.
     * @param {commandeCreateArgs} args - Arguments to create a Commande.
     * @example
     * // Create one Commande
     * const Commande = await prisma.commande.create({
     *   data: {
     *     // ... data to create a Commande
     *   }
     * })
     * 
    **/
    create<T extends commandeCreateArgs>(
      args: SelectSubset<T, commandeCreateArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Create many Commandes.
     *     @param {commandeCreateManyArgs} args - Arguments to create many Commandes.
     *     @example
     *     // Create many Commandes
     *     const commande = await prisma.commande.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commandeCreateManyArgs>(
      args?: SelectSubset<T, commandeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commande.
     * @param {commandeDeleteArgs} args - Arguments to delete one Commande.
     * @example
     * // Delete one Commande
     * const Commande = await prisma.commande.delete({
     *   where: {
     *     // ... filter to delete one Commande
     *   }
     * })
     * 
    **/
    delete<T extends commandeDeleteArgs>(
      args: SelectSubset<T, commandeDeleteArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Update one Commande.
     * @param {commandeUpdateArgs} args - Arguments to update one Commande.
     * @example
     * // Update one Commande
     * const commande = await prisma.commande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commandeUpdateArgs>(
      args: SelectSubset<T, commandeUpdateArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Delete zero or more Commandes.
     * @param {commandeDeleteManyArgs} args - Arguments to filter Commandes to delete.
     * @example
     * // Delete a few Commandes
     * const { count } = await prisma.commande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commandeDeleteManyArgs>(
      args?: SelectSubset<T, commandeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commandeUpdateManyArgs>(
      args: SelectSubset<T, commandeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commande.
     * @param {commandeUpsertArgs} args - Arguments to update or create a Commande.
     * @example
     * // Update or create a Commande
     * const commande = await prisma.commande.upsert({
     *   create: {
     *     // ... data to create a Commande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commande we want to update
     *   }
     * })
    **/
    upsert<T extends commandeUpsertArgs>(
      args: SelectSubset<T, commandeUpsertArgs>
    ): Prisma__commandeClient<commandeGetPayload<T>>

    /**
     * Count the number of Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commandeCountArgs} args - Arguments to filter Commandes to count.
     * @example
     * // Count the number of Commandes
     * const count = await prisma.commande.count({
     *   where: {
     *     // ... the filter for the Commandes we want to count
     *   }
     * })
    **/
    count<T extends commandeCountArgs>(
      args?: Subset<T, commandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeAggregateArgs>(args: Subset<T, CommandeAggregateArgs>): Prisma.PrismaPromise<GetCommandeAggregateType<T>>

    /**
     * Group by Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandeGroupByArgs['orderBy'] }
        : { orderBy?: CommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for commande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__commandeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    recette<T extends recetteArgs= {}>(args?: Subset<T, recetteArgs>): Prisma__recetteClient<recetteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * commande base type for findUnique actions
   */
  export type commandeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter, which commande to fetch.
     */
    where: commandeWhereUniqueInput
  }

  /**
   * commande findUnique
   */
  export interface commandeFindUniqueArgs extends commandeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commande findUniqueOrThrow
   */
  export type commandeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter, which commande to fetch.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande base type for findFirst actions
   */
  export type commandeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter, which commande to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: Enumerable<commandeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commandes.
     */
    distinct?: Enumerable<CommandeScalarFieldEnum>
  }

  /**
   * commande findFirst
   */
  export interface commandeFindFirstArgs extends commandeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commande findFirstOrThrow
   */
  export type commandeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter, which commande to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: Enumerable<commandeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commandes.
     */
    distinct?: Enumerable<CommandeScalarFieldEnum>
  }


  /**
   * commande findMany
   */
  export type commandeFindManyArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter, which commandes to fetch.
     */
    where?: commandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commandes to fetch.
     */
    orderBy?: Enumerable<commandeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commandes.
     */
    cursor?: commandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commandes.
     */
    skip?: number
    distinct?: Enumerable<CommandeScalarFieldEnum>
  }


  /**
   * commande create
   */
  export type commandeCreateArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * The data needed to create a commande.
     */
    data: XOR<commandeCreateInput, commandeUncheckedCreateInput>
  }


  /**
   * commande createMany
   */
  export type commandeCreateManyArgs = {
    /**
     * The data used to create many commandes.
     */
    data: Enumerable<commandeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * commande update
   */
  export type commandeUpdateArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * The data needed to update a commande.
     */
    data: XOR<commandeUpdateInput, commandeUncheckedUpdateInput>
    /**
     * Choose, which commande to update.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande updateMany
   */
  export type commandeUpdateManyArgs = {
    /**
     * The data used to update commandes.
     */
    data: XOR<commandeUpdateManyMutationInput, commandeUncheckedUpdateManyInput>
    /**
     * Filter which commandes to update
     */
    where?: commandeWhereInput
  }


  /**
   * commande upsert
   */
  export type commandeUpsertArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * The filter to search for the commande to update in case it exists.
     */
    where: commandeWhereUniqueInput
    /**
     * In case the commande found by the `where` argument doesn't exist, create a new commande with this data.
     */
    create: XOR<commandeCreateInput, commandeUncheckedCreateInput>
    /**
     * In case the commande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commandeUpdateInput, commandeUncheckedUpdateInput>
  }


  /**
   * commande delete
   */
  export type commandeDeleteArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    /**
     * Filter which commande to delete.
     */
    where: commandeWhereUniqueInput
  }


  /**
   * commande deleteMany
   */
  export type commandeDeleteManyArgs = {
    /**
     * Filter which commandes to delete
     */
    where?: commandeWhereInput
  }


  /**
   * commande without action
   */
  export type commandeArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
  }



  /**
   * Model distributeur
   */


  export type AggregateDistributeur = {
    _count: DistributeurCountAggregateOutputType | null
    _avg: DistributeurAvgAggregateOutputType | null
    _sum: DistributeurSumAggregateOutputType | null
    _min: DistributeurMinAggregateOutputType | null
    _max: DistributeurMaxAggregateOutputType | null
  }

  export type DistributeurAvgAggregateOutputType = {
    id: number | null
    capaciteGoblet: number | null
    capaciteSucre: number | null
    capaciteSpoon: number | null
  }

  export type DistributeurSumAggregateOutputType = {
    id: number | null
    capaciteGoblet: number | null
    capaciteSucre: number | null
    capaciteSpoon: number | null
  }

  export type DistributeurMinAggregateOutputType = {
    id: number | null
    identifiant: string | null
    capaciteGoblet: number | null
    capaciteSucre: number | null
    capaciteSpoon: number | null
  }

  export type DistributeurMaxAggregateOutputType = {
    id: number | null
    identifiant: string | null
    capaciteGoblet: number | null
    capaciteSucre: number | null
    capaciteSpoon: number | null
  }

  export type DistributeurCountAggregateOutputType = {
    id: number
    identifiant: number
    capaciteGoblet: number
    capaciteSucre: number
    capaciteSpoon: number
    _all: number
  }


  export type DistributeurAvgAggregateInputType = {
    id?: true
    capaciteGoblet?: true
    capaciteSucre?: true
    capaciteSpoon?: true
  }

  export type DistributeurSumAggregateInputType = {
    id?: true
    capaciteGoblet?: true
    capaciteSucre?: true
    capaciteSpoon?: true
  }

  export type DistributeurMinAggregateInputType = {
    id?: true
    identifiant?: true
    capaciteGoblet?: true
    capaciteSucre?: true
    capaciteSpoon?: true
  }

  export type DistributeurMaxAggregateInputType = {
    id?: true
    identifiant?: true
    capaciteGoblet?: true
    capaciteSucre?: true
    capaciteSpoon?: true
  }

  export type DistributeurCountAggregateInputType = {
    id?: true
    identifiant?: true
    capaciteGoblet?: true
    capaciteSucre?: true
    capaciteSpoon?: true
    _all?: true
  }

  export type DistributeurAggregateArgs = {
    /**
     * Filter which distributeur to aggregate.
     */
    where?: distributeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of distributeurs to fetch.
     */
    orderBy?: Enumerable<distributeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: distributeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` distributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` distributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned distributeurs
    **/
    _count?: true | DistributeurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistributeurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistributeurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributeurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributeurMaxAggregateInputType
  }

  export type GetDistributeurAggregateType<T extends DistributeurAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributeur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributeur[P]>
      : GetScalarType<T[P], AggregateDistributeur[P]>
  }




  export type DistributeurGroupByArgs = {
    where?: distributeurWhereInput
    orderBy?: Enumerable<distributeurOrderByWithAggregationInput>
    by: DistributeurScalarFieldEnum[]
    having?: distributeurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributeurCountAggregateInputType | true
    _avg?: DistributeurAvgAggregateInputType
    _sum?: DistributeurSumAggregateInputType
    _min?: DistributeurMinAggregateInputType
    _max?: DistributeurMaxAggregateInputType
  }


  export type DistributeurGroupByOutputType = {
    id: number
    identifiant: string
    capaciteGoblet: number | null
    capaciteSucre: number | null
    capaciteSpoon: number | null
    _count: DistributeurCountAggregateOutputType | null
    _avg: DistributeurAvgAggregateOutputType | null
    _sum: DistributeurSumAggregateOutputType | null
    _min: DistributeurMinAggregateOutputType | null
    _max: DistributeurMaxAggregateOutputType | null
  }

  type GetDistributeurGroupByPayload<T extends DistributeurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DistributeurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributeurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributeurGroupByOutputType[P]>
            : GetScalarType<T[P], DistributeurGroupByOutputType[P]>
        }
      >
    >


  export type distributeurSelect = {
    id?: boolean
    identifiant?: boolean
    capaciteGoblet?: boolean
    capaciteSucre?: boolean
    capaciteSpoon?: boolean
    pack?: boolean | packArgs
    sensors?: boolean | distributeur$sensorsArgs
    _count?: boolean | DistributeurCountOutputTypeArgs
  }


  export type distributeurInclude = {
    pack?: boolean | packArgs
    sensors?: boolean | distributeur$sensorsArgs
    _count?: boolean | DistributeurCountOutputTypeArgs
  }

  export type distributeurGetPayload<S extends boolean | null | undefined | distributeurArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? distributeur :
    S extends undefined ? never :
    S extends { include: any } & (distributeurArgs | distributeurFindManyArgs)
    ? distributeur  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pack' ? packGetPayload<S['include'][P]> | null :
        P extends 'sensors' ? Array < sensorsGetPayload<S['include'][P]>>  :
        P extends '_count' ? DistributeurCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (distributeurArgs | distributeurFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pack' ? packGetPayload<S['select'][P]> | null :
        P extends 'sensors' ? Array < sensorsGetPayload<S['select'][P]>>  :
        P extends '_count' ? DistributeurCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof distributeur ? distributeur[P] : never
  } 
      : distributeur


  type distributeurCountArgs = 
    Omit<distributeurFindManyArgs, 'select' | 'include'> & {
      select?: DistributeurCountAggregateInputType | true
    }

  export interface distributeurDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Distributeur that matches the filter.
     * @param {distributeurFindUniqueArgs} args - Arguments to find a Distributeur
     * @example
     * // Get one Distributeur
     * const distributeur = await prisma.distributeur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends distributeurFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, distributeurFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'distributeur'> extends True ? Prisma__distributeurClient<distributeurGetPayload<T>> : Prisma__distributeurClient<distributeurGetPayload<T> | null, null>

    /**
     * Find one Distributeur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {distributeurFindUniqueOrThrowArgs} args - Arguments to find a Distributeur
     * @example
     * // Get one Distributeur
     * const distributeur = await prisma.distributeur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends distributeurFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, distributeurFindUniqueOrThrowArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Find the first Distributeur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {distributeurFindFirstArgs} args - Arguments to find a Distributeur
     * @example
     * // Get one Distributeur
     * const distributeur = await prisma.distributeur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends distributeurFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, distributeurFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'distributeur'> extends True ? Prisma__distributeurClient<distributeurGetPayload<T>> : Prisma__distributeurClient<distributeurGetPayload<T> | null, null>

    /**
     * Find the first Distributeur that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {distributeurFindFirstOrThrowArgs} args - Arguments to find a Distributeur
     * @example
     * // Get one Distributeur
     * const distributeur = await prisma.distributeur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends distributeurFindFirstOrThrowArgs>(
      args?: SelectSubset<T, distributeurFindFirstOrThrowArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Find zero or more Distributeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {distributeurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distributeurs
     * const distributeurs = await prisma.distributeur.findMany()
     * 
     * // Get first 10 Distributeurs
     * const distributeurs = await prisma.distributeur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributeurWithIdOnly = await prisma.distributeur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends distributeurFindManyArgs>(
      args?: SelectSubset<T, distributeurFindManyArgs>
    ): Prisma.PrismaPromise<Array<distributeurGetPayload<T>>>

    /**
     * Create a Distributeur.
     * @param {distributeurCreateArgs} args - Arguments to create a Distributeur.
     * @example
     * // Create one Distributeur
     * const Distributeur = await prisma.distributeur.create({
     *   data: {
     *     // ... data to create a Distributeur
     *   }
     * })
     * 
    **/
    create<T extends distributeurCreateArgs>(
      args: SelectSubset<T, distributeurCreateArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Create many Distributeurs.
     *     @param {distributeurCreateManyArgs} args - Arguments to create many Distributeurs.
     *     @example
     *     // Create many Distributeurs
     *     const distributeur = await prisma.distributeur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends distributeurCreateManyArgs>(
      args?: SelectSubset<T, distributeurCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Distributeur.
     * @param {distributeurDeleteArgs} args - Arguments to delete one Distributeur.
     * @example
     * // Delete one Distributeur
     * const Distributeur = await prisma.distributeur.delete({
     *   where: {
     *     // ... filter to delete one Distributeur
     *   }
     * })
     * 
    **/
    delete<T extends distributeurDeleteArgs>(
      args: SelectSubset<T, distributeurDeleteArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Update one Distributeur.
     * @param {distributeurUpdateArgs} args - Arguments to update one Distributeur.
     * @example
     * // Update one Distributeur
     * const distributeur = await prisma.distributeur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends distributeurUpdateArgs>(
      args: SelectSubset<T, distributeurUpdateArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Delete zero or more Distributeurs.
     * @param {distributeurDeleteManyArgs} args - Arguments to filter Distributeurs to delete.
     * @example
     * // Delete a few Distributeurs
     * const { count } = await prisma.distributeur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends distributeurDeleteManyArgs>(
      args?: SelectSubset<T, distributeurDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {distributeurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distributeurs
     * const distributeur = await prisma.distributeur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends distributeurUpdateManyArgs>(
      args: SelectSubset<T, distributeurUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Distributeur.
     * @param {distributeurUpsertArgs} args - Arguments to update or create a Distributeur.
     * @example
     * // Update or create a Distributeur
     * const distributeur = await prisma.distributeur.upsert({
     *   create: {
     *     // ... data to create a Distributeur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distributeur we want to update
     *   }
     * })
    **/
    upsert<T extends distributeurUpsertArgs>(
      args: SelectSubset<T, distributeurUpsertArgs>
    ): Prisma__distributeurClient<distributeurGetPayload<T>>

    /**
     * Count the number of Distributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {distributeurCountArgs} args - Arguments to filter Distributeurs to count.
     * @example
     * // Count the number of Distributeurs
     * const count = await prisma.distributeur.count({
     *   where: {
     *     // ... the filter for the Distributeurs we want to count
     *   }
     * })
    **/
    count<T extends distributeurCountArgs>(
      args?: Subset<T, distributeurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributeurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distributeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributeurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributeurAggregateArgs>(args: Subset<T, DistributeurAggregateArgs>): Prisma.PrismaPromise<GetDistributeurAggregateType<T>>

    /**
     * Group by Distributeur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributeurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributeurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributeurGroupByArgs['orderBy'] }
        : { orderBy?: DistributeurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributeurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributeurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for distributeur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__distributeurClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pack<T extends packArgs= {}>(args?: Subset<T, packArgs>): Prisma__packClient<packGetPayload<T> | Null>;

    sensors<T extends distributeur$sensorsArgs= {}>(args?: Subset<T, distributeur$sensorsArgs>): Prisma.PrismaPromise<Array<sensorsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * distributeur base type for findUnique actions
   */
  export type distributeurFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter, which distributeur to fetch.
     */
    where: distributeurWhereUniqueInput
  }

  /**
   * distributeur findUnique
   */
  export interface distributeurFindUniqueArgs extends distributeurFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * distributeur findUniqueOrThrow
   */
  export type distributeurFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter, which distributeur to fetch.
     */
    where: distributeurWhereUniqueInput
  }


  /**
   * distributeur base type for findFirst actions
   */
  export type distributeurFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter, which distributeur to fetch.
     */
    where?: distributeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of distributeurs to fetch.
     */
    orderBy?: Enumerable<distributeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for distributeurs.
     */
    cursor?: distributeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` distributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` distributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of distributeurs.
     */
    distinct?: Enumerable<DistributeurScalarFieldEnum>
  }

  /**
   * distributeur findFirst
   */
  export interface distributeurFindFirstArgs extends distributeurFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * distributeur findFirstOrThrow
   */
  export type distributeurFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter, which distributeur to fetch.
     */
    where?: distributeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of distributeurs to fetch.
     */
    orderBy?: Enumerable<distributeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for distributeurs.
     */
    cursor?: distributeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` distributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` distributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of distributeurs.
     */
    distinct?: Enumerable<DistributeurScalarFieldEnum>
  }


  /**
   * distributeur findMany
   */
  export type distributeurFindManyArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter, which distributeurs to fetch.
     */
    where?: distributeurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of distributeurs to fetch.
     */
    orderBy?: Enumerable<distributeurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing distributeurs.
     */
    cursor?: distributeurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` distributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` distributeurs.
     */
    skip?: number
    distinct?: Enumerable<DistributeurScalarFieldEnum>
  }


  /**
   * distributeur create
   */
  export type distributeurCreateArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * The data needed to create a distributeur.
     */
    data: XOR<distributeurCreateInput, distributeurUncheckedCreateInput>
  }


  /**
   * distributeur createMany
   */
  export type distributeurCreateManyArgs = {
    /**
     * The data used to create many distributeurs.
     */
    data: Enumerable<distributeurCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * distributeur update
   */
  export type distributeurUpdateArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * The data needed to update a distributeur.
     */
    data: XOR<distributeurUpdateInput, distributeurUncheckedUpdateInput>
    /**
     * Choose, which distributeur to update.
     */
    where: distributeurWhereUniqueInput
  }


  /**
   * distributeur updateMany
   */
  export type distributeurUpdateManyArgs = {
    /**
     * The data used to update distributeurs.
     */
    data: XOR<distributeurUpdateManyMutationInput, distributeurUncheckedUpdateManyInput>
    /**
     * Filter which distributeurs to update
     */
    where?: distributeurWhereInput
  }


  /**
   * distributeur upsert
   */
  export type distributeurUpsertArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * The filter to search for the distributeur to update in case it exists.
     */
    where: distributeurWhereUniqueInput
    /**
     * In case the distributeur found by the `where` argument doesn't exist, create a new distributeur with this data.
     */
    create: XOR<distributeurCreateInput, distributeurUncheckedCreateInput>
    /**
     * In case the distributeur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<distributeurUpdateInput, distributeurUncheckedUpdateInput>
  }


  /**
   * distributeur delete
   */
  export type distributeurDeleteArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
    /**
     * Filter which distributeur to delete.
     */
    where: distributeurWhereUniqueInput
  }


  /**
   * distributeur deleteMany
   */
  export type distributeurDeleteManyArgs = {
    /**
     * Filter which distributeurs to delete
     */
    where?: distributeurWhereInput
  }


  /**
   * distributeur.sensors
   */
  export type distributeur$sensorsArgs = {
    /**
     * Select specific fields to fetch from the sensors
     */
    select?: sensorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sensorsInclude | null
    where?: sensorsWhereInput
    orderBy?: Enumerable<sensorsOrderByWithRelationInput>
    cursor?: sensorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SensorsScalarFieldEnum>
  }


  /**
   * distributeur without action
   */
  export type distributeurArgs = {
    /**
     * Select specific fields to fetch from the distributeur
     */
    select?: distributeurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: distributeurInclude | null
  }



  /**
   * Model entrepise
   */


  export type AggregateEntrepise = {
    _count: EntrepiseCountAggregateOutputType | null
    _avg: EntrepiseAvgAggregateOutputType | null
    _sum: EntrepiseSumAggregateOutputType | null
    _min: EntrepiseMinAggregateOutputType | null
    _max: EntrepiseMaxAggregateOutputType | null
  }

  export type EntrepiseAvgAggregateOutputType = {
    id: number | null
  }

  export type EntrepiseSumAggregateOutputType = {
    id: number | null
  }

  export type EntrepiseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    adresse: string | null
    mail: string | null
    tel: string | null
    link: string | null
  }

  export type EntrepiseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    adresse: string | null
    mail: string | null
    tel: string | null
    link: string | null
  }

  export type EntrepiseCountAggregateOutputType = {
    id: number
    nom: number
    adresse: number
    mail: number
    tel: number
    link: number
    _all: number
  }


  export type EntrepiseAvgAggregateInputType = {
    id?: true
  }

  export type EntrepiseSumAggregateInputType = {
    id?: true
  }

  export type EntrepiseMinAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    mail?: true
    tel?: true
    link?: true
  }

  export type EntrepiseMaxAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    mail?: true
    tel?: true
    link?: true
  }

  export type EntrepiseCountAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    mail?: true
    tel?: true
    link?: true
    _all?: true
  }

  export type EntrepiseAggregateArgs = {
    /**
     * Filter which entrepise to aggregate.
     */
    where?: entrepiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrepises to fetch.
     */
    orderBy?: Enumerable<entrepiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entrepiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrepises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrepises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entrepises
    **/
    _count?: true | EntrepiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntrepiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrepiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntrepiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntrepiseMaxAggregateInputType
  }

  export type GetEntrepiseAggregateType<T extends EntrepiseAggregateArgs> = {
        [P in keyof T & keyof AggregateEntrepise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntrepise[P]>
      : GetScalarType<T[P], AggregateEntrepise[P]>
  }




  export type EntrepiseGroupByArgs = {
    where?: entrepiseWhereInput
    orderBy?: Enumerable<entrepiseOrderByWithAggregationInput>
    by: EntrepiseScalarFieldEnum[]
    having?: entrepiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntrepiseCountAggregateInputType | true
    _avg?: EntrepiseAvgAggregateInputType
    _sum?: EntrepiseSumAggregateInputType
    _min?: EntrepiseMinAggregateInputType
    _max?: EntrepiseMaxAggregateInputType
  }


  export type EntrepiseGroupByOutputType = {
    id: number
    nom: string | null
    adresse: string | null
    mail: string | null
    tel: string | null
    link: string | null
    _count: EntrepiseCountAggregateOutputType | null
    _avg: EntrepiseAvgAggregateOutputType | null
    _sum: EntrepiseSumAggregateOutputType | null
    _min: EntrepiseMinAggregateOutputType | null
    _max: EntrepiseMaxAggregateOutputType | null
  }

  type GetEntrepiseGroupByPayload<T extends EntrepiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EntrepiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntrepiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntrepiseGroupByOutputType[P]>
            : GetScalarType<T[P], EntrepiseGroupByOutputType[P]>
        }
      >
    >


  export type entrepiseSelect = {
    id?: boolean
    nom?: boolean
    adresse?: boolean
    mail?: boolean
    tel?: boolean
    link?: boolean
    pack?: boolean | entrepise$packArgs
    users?: boolean | entrepise$usersArgs
    task?: boolean | entrepise$taskArgs
    _count?: boolean | EntrepiseCountOutputTypeArgs
  }


  export type entrepiseInclude = {
    pack?: boolean | entrepise$packArgs
    users?: boolean | entrepise$usersArgs
    task?: boolean | entrepise$taskArgs
    _count?: boolean | EntrepiseCountOutputTypeArgs
  }

  export type entrepiseGetPayload<S extends boolean | null | undefined | entrepiseArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? entrepise :
    S extends undefined ? never :
    S extends { include: any } & (entrepiseArgs | entrepiseFindManyArgs)
    ? entrepise  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pack' ? Array < packGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'task' ? Array < taskGetPayload<S['include'][P]>>  :
        P extends '_count' ? EntrepiseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (entrepiseArgs | entrepiseFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pack' ? Array < packGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'task' ? Array < taskGetPayload<S['select'][P]>>  :
        P extends '_count' ? EntrepiseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof entrepise ? entrepise[P] : never
  } 
      : entrepise


  type entrepiseCountArgs = 
    Omit<entrepiseFindManyArgs, 'select' | 'include'> & {
      select?: EntrepiseCountAggregateInputType | true
    }

  export interface entrepiseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Entrepise that matches the filter.
     * @param {entrepiseFindUniqueArgs} args - Arguments to find a Entrepise
     * @example
     * // Get one Entrepise
     * const entrepise = await prisma.entrepise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends entrepiseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, entrepiseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'entrepise'> extends True ? Prisma__entrepiseClient<entrepiseGetPayload<T>> : Prisma__entrepiseClient<entrepiseGetPayload<T> | null, null>

    /**
     * Find one Entrepise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {entrepiseFindUniqueOrThrowArgs} args - Arguments to find a Entrepise
     * @example
     * // Get one Entrepise
     * const entrepise = await prisma.entrepise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends entrepiseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, entrepiseFindUniqueOrThrowArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Find the first Entrepise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrepiseFindFirstArgs} args - Arguments to find a Entrepise
     * @example
     * // Get one Entrepise
     * const entrepise = await prisma.entrepise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends entrepiseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, entrepiseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'entrepise'> extends True ? Prisma__entrepiseClient<entrepiseGetPayload<T>> : Prisma__entrepiseClient<entrepiseGetPayload<T> | null, null>

    /**
     * Find the first Entrepise that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrepiseFindFirstOrThrowArgs} args - Arguments to find a Entrepise
     * @example
     * // Get one Entrepise
     * const entrepise = await prisma.entrepise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends entrepiseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, entrepiseFindFirstOrThrowArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Find zero or more Entrepises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrepiseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entrepises
     * const entrepises = await prisma.entrepise.findMany()
     * 
     * // Get first 10 Entrepises
     * const entrepises = await prisma.entrepise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entrepiseWithIdOnly = await prisma.entrepise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends entrepiseFindManyArgs>(
      args?: SelectSubset<T, entrepiseFindManyArgs>
    ): Prisma.PrismaPromise<Array<entrepiseGetPayload<T>>>

    /**
     * Create a Entrepise.
     * @param {entrepiseCreateArgs} args - Arguments to create a Entrepise.
     * @example
     * // Create one Entrepise
     * const Entrepise = await prisma.entrepise.create({
     *   data: {
     *     // ... data to create a Entrepise
     *   }
     * })
     * 
    **/
    create<T extends entrepiseCreateArgs>(
      args: SelectSubset<T, entrepiseCreateArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Create many Entrepises.
     *     @param {entrepiseCreateManyArgs} args - Arguments to create many Entrepises.
     *     @example
     *     // Create many Entrepises
     *     const entrepise = await prisma.entrepise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends entrepiseCreateManyArgs>(
      args?: SelectSubset<T, entrepiseCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entrepise.
     * @param {entrepiseDeleteArgs} args - Arguments to delete one Entrepise.
     * @example
     * // Delete one Entrepise
     * const Entrepise = await prisma.entrepise.delete({
     *   where: {
     *     // ... filter to delete one Entrepise
     *   }
     * })
     * 
    **/
    delete<T extends entrepiseDeleteArgs>(
      args: SelectSubset<T, entrepiseDeleteArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Update one Entrepise.
     * @param {entrepiseUpdateArgs} args - Arguments to update one Entrepise.
     * @example
     * // Update one Entrepise
     * const entrepise = await prisma.entrepise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends entrepiseUpdateArgs>(
      args: SelectSubset<T, entrepiseUpdateArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Delete zero or more Entrepises.
     * @param {entrepiseDeleteManyArgs} args - Arguments to filter Entrepises to delete.
     * @example
     * // Delete a few Entrepises
     * const { count } = await prisma.entrepise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends entrepiseDeleteManyArgs>(
      args?: SelectSubset<T, entrepiseDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entrepises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrepiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entrepises
     * const entrepise = await prisma.entrepise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends entrepiseUpdateManyArgs>(
      args: SelectSubset<T, entrepiseUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entrepise.
     * @param {entrepiseUpsertArgs} args - Arguments to update or create a Entrepise.
     * @example
     * // Update or create a Entrepise
     * const entrepise = await prisma.entrepise.upsert({
     *   create: {
     *     // ... data to create a Entrepise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entrepise we want to update
     *   }
     * })
    **/
    upsert<T extends entrepiseUpsertArgs>(
      args: SelectSubset<T, entrepiseUpsertArgs>
    ): Prisma__entrepiseClient<entrepiseGetPayload<T>>

    /**
     * Count the number of Entrepises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrepiseCountArgs} args - Arguments to filter Entrepises to count.
     * @example
     * // Count the number of Entrepises
     * const count = await prisma.entrepise.count({
     *   where: {
     *     // ... the filter for the Entrepises we want to count
     *   }
     * })
    **/
    count<T extends entrepiseCountArgs>(
      args?: Subset<T, entrepiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntrepiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entrepise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntrepiseAggregateArgs>(args: Subset<T, EntrepiseAggregateArgs>): Prisma.PrismaPromise<GetEntrepiseAggregateType<T>>

    /**
     * Group by Entrepise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntrepiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntrepiseGroupByArgs['orderBy'] }
        : { orderBy?: EntrepiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntrepiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntrepiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for entrepise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__entrepiseClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pack<T extends entrepise$packArgs= {}>(args?: Subset<T, entrepise$packArgs>): Prisma.PrismaPromise<Array<packGetPayload<T>>| Null>;

    users<T extends entrepise$usersArgs= {}>(args?: Subset<T, entrepise$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    task<T extends entrepise$taskArgs= {}>(args?: Subset<T, entrepise$taskArgs>): Prisma.PrismaPromise<Array<taskGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * entrepise base type for findUnique actions
   */
  export type entrepiseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter, which entrepise to fetch.
     */
    where: entrepiseWhereUniqueInput
  }

  /**
   * entrepise findUnique
   */
  export interface entrepiseFindUniqueArgs extends entrepiseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * entrepise findUniqueOrThrow
   */
  export type entrepiseFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter, which entrepise to fetch.
     */
    where: entrepiseWhereUniqueInput
  }


  /**
   * entrepise base type for findFirst actions
   */
  export type entrepiseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter, which entrepise to fetch.
     */
    where?: entrepiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrepises to fetch.
     */
    orderBy?: Enumerable<entrepiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrepises.
     */
    cursor?: entrepiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrepises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrepises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrepises.
     */
    distinct?: Enumerable<EntrepiseScalarFieldEnum>
  }

  /**
   * entrepise findFirst
   */
  export interface entrepiseFindFirstArgs extends entrepiseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * entrepise findFirstOrThrow
   */
  export type entrepiseFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter, which entrepise to fetch.
     */
    where?: entrepiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrepises to fetch.
     */
    orderBy?: Enumerable<entrepiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrepises.
     */
    cursor?: entrepiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrepises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrepises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrepises.
     */
    distinct?: Enumerable<EntrepiseScalarFieldEnum>
  }


  /**
   * entrepise findMany
   */
  export type entrepiseFindManyArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter, which entrepises to fetch.
     */
    where?: entrepiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrepises to fetch.
     */
    orderBy?: Enumerable<entrepiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entrepises.
     */
    cursor?: entrepiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrepises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrepises.
     */
    skip?: number
    distinct?: Enumerable<EntrepiseScalarFieldEnum>
  }


  /**
   * entrepise create
   */
  export type entrepiseCreateArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * The data needed to create a entrepise.
     */
    data: XOR<entrepiseCreateInput, entrepiseUncheckedCreateInput>
  }


  /**
   * entrepise createMany
   */
  export type entrepiseCreateManyArgs = {
    /**
     * The data used to create many entrepises.
     */
    data: Enumerable<entrepiseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * entrepise update
   */
  export type entrepiseUpdateArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * The data needed to update a entrepise.
     */
    data: XOR<entrepiseUpdateInput, entrepiseUncheckedUpdateInput>
    /**
     * Choose, which entrepise to update.
     */
    where: entrepiseWhereUniqueInput
  }


  /**
   * entrepise updateMany
   */
  export type entrepiseUpdateManyArgs = {
    /**
     * The data used to update entrepises.
     */
    data: XOR<entrepiseUpdateManyMutationInput, entrepiseUncheckedUpdateManyInput>
    /**
     * Filter which entrepises to update
     */
    where?: entrepiseWhereInput
  }


  /**
   * entrepise upsert
   */
  export type entrepiseUpsertArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * The filter to search for the entrepise to update in case it exists.
     */
    where: entrepiseWhereUniqueInput
    /**
     * In case the entrepise found by the `where` argument doesn't exist, create a new entrepise with this data.
     */
    create: XOR<entrepiseCreateInput, entrepiseUncheckedCreateInput>
    /**
     * In case the entrepise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entrepiseUpdateInput, entrepiseUncheckedUpdateInput>
  }


  /**
   * entrepise delete
   */
  export type entrepiseDeleteArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
    /**
     * Filter which entrepise to delete.
     */
    where: entrepiseWhereUniqueInput
  }


  /**
   * entrepise deleteMany
   */
  export type entrepiseDeleteManyArgs = {
    /**
     * Filter which entrepises to delete
     */
    where?: entrepiseWhereInput
  }


  /**
   * entrepise.pack
   */
  export type entrepise$packArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    where?: packWhereInput
    orderBy?: Enumerable<packOrderByWithRelationInput>
    cursor?: packWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PackScalarFieldEnum>
  }


  /**
   * entrepise.users
   */
  export type entrepise$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * entrepise.task
   */
  export type entrepise$taskArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    where?: taskWhereInput
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    cursor?: taskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * entrepise without action
   */
  export type entrepiseArgs = {
    /**
     * Select specific fields to fetch from the entrepise
     */
    select?: entrepiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: entrepiseInclude | null
  }



  /**
   * Model facture
   */


  export type AggregateFacture = {
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  export type FactureAvgAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idComm: number | null
    idInfoPaiment: number | null
  }

  export type FactureSumAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idComm: number | null
    idInfoPaiment: number | null
  }

  export type FactureMinAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idComm: number | null
    idInfoPaiment: number | null
  }

  export type FactureMaxAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idComm: number | null
    idInfoPaiment: number | null
  }

  export type FactureCountAggregateOutputType = {
    id: number
    idDistr: number
    idComm: number
    idInfoPaiment: number
    _all: number
  }


  export type FactureAvgAggregateInputType = {
    id?: true
    idDistr?: true
    idComm?: true
    idInfoPaiment?: true
  }

  export type FactureSumAggregateInputType = {
    id?: true
    idDistr?: true
    idComm?: true
    idInfoPaiment?: true
  }

  export type FactureMinAggregateInputType = {
    id?: true
    idDistr?: true
    idComm?: true
    idInfoPaiment?: true
  }

  export type FactureMaxAggregateInputType = {
    id?: true
    idDistr?: true
    idComm?: true
    idInfoPaiment?: true
  }

  export type FactureCountAggregateInputType = {
    id?: true
    idDistr?: true
    idComm?: true
    idInfoPaiment?: true
    _all?: true
  }

  export type FactureAggregateArgs = {
    /**
     * Filter which facture to aggregate.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: Enumerable<factureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned factures
    **/
    _count?: true | FactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactureMaxAggregateInputType
  }

  export type GetFactureAggregateType<T extends FactureAggregateArgs> = {
        [P in keyof T & keyof AggregateFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacture[P]>
      : GetScalarType<T[P], AggregateFacture[P]>
  }




  export type FactureGroupByArgs = {
    where?: factureWhereInput
    orderBy?: Enumerable<factureOrderByWithAggregationInput>
    by: FactureScalarFieldEnum[]
    having?: factureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactureCountAggregateInputType | true
    _avg?: FactureAvgAggregateInputType
    _sum?: FactureSumAggregateInputType
    _min?: FactureMinAggregateInputType
    _max?: FactureMaxAggregateInputType
  }


  export type FactureGroupByOutputType = {
    id: number
    idDistr: number | null
    idComm: number | null
    idInfoPaiment: number | null
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  type GetFactureGroupByPayload<T extends FactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactureGroupByOutputType[P]>
            : GetScalarType<T[P], FactureGroupByOutputType[P]>
        }
      >
    >


  export type factureSelect = {
    id?: boolean
    idDistr?: boolean
    idComm?: boolean
    idInfoPaiment?: boolean
  }


  export type factureGetPayload<S extends boolean | null | undefined | factureArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? facture :
    S extends undefined ? never :
    S extends { include: any } & (factureArgs | factureFindManyArgs)
    ? facture 
    : S extends { select: any } & (factureArgs | factureFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof facture ? facture[P] : never
  } 
      : facture


  type factureCountArgs = 
    Omit<factureFindManyArgs, 'select' | 'include'> & {
      select?: FactureCountAggregateInputType | true
    }

  export interface factureDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Facture that matches the filter.
     * @param {factureFindUniqueArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends factureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, factureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'facture'> extends True ? Prisma__factureClient<factureGetPayload<T>> : Prisma__factureClient<factureGetPayload<T> | null, null>

    /**
     * Find one Facture that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {factureFindUniqueOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends factureFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, factureFindUniqueOrThrowArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Find the first Facture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindFirstArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends factureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, factureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'facture'> extends True ? Prisma__factureClient<factureGetPayload<T>> : Prisma__factureClient<factureGetPayload<T> | null, null>

    /**
     * Find the first Facture that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindFirstOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends factureFindFirstOrThrowArgs>(
      args?: SelectSubset<T, factureFindFirstOrThrowArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Find zero or more Factures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factures
     * const factures = await prisma.facture.findMany()
     * 
     * // Get first 10 Factures
     * const factures = await prisma.facture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factureWithIdOnly = await prisma.facture.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends factureFindManyArgs>(
      args?: SelectSubset<T, factureFindManyArgs>
    ): Prisma.PrismaPromise<Array<factureGetPayload<T>>>

    /**
     * Create a Facture.
     * @param {factureCreateArgs} args - Arguments to create a Facture.
     * @example
     * // Create one Facture
     * const Facture = await prisma.facture.create({
     *   data: {
     *     // ... data to create a Facture
     *   }
     * })
     * 
    **/
    create<T extends factureCreateArgs>(
      args: SelectSubset<T, factureCreateArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Create many Factures.
     *     @param {factureCreateManyArgs} args - Arguments to create many Factures.
     *     @example
     *     // Create many Factures
     *     const facture = await prisma.facture.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends factureCreateManyArgs>(
      args?: SelectSubset<T, factureCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Facture.
     * @param {factureDeleteArgs} args - Arguments to delete one Facture.
     * @example
     * // Delete one Facture
     * const Facture = await prisma.facture.delete({
     *   where: {
     *     // ... filter to delete one Facture
     *   }
     * })
     * 
    **/
    delete<T extends factureDeleteArgs>(
      args: SelectSubset<T, factureDeleteArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Update one Facture.
     * @param {factureUpdateArgs} args - Arguments to update one Facture.
     * @example
     * // Update one Facture
     * const facture = await prisma.facture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends factureUpdateArgs>(
      args: SelectSubset<T, factureUpdateArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Delete zero or more Factures.
     * @param {factureDeleteManyArgs} args - Arguments to filter Factures to delete.
     * @example
     * // Delete a few Factures
     * const { count } = await prisma.facture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends factureDeleteManyArgs>(
      args?: SelectSubset<T, factureDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factures
     * const facture = await prisma.facture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends factureUpdateManyArgs>(
      args: SelectSubset<T, factureUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facture.
     * @param {factureUpsertArgs} args - Arguments to update or create a Facture.
     * @example
     * // Update or create a Facture
     * const facture = await prisma.facture.upsert({
     *   create: {
     *     // ... data to create a Facture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facture we want to update
     *   }
     * })
    **/
    upsert<T extends factureUpsertArgs>(
      args: SelectSubset<T, factureUpsertArgs>
    ): Prisma__factureClient<factureGetPayload<T>>

    /**
     * Count the number of Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factureCountArgs} args - Arguments to filter Factures to count.
     * @example
     * // Count the number of Factures
     * const count = await prisma.facture.count({
     *   where: {
     *     // ... the filter for the Factures we want to count
     *   }
     * })
    **/
    count<T extends factureCountArgs>(
      args?: Subset<T, factureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactureAggregateArgs>(args: Subset<T, FactureAggregateArgs>): Prisma.PrismaPromise<GetFactureAggregateType<T>>

    /**
     * Group by Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactureGroupByArgs['orderBy'] }
        : { orderBy?: FactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for facture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__factureClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * facture base type for findUnique actions
   */
  export type factureFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter, which facture to fetch.
     */
    where: factureWhereUniqueInput
  }

  /**
   * facture findUnique
   */
  export interface factureFindUniqueArgs extends factureFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * facture findUniqueOrThrow
   */
  export type factureFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter, which facture to fetch.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture base type for findFirst actions
   */
  export type factureFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter, which facture to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: Enumerable<factureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factures.
     */
    distinct?: Enumerable<FactureScalarFieldEnum>
  }

  /**
   * facture findFirst
   */
  export interface factureFindFirstArgs extends factureFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * facture findFirstOrThrow
   */
  export type factureFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter, which facture to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: Enumerable<factureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factures.
     */
    distinct?: Enumerable<FactureScalarFieldEnum>
  }


  /**
   * facture findMany
   */
  export type factureFindManyArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter, which factures to fetch.
     */
    where?: factureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factures to fetch.
     */
    orderBy?: Enumerable<factureOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing factures.
     */
    cursor?: factureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factures.
     */
    skip?: number
    distinct?: Enumerable<FactureScalarFieldEnum>
  }


  /**
   * facture create
   */
  export type factureCreateArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * The data needed to create a facture.
     */
    data: XOR<factureCreateInput, factureUncheckedCreateInput>
  }


  /**
   * facture createMany
   */
  export type factureCreateManyArgs = {
    /**
     * The data used to create many factures.
     */
    data: Enumerable<factureCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * facture update
   */
  export type factureUpdateArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * The data needed to update a facture.
     */
    data: XOR<factureUpdateInput, factureUncheckedUpdateInput>
    /**
     * Choose, which facture to update.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture updateMany
   */
  export type factureUpdateManyArgs = {
    /**
     * The data used to update factures.
     */
    data: XOR<factureUpdateManyMutationInput, factureUncheckedUpdateManyInput>
    /**
     * Filter which factures to update
     */
    where?: factureWhereInput
  }


  /**
   * facture upsert
   */
  export type factureUpsertArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * The filter to search for the facture to update in case it exists.
     */
    where: factureWhereUniqueInput
    /**
     * In case the facture found by the `where` argument doesn't exist, create a new facture with this data.
     */
    create: XOR<factureCreateInput, factureUncheckedCreateInput>
    /**
     * In case the facture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<factureUpdateInput, factureUncheckedUpdateInput>
  }


  /**
   * facture delete
   */
  export type factureDeleteArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
    /**
     * Filter which facture to delete.
     */
    where: factureWhereUniqueInput
  }


  /**
   * facture deleteMany
   */
  export type factureDeleteManyArgs = {
    /**
     * Filter which factures to delete
     */
    where?: factureWhereInput
  }


  /**
   * facture without action
   */
  export type factureArgs = {
    /**
     * Select specific fields to fetch from the facture
     */
    select?: factureSelect | null
  }



  /**
   * Model infopaiment
   */


  export type AggregateInfopaiment = {
    _count: InfopaimentCountAggregateOutputType | null
    _avg: InfopaimentAvgAggregateOutputType | null
    _sum: InfopaimentSumAggregateOutputType | null
    _min: InfopaimentMinAggregateOutputType | null
    _max: InfopaimentMaxAggregateOutputType | null
  }

  export type InfopaimentAvgAggregateOutputType = {
    id: number | null
  }

  export type InfopaimentSumAggregateOutputType = {
    id: number | null
  }

  export type InfopaimentMinAggregateOutputType = {
    id: number | null
    mail: string | null
    cartePaiment: string | null
    ccv: string | null
  }

  export type InfopaimentMaxAggregateOutputType = {
    id: number | null
    mail: string | null
    cartePaiment: string | null
    ccv: string | null
  }

  export type InfopaimentCountAggregateOutputType = {
    id: number
    mail: number
    cartePaiment: number
    ccv: number
    _all: number
  }


  export type InfopaimentAvgAggregateInputType = {
    id?: true
  }

  export type InfopaimentSumAggregateInputType = {
    id?: true
  }

  export type InfopaimentMinAggregateInputType = {
    id?: true
    mail?: true
    cartePaiment?: true
    ccv?: true
  }

  export type InfopaimentMaxAggregateInputType = {
    id?: true
    mail?: true
    cartePaiment?: true
    ccv?: true
  }

  export type InfopaimentCountAggregateInputType = {
    id?: true
    mail?: true
    cartePaiment?: true
    ccv?: true
    _all?: true
  }

  export type InfopaimentAggregateArgs = {
    /**
     * Filter which infopaiment to aggregate.
     */
    where?: infopaimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopaiments to fetch.
     */
    orderBy?: Enumerable<infopaimentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: infopaimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopaiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopaiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned infopaiments
    **/
    _count?: true | InfopaimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfopaimentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfopaimentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfopaimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfopaimentMaxAggregateInputType
  }

  export type GetInfopaimentAggregateType<T extends InfopaimentAggregateArgs> = {
        [P in keyof T & keyof AggregateInfopaiment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfopaiment[P]>
      : GetScalarType<T[P], AggregateInfopaiment[P]>
  }




  export type InfopaimentGroupByArgs = {
    where?: infopaimentWhereInput
    orderBy?: Enumerable<infopaimentOrderByWithAggregationInput>
    by: InfopaimentScalarFieldEnum[]
    having?: infopaimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfopaimentCountAggregateInputType | true
    _avg?: InfopaimentAvgAggregateInputType
    _sum?: InfopaimentSumAggregateInputType
    _min?: InfopaimentMinAggregateInputType
    _max?: InfopaimentMaxAggregateInputType
  }


  export type InfopaimentGroupByOutputType = {
    id: number
    mail: string | null
    cartePaiment: string | null
    ccv: string | null
    _count: InfopaimentCountAggregateOutputType | null
    _avg: InfopaimentAvgAggregateOutputType | null
    _sum: InfopaimentSumAggregateOutputType | null
    _min: InfopaimentMinAggregateOutputType | null
    _max: InfopaimentMaxAggregateOutputType | null
  }

  type GetInfopaimentGroupByPayload<T extends InfopaimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InfopaimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfopaimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfopaimentGroupByOutputType[P]>
            : GetScalarType<T[P], InfopaimentGroupByOutputType[P]>
        }
      >
    >


  export type infopaimentSelect = {
    id?: boolean
    mail?: boolean
    cartePaiment?: boolean
    ccv?: boolean
  }


  export type infopaimentGetPayload<S extends boolean | null | undefined | infopaimentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? infopaiment :
    S extends undefined ? never :
    S extends { include: any } & (infopaimentArgs | infopaimentFindManyArgs)
    ? infopaiment 
    : S extends { select: any } & (infopaimentArgs | infopaimentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof infopaiment ? infopaiment[P] : never
  } 
      : infopaiment


  type infopaimentCountArgs = 
    Omit<infopaimentFindManyArgs, 'select' | 'include'> & {
      select?: InfopaimentCountAggregateInputType | true
    }

  export interface infopaimentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Infopaiment that matches the filter.
     * @param {infopaimentFindUniqueArgs} args - Arguments to find a Infopaiment
     * @example
     * // Get one Infopaiment
     * const infopaiment = await prisma.infopaiment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends infopaimentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, infopaimentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'infopaiment'> extends True ? Prisma__infopaimentClient<infopaimentGetPayload<T>> : Prisma__infopaimentClient<infopaimentGetPayload<T> | null, null>

    /**
     * Find one Infopaiment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {infopaimentFindUniqueOrThrowArgs} args - Arguments to find a Infopaiment
     * @example
     * // Get one Infopaiment
     * const infopaiment = await prisma.infopaiment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends infopaimentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, infopaimentFindUniqueOrThrowArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Find the first Infopaiment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopaimentFindFirstArgs} args - Arguments to find a Infopaiment
     * @example
     * // Get one Infopaiment
     * const infopaiment = await prisma.infopaiment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends infopaimentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, infopaimentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'infopaiment'> extends True ? Prisma__infopaimentClient<infopaimentGetPayload<T>> : Prisma__infopaimentClient<infopaimentGetPayload<T> | null, null>

    /**
     * Find the first Infopaiment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopaimentFindFirstOrThrowArgs} args - Arguments to find a Infopaiment
     * @example
     * // Get one Infopaiment
     * const infopaiment = await prisma.infopaiment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends infopaimentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, infopaimentFindFirstOrThrowArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Find zero or more Infopaiments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopaimentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infopaiments
     * const infopaiments = await prisma.infopaiment.findMany()
     * 
     * // Get first 10 Infopaiments
     * const infopaiments = await prisma.infopaiment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infopaimentWithIdOnly = await prisma.infopaiment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends infopaimentFindManyArgs>(
      args?: SelectSubset<T, infopaimentFindManyArgs>
    ): Prisma.PrismaPromise<Array<infopaimentGetPayload<T>>>

    /**
     * Create a Infopaiment.
     * @param {infopaimentCreateArgs} args - Arguments to create a Infopaiment.
     * @example
     * // Create one Infopaiment
     * const Infopaiment = await prisma.infopaiment.create({
     *   data: {
     *     // ... data to create a Infopaiment
     *   }
     * })
     * 
    **/
    create<T extends infopaimentCreateArgs>(
      args: SelectSubset<T, infopaimentCreateArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Create many Infopaiments.
     *     @param {infopaimentCreateManyArgs} args - Arguments to create many Infopaiments.
     *     @example
     *     // Create many Infopaiments
     *     const infopaiment = await prisma.infopaiment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends infopaimentCreateManyArgs>(
      args?: SelectSubset<T, infopaimentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Infopaiment.
     * @param {infopaimentDeleteArgs} args - Arguments to delete one Infopaiment.
     * @example
     * // Delete one Infopaiment
     * const Infopaiment = await prisma.infopaiment.delete({
     *   where: {
     *     // ... filter to delete one Infopaiment
     *   }
     * })
     * 
    **/
    delete<T extends infopaimentDeleteArgs>(
      args: SelectSubset<T, infopaimentDeleteArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Update one Infopaiment.
     * @param {infopaimentUpdateArgs} args - Arguments to update one Infopaiment.
     * @example
     * // Update one Infopaiment
     * const infopaiment = await prisma.infopaiment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends infopaimentUpdateArgs>(
      args: SelectSubset<T, infopaimentUpdateArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Delete zero or more Infopaiments.
     * @param {infopaimentDeleteManyArgs} args - Arguments to filter Infopaiments to delete.
     * @example
     * // Delete a few Infopaiments
     * const { count } = await prisma.infopaiment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends infopaimentDeleteManyArgs>(
      args?: SelectSubset<T, infopaimentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infopaiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopaimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infopaiments
     * const infopaiment = await prisma.infopaiment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends infopaimentUpdateManyArgs>(
      args: SelectSubset<T, infopaimentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infopaiment.
     * @param {infopaimentUpsertArgs} args - Arguments to update or create a Infopaiment.
     * @example
     * // Update or create a Infopaiment
     * const infopaiment = await prisma.infopaiment.upsert({
     *   create: {
     *     // ... data to create a Infopaiment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infopaiment we want to update
     *   }
     * })
    **/
    upsert<T extends infopaimentUpsertArgs>(
      args: SelectSubset<T, infopaimentUpsertArgs>
    ): Prisma__infopaimentClient<infopaimentGetPayload<T>>

    /**
     * Count the number of Infopaiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infopaimentCountArgs} args - Arguments to filter Infopaiments to count.
     * @example
     * // Count the number of Infopaiments
     * const count = await prisma.infopaiment.count({
     *   where: {
     *     // ... the filter for the Infopaiments we want to count
     *   }
     * })
    **/
    count<T extends infopaimentCountArgs>(
      args?: Subset<T, infopaimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfopaimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infopaiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfopaimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfopaimentAggregateArgs>(args: Subset<T, InfopaimentAggregateArgs>): Prisma.PrismaPromise<GetInfopaimentAggregateType<T>>

    /**
     * Group by Infopaiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfopaimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfopaimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfopaimentGroupByArgs['orderBy'] }
        : { orderBy?: InfopaimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfopaimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfopaimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for infopaiment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__infopaimentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * infopaiment base type for findUnique actions
   */
  export type infopaimentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter, which infopaiment to fetch.
     */
    where: infopaimentWhereUniqueInput
  }

  /**
   * infopaiment findUnique
   */
  export interface infopaimentFindUniqueArgs extends infopaimentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infopaiment findUniqueOrThrow
   */
  export type infopaimentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter, which infopaiment to fetch.
     */
    where: infopaimentWhereUniqueInput
  }


  /**
   * infopaiment base type for findFirst actions
   */
  export type infopaimentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter, which infopaiment to fetch.
     */
    where?: infopaimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopaiments to fetch.
     */
    orderBy?: Enumerable<infopaimentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infopaiments.
     */
    cursor?: infopaimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopaiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopaiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infopaiments.
     */
    distinct?: Enumerable<InfopaimentScalarFieldEnum>
  }

  /**
   * infopaiment findFirst
   */
  export interface infopaimentFindFirstArgs extends infopaimentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * infopaiment findFirstOrThrow
   */
  export type infopaimentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter, which infopaiment to fetch.
     */
    where?: infopaimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopaiments to fetch.
     */
    orderBy?: Enumerable<infopaimentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infopaiments.
     */
    cursor?: infopaimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopaiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopaiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infopaiments.
     */
    distinct?: Enumerable<InfopaimentScalarFieldEnum>
  }


  /**
   * infopaiment findMany
   */
  export type infopaimentFindManyArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter, which infopaiments to fetch.
     */
    where?: infopaimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infopaiments to fetch.
     */
    orderBy?: Enumerable<infopaimentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing infopaiments.
     */
    cursor?: infopaimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infopaiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infopaiments.
     */
    skip?: number
    distinct?: Enumerable<InfopaimentScalarFieldEnum>
  }


  /**
   * infopaiment create
   */
  export type infopaimentCreateArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * The data needed to create a infopaiment.
     */
    data: XOR<infopaimentCreateInput, infopaimentUncheckedCreateInput>
  }


  /**
   * infopaiment createMany
   */
  export type infopaimentCreateManyArgs = {
    /**
     * The data used to create many infopaiments.
     */
    data: Enumerable<infopaimentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * infopaiment update
   */
  export type infopaimentUpdateArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * The data needed to update a infopaiment.
     */
    data: XOR<infopaimentUpdateInput, infopaimentUncheckedUpdateInput>
    /**
     * Choose, which infopaiment to update.
     */
    where: infopaimentWhereUniqueInput
  }


  /**
   * infopaiment updateMany
   */
  export type infopaimentUpdateManyArgs = {
    /**
     * The data used to update infopaiments.
     */
    data: XOR<infopaimentUpdateManyMutationInput, infopaimentUncheckedUpdateManyInput>
    /**
     * Filter which infopaiments to update
     */
    where?: infopaimentWhereInput
  }


  /**
   * infopaiment upsert
   */
  export type infopaimentUpsertArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * The filter to search for the infopaiment to update in case it exists.
     */
    where: infopaimentWhereUniqueInput
    /**
     * In case the infopaiment found by the `where` argument doesn't exist, create a new infopaiment with this data.
     */
    create: XOR<infopaimentCreateInput, infopaimentUncheckedCreateInput>
    /**
     * In case the infopaiment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<infopaimentUpdateInput, infopaimentUncheckedUpdateInput>
  }


  /**
   * infopaiment delete
   */
  export type infopaimentDeleteArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
    /**
     * Filter which infopaiment to delete.
     */
    where: infopaimentWhereUniqueInput
  }


  /**
   * infopaiment deleteMany
   */
  export type infopaimentDeleteManyArgs = {
    /**
     * Filter which infopaiments to delete
     */
    where?: infopaimentWhereInput
  }


  /**
   * infopaiment without action
   */
  export type infopaimentArgs = {
    /**
     * Select specific fields to fetch from the infopaiment
     */
    select?: infopaimentSelect | null
  }



  /**
   * Model pack
   */


  export type AggregatePack = {
    _count: PackCountAggregateOutputType | null
    _avg: PackAvgAggregateOutputType | null
    _sum: PackSumAggregateOutputType | null
    _min: PackMinAggregateOutputType | null
    _max: PackMaxAggregateOutputType | null
  }

  export type PackAvgAggregateOutputType = {
    idDistr: number | null
    idEntre: number | null
  }

  export type PackSumAggregateOutputType = {
    idDistr: number | null
    idEntre: number | null
  }

  export type PackMinAggregateOutputType = {
    idDistr: number | null
    idEntre: number | null
    codeverou: string | null
    localisation: string | null
    state: string | null
  }

  export type PackMaxAggregateOutputType = {
    idDistr: number | null
    idEntre: number | null
    codeverou: string | null
    localisation: string | null
    state: string | null
  }

  export type PackCountAggregateOutputType = {
    idDistr: number
    idEntre: number
    codeverou: number
    localisation: number
    state: number
    _all: number
  }


  export type PackAvgAggregateInputType = {
    idDistr?: true
    idEntre?: true
  }

  export type PackSumAggregateInputType = {
    idDistr?: true
    idEntre?: true
  }

  export type PackMinAggregateInputType = {
    idDistr?: true
    idEntre?: true
    codeverou?: true
    localisation?: true
    state?: true
  }

  export type PackMaxAggregateInputType = {
    idDistr?: true
    idEntre?: true
    codeverou?: true
    localisation?: true
    state?: true
  }

  export type PackCountAggregateInputType = {
    idDistr?: true
    idEntre?: true
    codeverou?: true
    localisation?: true
    state?: true
    _all?: true
  }

  export type PackAggregateArgs = {
    /**
     * Filter which pack to aggregate.
     */
    where?: packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packs to fetch.
     */
    orderBy?: Enumerable<packOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned packs
    **/
    _count?: true | PackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackMaxAggregateInputType
  }

  export type GetPackAggregateType<T extends PackAggregateArgs> = {
        [P in keyof T & keyof AggregatePack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePack[P]>
      : GetScalarType<T[P], AggregatePack[P]>
  }




  export type PackGroupByArgs = {
    where?: packWhereInput
    orderBy?: Enumerable<packOrderByWithAggregationInput>
    by: PackScalarFieldEnum[]
    having?: packScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackCountAggregateInputType | true
    _avg?: PackAvgAggregateInputType
    _sum?: PackSumAggregateInputType
    _min?: PackMinAggregateInputType
    _max?: PackMaxAggregateInputType
  }


  export type PackGroupByOutputType = {
    idDistr: number
    idEntre: number
    codeverou: string | null
    localisation: string | null
    state: string | null
    _count: PackCountAggregateOutputType | null
    _avg: PackAvgAggregateOutputType | null
    _sum: PackSumAggregateOutputType | null
    _min: PackMinAggregateOutputType | null
    _max: PackMaxAggregateOutputType | null
  }

  type GetPackGroupByPayload<T extends PackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackGroupByOutputType[P]>
            : GetScalarType<T[P], PackGroupByOutputType[P]>
        }
      >
    >


  export type packSelect = {
    idDistr?: boolean
    idEntre?: boolean
    codeverou?: boolean
    localisation?: boolean
    state?: boolean
    distr?: boolean | distributeurArgs
    entre?: boolean | entrepiseArgs
  }


  export type packInclude = {
    distr?: boolean | distributeurArgs
    entre?: boolean | entrepiseArgs
  }

  export type packGetPayload<S extends boolean | null | undefined | packArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pack :
    S extends undefined ? never :
    S extends { include: any } & (packArgs | packFindManyArgs)
    ? pack  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'distr' ? distributeurGetPayload<S['include'][P]> :
        P extends 'entre' ? entrepiseGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (packArgs | packFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'distr' ? distributeurGetPayload<S['select'][P]> :
        P extends 'entre' ? entrepiseGetPayload<S['select'][P]> :  P extends keyof pack ? pack[P] : never
  } 
      : pack


  type packCountArgs = 
    Omit<packFindManyArgs, 'select' | 'include'> & {
      select?: PackCountAggregateInputType | true
    }

  export interface packDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Pack that matches the filter.
     * @param {packFindUniqueArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends packFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, packFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pack'> extends True ? Prisma__packClient<packGetPayload<T>> : Prisma__packClient<packGetPayload<T> | null, null>

    /**
     * Find one Pack that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {packFindUniqueOrThrowArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends packFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, packFindUniqueOrThrowArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Find the first Pack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packFindFirstArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends packFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, packFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pack'> extends True ? Prisma__packClient<packGetPayload<T>> : Prisma__packClient<packGetPayload<T> | null, null>

    /**
     * Find the first Pack that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packFindFirstOrThrowArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends packFindFirstOrThrowArgs>(
      args?: SelectSubset<T, packFindFirstOrThrowArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Find zero or more Packs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packs
     * const packs = await prisma.pack.findMany()
     * 
     * // Get first 10 Packs
     * const packs = await prisma.pack.findMany({ take: 10 })
     * 
     * // Only select the `idDistr`
     * const packWithIdDistrOnly = await prisma.pack.findMany({ select: { idDistr: true } })
     * 
    **/
    findMany<T extends packFindManyArgs>(
      args?: SelectSubset<T, packFindManyArgs>
    ): Prisma.PrismaPromise<Array<packGetPayload<T>>>

    /**
     * Create a Pack.
     * @param {packCreateArgs} args - Arguments to create a Pack.
     * @example
     * // Create one Pack
     * const Pack = await prisma.pack.create({
     *   data: {
     *     // ... data to create a Pack
     *   }
     * })
     * 
    **/
    create<T extends packCreateArgs>(
      args: SelectSubset<T, packCreateArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Create many Packs.
     *     @param {packCreateManyArgs} args - Arguments to create many Packs.
     *     @example
     *     // Create many Packs
     *     const pack = await prisma.pack.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends packCreateManyArgs>(
      args?: SelectSubset<T, packCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pack.
     * @param {packDeleteArgs} args - Arguments to delete one Pack.
     * @example
     * // Delete one Pack
     * const Pack = await prisma.pack.delete({
     *   where: {
     *     // ... filter to delete one Pack
     *   }
     * })
     * 
    **/
    delete<T extends packDeleteArgs>(
      args: SelectSubset<T, packDeleteArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Update one Pack.
     * @param {packUpdateArgs} args - Arguments to update one Pack.
     * @example
     * // Update one Pack
     * const pack = await prisma.pack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends packUpdateArgs>(
      args: SelectSubset<T, packUpdateArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Delete zero or more Packs.
     * @param {packDeleteManyArgs} args - Arguments to filter Packs to delete.
     * @example
     * // Delete a few Packs
     * const { count } = await prisma.pack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends packDeleteManyArgs>(
      args?: SelectSubset<T, packDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packs
     * const pack = await prisma.pack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends packUpdateManyArgs>(
      args: SelectSubset<T, packUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pack.
     * @param {packUpsertArgs} args - Arguments to update or create a Pack.
     * @example
     * // Update or create a Pack
     * const pack = await prisma.pack.upsert({
     *   create: {
     *     // ... data to create a Pack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pack we want to update
     *   }
     * })
    **/
    upsert<T extends packUpsertArgs>(
      args: SelectSubset<T, packUpsertArgs>
    ): Prisma__packClient<packGetPayload<T>>

    /**
     * Count the number of Packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packCountArgs} args - Arguments to filter Packs to count.
     * @example
     * // Count the number of Packs
     * const count = await prisma.pack.count({
     *   where: {
     *     // ... the filter for the Packs we want to count
     *   }
     * })
    **/
    count<T extends packCountArgs>(
      args?: Subset<T, packCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackAggregateArgs>(args: Subset<T, PackAggregateArgs>): Prisma.PrismaPromise<GetPackAggregateType<T>>

    /**
     * Group by Pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackGroupByArgs['orderBy'] }
        : { orderBy?: PackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__packClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    distr<T extends distributeurArgs= {}>(args?: Subset<T, distributeurArgs>): Prisma__distributeurClient<distributeurGetPayload<T> | Null>;

    entre<T extends entrepiseArgs= {}>(args?: Subset<T, entrepiseArgs>): Prisma__entrepiseClient<entrepiseGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pack base type for findUnique actions
   */
  export type packFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter, which pack to fetch.
     */
    where: packWhereUniqueInput
  }

  /**
   * pack findUnique
   */
  export interface packFindUniqueArgs extends packFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pack findUniqueOrThrow
   */
  export type packFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter, which pack to fetch.
     */
    where: packWhereUniqueInput
  }


  /**
   * pack base type for findFirst actions
   */
  export type packFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter, which pack to fetch.
     */
    where?: packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packs to fetch.
     */
    orderBy?: Enumerable<packOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packs.
     */
    cursor?: packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packs.
     */
    distinct?: Enumerable<PackScalarFieldEnum>
  }

  /**
   * pack findFirst
   */
  export interface packFindFirstArgs extends packFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pack findFirstOrThrow
   */
  export type packFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter, which pack to fetch.
     */
    where?: packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packs to fetch.
     */
    orderBy?: Enumerable<packOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packs.
     */
    cursor?: packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packs.
     */
    distinct?: Enumerable<PackScalarFieldEnum>
  }


  /**
   * pack findMany
   */
  export type packFindManyArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter, which packs to fetch.
     */
    where?: packWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packs to fetch.
     */
    orderBy?: Enumerable<packOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing packs.
     */
    cursor?: packWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packs.
     */
    skip?: number
    distinct?: Enumerable<PackScalarFieldEnum>
  }


  /**
   * pack create
   */
  export type packCreateArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * The data needed to create a pack.
     */
    data: XOR<packCreateInput, packUncheckedCreateInput>
  }


  /**
   * pack createMany
   */
  export type packCreateManyArgs = {
    /**
     * The data used to create many packs.
     */
    data: Enumerable<packCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pack update
   */
  export type packUpdateArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * The data needed to update a pack.
     */
    data: XOR<packUpdateInput, packUncheckedUpdateInput>
    /**
     * Choose, which pack to update.
     */
    where: packWhereUniqueInput
  }


  /**
   * pack updateMany
   */
  export type packUpdateManyArgs = {
    /**
     * The data used to update packs.
     */
    data: XOR<packUpdateManyMutationInput, packUncheckedUpdateManyInput>
    /**
     * Filter which packs to update
     */
    where?: packWhereInput
  }


  /**
   * pack upsert
   */
  export type packUpsertArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * The filter to search for the pack to update in case it exists.
     */
    where: packWhereUniqueInput
    /**
     * In case the pack found by the `where` argument doesn't exist, create a new pack with this data.
     */
    create: XOR<packCreateInput, packUncheckedCreateInput>
    /**
     * In case the pack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<packUpdateInput, packUncheckedUpdateInput>
  }


  /**
   * pack delete
   */
  export type packDeleteArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
    /**
     * Filter which pack to delete.
     */
    where: packWhereUniqueInput
  }


  /**
   * pack deleteMany
   */
  export type packDeleteManyArgs = {
    /**
     * Filter which packs to delete
     */
    where?: packWhereInput
  }


  /**
   * pack without action
   */
  export type packArgs = {
    /**
     * Select specific fields to fetch from the pack
     */
    select?: packSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: packInclude | null
  }



  /**
   * Model publicite
   */


  export type AggregatePublicite = {
    _count: PubliciteCountAggregateOutputType | null
    _avg: PubliciteAvgAggregateOutputType | null
    _sum: PubliciteSumAggregateOutputType | null
    _min: PubliciteMinAggregateOutputType | null
    _max: PubliciteMaxAggregateOutputType | null
  }

  export type PubliciteAvgAggregateOutputType = {
    id: number | null
    idCategorie: number | null
    idCategRecette: number | null
    idAnnonceur: number | null
  }

  export type PubliciteSumAggregateOutputType = {
    id: number | null
    idCategorie: number | null
    idCategRecette: number | null
    idAnnonceur: number | null
  }

  export type PubliciteMinAggregateOutputType = {
    id: number | null
    url: string | null
    idCategorie: number | null
    idCategRecette: number | null
    idAnnonceur: number | null
  }

  export type PubliciteMaxAggregateOutputType = {
    id: number | null
    url: string | null
    idCategorie: number | null
    idCategRecette: number | null
    idAnnonceur: number | null
  }

  export type PubliciteCountAggregateOutputType = {
    id: number
    url: number
    idCategorie: number
    idCategRecette: number
    idAnnonceur: number
    _all: number
  }


  export type PubliciteAvgAggregateInputType = {
    id?: true
    idCategorie?: true
    idCategRecette?: true
    idAnnonceur?: true
  }

  export type PubliciteSumAggregateInputType = {
    id?: true
    idCategorie?: true
    idCategRecette?: true
    idAnnonceur?: true
  }

  export type PubliciteMinAggregateInputType = {
    id?: true
    url?: true
    idCategorie?: true
    idCategRecette?: true
    idAnnonceur?: true
  }

  export type PubliciteMaxAggregateInputType = {
    id?: true
    url?: true
    idCategorie?: true
    idCategRecette?: true
    idAnnonceur?: true
  }

  export type PubliciteCountAggregateInputType = {
    id?: true
    url?: true
    idCategorie?: true
    idCategRecette?: true
    idAnnonceur?: true
    _all?: true
  }

  export type PubliciteAggregateArgs = {
    /**
     * Filter which publicite to aggregate.
     */
    where?: publiciteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicites to fetch.
     */
    orderBy?: Enumerable<publiciteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publiciteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publicites
    **/
    _count?: true | PubliciteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PubliciteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PubliciteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PubliciteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PubliciteMaxAggregateInputType
  }

  export type GetPubliciteAggregateType<T extends PubliciteAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicite[P]>
      : GetScalarType<T[P], AggregatePublicite[P]>
  }




  export type PubliciteGroupByArgs = {
    where?: publiciteWhereInput
    orderBy?: Enumerable<publiciteOrderByWithAggregationInput>
    by: PubliciteScalarFieldEnum[]
    having?: publiciteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PubliciteCountAggregateInputType | true
    _avg?: PubliciteAvgAggregateInputType
    _sum?: PubliciteSumAggregateInputType
    _min?: PubliciteMinAggregateInputType
    _max?: PubliciteMaxAggregateInputType
  }


  export type PubliciteGroupByOutputType = {
    id: number
    url: string | null
    idCategorie: number | null
    idCategRecette: number | null
    idAnnonceur: number | null
    _count: PubliciteCountAggregateOutputType | null
    _avg: PubliciteAvgAggregateOutputType | null
    _sum: PubliciteSumAggregateOutputType | null
    _min: PubliciteMinAggregateOutputType | null
    _max: PubliciteMaxAggregateOutputType | null
  }

  type GetPubliciteGroupByPayload<T extends PubliciteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PubliciteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PubliciteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PubliciteGroupByOutputType[P]>
            : GetScalarType<T[P], PubliciteGroupByOutputType[P]>
        }
      >
    >


  export type publiciteSelect = {
    id?: boolean
    url?: boolean
    idCategorie?: boolean
    idCategRecette?: boolean
    idAnnonceur?: boolean
    categoryrecette?: boolean | categoryrecetteArgs
  }


  export type publiciteInclude = {
    categoryrecette?: boolean | categoryrecetteArgs
  }

  export type publiciteGetPayload<S extends boolean | null | undefined | publiciteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? publicite :
    S extends undefined ? never :
    S extends { include: any } & (publiciteArgs | publiciteFindManyArgs)
    ? publicite  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'categoryrecette' ? categoryrecetteGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (publiciteArgs | publiciteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'categoryrecette' ? categoryrecetteGetPayload<S['select'][P]> | null :  P extends keyof publicite ? publicite[P] : never
  } 
      : publicite


  type publiciteCountArgs = 
    Omit<publiciteFindManyArgs, 'select' | 'include'> & {
      select?: PubliciteCountAggregateInputType | true
    }

  export interface publiciteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Publicite that matches the filter.
     * @param {publiciteFindUniqueArgs} args - Arguments to find a Publicite
     * @example
     * // Get one Publicite
     * const publicite = await prisma.publicite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends publiciteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, publiciteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'publicite'> extends True ? Prisma__publiciteClient<publiciteGetPayload<T>> : Prisma__publiciteClient<publiciteGetPayload<T> | null, null>

    /**
     * Find one Publicite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {publiciteFindUniqueOrThrowArgs} args - Arguments to find a Publicite
     * @example
     * // Get one Publicite
     * const publicite = await prisma.publicite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends publiciteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, publiciteFindUniqueOrThrowArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Find the first Publicite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publiciteFindFirstArgs} args - Arguments to find a Publicite
     * @example
     * // Get one Publicite
     * const publicite = await prisma.publicite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends publiciteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, publiciteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'publicite'> extends True ? Prisma__publiciteClient<publiciteGetPayload<T>> : Prisma__publiciteClient<publiciteGetPayload<T> | null, null>

    /**
     * Find the first Publicite that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publiciteFindFirstOrThrowArgs} args - Arguments to find a Publicite
     * @example
     * // Get one Publicite
     * const publicite = await prisma.publicite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends publiciteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, publiciteFindFirstOrThrowArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Find zero or more Publicites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publiciteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicites
     * const publicites = await prisma.publicite.findMany()
     * 
     * // Get first 10 Publicites
     * const publicites = await prisma.publicite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publiciteWithIdOnly = await prisma.publicite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends publiciteFindManyArgs>(
      args?: SelectSubset<T, publiciteFindManyArgs>
    ): Prisma.PrismaPromise<Array<publiciteGetPayload<T>>>

    /**
     * Create a Publicite.
     * @param {publiciteCreateArgs} args - Arguments to create a Publicite.
     * @example
     * // Create one Publicite
     * const Publicite = await prisma.publicite.create({
     *   data: {
     *     // ... data to create a Publicite
     *   }
     * })
     * 
    **/
    create<T extends publiciteCreateArgs>(
      args: SelectSubset<T, publiciteCreateArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Create many Publicites.
     *     @param {publiciteCreateManyArgs} args - Arguments to create many Publicites.
     *     @example
     *     // Create many Publicites
     *     const publicite = await prisma.publicite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends publiciteCreateManyArgs>(
      args?: SelectSubset<T, publiciteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publicite.
     * @param {publiciteDeleteArgs} args - Arguments to delete one Publicite.
     * @example
     * // Delete one Publicite
     * const Publicite = await prisma.publicite.delete({
     *   where: {
     *     // ... filter to delete one Publicite
     *   }
     * })
     * 
    **/
    delete<T extends publiciteDeleteArgs>(
      args: SelectSubset<T, publiciteDeleteArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Update one Publicite.
     * @param {publiciteUpdateArgs} args - Arguments to update one Publicite.
     * @example
     * // Update one Publicite
     * const publicite = await prisma.publicite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends publiciteUpdateArgs>(
      args: SelectSubset<T, publiciteUpdateArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Delete zero or more Publicites.
     * @param {publiciteDeleteManyArgs} args - Arguments to filter Publicites to delete.
     * @example
     * // Delete a few Publicites
     * const { count } = await prisma.publicite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends publiciteDeleteManyArgs>(
      args?: SelectSubset<T, publiciteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publicites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publiciteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicites
     * const publicite = await prisma.publicite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends publiciteUpdateManyArgs>(
      args: SelectSubset<T, publiciteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publicite.
     * @param {publiciteUpsertArgs} args - Arguments to update or create a Publicite.
     * @example
     * // Update or create a Publicite
     * const publicite = await prisma.publicite.upsert({
     *   create: {
     *     // ... data to create a Publicite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicite we want to update
     *   }
     * })
    **/
    upsert<T extends publiciteUpsertArgs>(
      args: SelectSubset<T, publiciteUpsertArgs>
    ): Prisma__publiciteClient<publiciteGetPayload<T>>

    /**
     * Count the number of Publicites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publiciteCountArgs} args - Arguments to filter Publicites to count.
     * @example
     * // Count the number of Publicites
     * const count = await prisma.publicite.count({
     *   where: {
     *     // ... the filter for the Publicites we want to count
     *   }
     * })
    **/
    count<T extends publiciteCountArgs>(
      args?: Subset<T, publiciteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PubliciteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publicite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubliciteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PubliciteAggregateArgs>(args: Subset<T, PubliciteAggregateArgs>): Prisma.PrismaPromise<GetPubliciteAggregateType<T>>

    /**
     * Group by Publicite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubliciteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PubliciteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PubliciteGroupByArgs['orderBy'] }
        : { orderBy?: PubliciteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PubliciteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPubliciteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for publicite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__publiciteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    categoryrecette<T extends categoryrecetteArgs= {}>(args?: Subset<T, categoryrecetteArgs>): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * publicite base type for findUnique actions
   */
  export type publiciteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter, which publicite to fetch.
     */
    where: publiciteWhereUniqueInput
  }

  /**
   * publicite findUnique
   */
  export interface publiciteFindUniqueArgs extends publiciteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicite findUniqueOrThrow
   */
  export type publiciteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter, which publicite to fetch.
     */
    where: publiciteWhereUniqueInput
  }


  /**
   * publicite base type for findFirst actions
   */
  export type publiciteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter, which publicite to fetch.
     */
    where?: publiciteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicites to fetch.
     */
    orderBy?: Enumerable<publiciteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicites.
     */
    cursor?: publiciteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicites.
     */
    distinct?: Enumerable<PubliciteScalarFieldEnum>
  }

  /**
   * publicite findFirst
   */
  export interface publiciteFindFirstArgs extends publiciteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * publicite findFirstOrThrow
   */
  export type publiciteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter, which publicite to fetch.
     */
    where?: publiciteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicites to fetch.
     */
    orderBy?: Enumerable<publiciteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publicites.
     */
    cursor?: publiciteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publicites.
     */
    distinct?: Enumerable<PubliciteScalarFieldEnum>
  }


  /**
   * publicite findMany
   */
  export type publiciteFindManyArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter, which publicites to fetch.
     */
    where?: publiciteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publicites to fetch.
     */
    orderBy?: Enumerable<publiciteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publicites.
     */
    cursor?: publiciteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publicites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publicites.
     */
    skip?: number
    distinct?: Enumerable<PubliciteScalarFieldEnum>
  }


  /**
   * publicite create
   */
  export type publiciteCreateArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * The data needed to create a publicite.
     */
    data: XOR<publiciteCreateInput, publiciteUncheckedCreateInput>
  }


  /**
   * publicite createMany
   */
  export type publiciteCreateManyArgs = {
    /**
     * The data used to create many publicites.
     */
    data: Enumerable<publiciteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * publicite update
   */
  export type publiciteUpdateArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * The data needed to update a publicite.
     */
    data: XOR<publiciteUpdateInput, publiciteUncheckedUpdateInput>
    /**
     * Choose, which publicite to update.
     */
    where: publiciteWhereUniqueInput
  }


  /**
   * publicite updateMany
   */
  export type publiciteUpdateManyArgs = {
    /**
     * The data used to update publicites.
     */
    data: XOR<publiciteUpdateManyMutationInput, publiciteUncheckedUpdateManyInput>
    /**
     * Filter which publicites to update
     */
    where?: publiciteWhereInput
  }


  /**
   * publicite upsert
   */
  export type publiciteUpsertArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * The filter to search for the publicite to update in case it exists.
     */
    where: publiciteWhereUniqueInput
    /**
     * In case the publicite found by the `where` argument doesn't exist, create a new publicite with this data.
     */
    create: XOR<publiciteCreateInput, publiciteUncheckedCreateInput>
    /**
     * In case the publicite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publiciteUpdateInput, publiciteUncheckedUpdateInput>
  }


  /**
   * publicite delete
   */
  export type publiciteDeleteArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
    /**
     * Filter which publicite to delete.
     */
    where: publiciteWhereUniqueInput
  }


  /**
   * publicite deleteMany
   */
  export type publiciteDeleteManyArgs = {
    /**
     * Filter which publicites to delete
     */
    where?: publiciteWhereInput
  }


  /**
   * publicite without action
   */
  export type publiciteArgs = {
    /**
     * Select specific fields to fetch from the publicite
     */
    select?: publiciteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: publiciteInclude | null
  }



  /**
   * Model recette
   */


  export type AggregateRecette = {
    _count: RecetteCountAggregateOutputType | null
    _avg: RecetteAvgAggregateOutputType | null
    _sum: RecetteSumAggregateOutputType | null
    _min: RecetteMinAggregateOutputType | null
    _max: RecetteMaxAggregateOutputType | null
  }

  export type RecetteAvgAggregateOutputType = {
    id: number | null
    idCategRecette: number | null
    price: Decimal | null
  }

  export type RecetteSumAggregateOutputType = {
    id: number | null
    idCategRecette: number | null
    price: Decimal | null
  }

  export type RecetteMinAggregateOutputType = {
    id: number | null
    idCategRecette: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    imageLink: string | null
  }

  export type RecetteMaxAggregateOutputType = {
    id: number | null
    idCategRecette: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    imageLink: string | null
  }

  export type RecetteCountAggregateOutputType = {
    id: number
    idCategRecette: number
    name: number
    description: number
    price: number
    imageLink: number
    _all: number
  }


  export type RecetteAvgAggregateInputType = {
    id?: true
    idCategRecette?: true
    price?: true
  }

  export type RecetteSumAggregateInputType = {
    id?: true
    idCategRecette?: true
    price?: true
  }

  export type RecetteMinAggregateInputType = {
    id?: true
    idCategRecette?: true
    name?: true
    description?: true
    price?: true
    imageLink?: true
  }

  export type RecetteMaxAggregateInputType = {
    id?: true
    idCategRecette?: true
    name?: true
    description?: true
    price?: true
    imageLink?: true
  }

  export type RecetteCountAggregateInputType = {
    id?: true
    idCategRecette?: true
    name?: true
    description?: true
    price?: true
    imageLink?: true
    _all?: true
  }

  export type RecetteAggregateArgs = {
    /**
     * Filter which recette to aggregate.
     */
    where?: recetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recettes to fetch.
     */
    orderBy?: Enumerable<recetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recettes
    **/
    _count?: true | RecetteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetteMaxAggregateInputType
  }

  export type GetRecetteAggregateType<T extends RecetteAggregateArgs> = {
        [P in keyof T & keyof AggregateRecette]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecette[P]>
      : GetScalarType<T[P], AggregateRecette[P]>
  }




  export type RecetteGroupByArgs = {
    where?: recetteWhereInput
    orderBy?: Enumerable<recetteOrderByWithAggregationInput>
    by: RecetteScalarFieldEnum[]
    having?: recetteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetteCountAggregateInputType | true
    _avg?: RecetteAvgAggregateInputType
    _sum?: RecetteSumAggregateInputType
    _min?: RecetteMinAggregateInputType
    _max?: RecetteMaxAggregateInputType
  }


  export type RecetteGroupByOutputType = {
    id: number
    idCategRecette: number | null
    name: string | null
    description: string | null
    price: Decimal
    imageLink: string | null
    _count: RecetteCountAggregateOutputType | null
    _avg: RecetteAvgAggregateOutputType | null
    _sum: RecetteSumAggregateOutputType | null
    _min: RecetteMinAggregateOutputType | null
    _max: RecetteMaxAggregateOutputType | null
  }

  type GetRecetteGroupByPayload<T extends RecetteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RecetteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetteGroupByOutputType[P]>
            : GetScalarType<T[P], RecetteGroupByOutputType[P]>
        }
      >
    >


  export type recetteSelect = {
    id?: boolean
    idCategRecette?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    imageLink?: boolean
    commande?: boolean | recette$commandeArgs
    categoryrecette?: boolean | categoryrecetteArgs
    recetteingr?: boolean | recette$recetteingrArgs
    _count?: boolean | RecetteCountOutputTypeArgs
  }


  export type recetteInclude = {
    commande?: boolean | recette$commandeArgs
    categoryrecette?: boolean | categoryrecetteArgs
    recetteingr?: boolean | recette$recetteingrArgs
    _count?: boolean | RecetteCountOutputTypeArgs
  }

  export type recetteGetPayload<S extends boolean | null | undefined | recetteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? recette :
    S extends undefined ? never :
    S extends { include: any } & (recetteArgs | recetteFindManyArgs)
    ? recette  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commande' ? Array < commandeGetPayload<S['include'][P]>>  :
        P extends 'categoryrecette' ? categoryrecetteGetPayload<S['include'][P]> | null :
        P extends 'recetteingr' ? Array < recetteingrGetPayload<S['include'][P]>>  :
        P extends '_count' ? RecetteCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (recetteArgs | recetteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commande' ? Array < commandeGetPayload<S['select'][P]>>  :
        P extends 'categoryrecette' ? categoryrecetteGetPayload<S['select'][P]> | null :
        P extends 'recetteingr' ? Array < recetteingrGetPayload<S['select'][P]>>  :
        P extends '_count' ? RecetteCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof recette ? recette[P] : never
  } 
      : recette


  type recetteCountArgs = 
    Omit<recetteFindManyArgs, 'select' | 'include'> & {
      select?: RecetteCountAggregateInputType | true
    }

  export interface recetteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Recette that matches the filter.
     * @param {recetteFindUniqueArgs} args - Arguments to find a Recette
     * @example
     * // Get one Recette
     * const recette = await prisma.recette.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recetteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, recetteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'recette'> extends True ? Prisma__recetteClient<recetteGetPayload<T>> : Prisma__recetteClient<recetteGetPayload<T> | null, null>

    /**
     * Find one Recette that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {recetteFindUniqueOrThrowArgs} args - Arguments to find a Recette
     * @example
     * // Get one Recette
     * const recette = await prisma.recette.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends recetteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, recetteFindUniqueOrThrowArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Find the first Recette that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteFindFirstArgs} args - Arguments to find a Recette
     * @example
     * // Get one Recette
     * const recette = await prisma.recette.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recetteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, recetteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'recette'> extends True ? Prisma__recetteClient<recetteGetPayload<T>> : Prisma__recetteClient<recetteGetPayload<T> | null, null>

    /**
     * Find the first Recette that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteFindFirstOrThrowArgs} args - Arguments to find a Recette
     * @example
     * // Get one Recette
     * const recette = await prisma.recette.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends recetteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, recetteFindFirstOrThrowArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Find zero or more Recettes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recettes
     * const recettes = await prisma.recette.findMany()
     * 
     * // Get first 10 Recettes
     * const recettes = await prisma.recette.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recetteWithIdOnly = await prisma.recette.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends recetteFindManyArgs>(
      args?: SelectSubset<T, recetteFindManyArgs>
    ): Prisma.PrismaPromise<Array<recetteGetPayload<T>>>

    /**
     * Create a Recette.
     * @param {recetteCreateArgs} args - Arguments to create a Recette.
     * @example
     * // Create one Recette
     * const Recette = await prisma.recette.create({
     *   data: {
     *     // ... data to create a Recette
     *   }
     * })
     * 
    **/
    create<T extends recetteCreateArgs>(
      args: SelectSubset<T, recetteCreateArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Create many Recettes.
     *     @param {recetteCreateManyArgs} args - Arguments to create many Recettes.
     *     @example
     *     // Create many Recettes
     *     const recette = await prisma.recette.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recetteCreateManyArgs>(
      args?: SelectSubset<T, recetteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recette.
     * @param {recetteDeleteArgs} args - Arguments to delete one Recette.
     * @example
     * // Delete one Recette
     * const Recette = await prisma.recette.delete({
     *   where: {
     *     // ... filter to delete one Recette
     *   }
     * })
     * 
    **/
    delete<T extends recetteDeleteArgs>(
      args: SelectSubset<T, recetteDeleteArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Update one Recette.
     * @param {recetteUpdateArgs} args - Arguments to update one Recette.
     * @example
     * // Update one Recette
     * const recette = await prisma.recette.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recetteUpdateArgs>(
      args: SelectSubset<T, recetteUpdateArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Delete zero or more Recettes.
     * @param {recetteDeleteManyArgs} args - Arguments to filter Recettes to delete.
     * @example
     * // Delete a few Recettes
     * const { count } = await prisma.recette.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recetteDeleteManyArgs>(
      args?: SelectSubset<T, recetteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recettes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recettes
     * const recette = await prisma.recette.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recetteUpdateManyArgs>(
      args: SelectSubset<T, recetteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recette.
     * @param {recetteUpsertArgs} args - Arguments to update or create a Recette.
     * @example
     * // Update or create a Recette
     * const recette = await prisma.recette.upsert({
     *   create: {
     *     // ... data to create a Recette
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recette we want to update
     *   }
     * })
    **/
    upsert<T extends recetteUpsertArgs>(
      args: SelectSubset<T, recetteUpsertArgs>
    ): Prisma__recetteClient<recetteGetPayload<T>>

    /**
     * Count the number of Recettes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteCountArgs} args - Arguments to filter Recettes to count.
     * @example
     * // Count the number of Recettes
     * const count = await prisma.recette.count({
     *   where: {
     *     // ... the filter for the Recettes we want to count
     *   }
     * })
    **/
    count<T extends recetteCountArgs>(
      args?: Subset<T, recetteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recette.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetteAggregateArgs>(args: Subset<T, RecetteAggregateArgs>): Prisma.PrismaPromise<GetRecetteAggregateType<T>>

    /**
     * Group by Recette.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetteGroupByArgs['orderBy'] }
        : { orderBy?: RecetteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for recette.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__recetteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commande<T extends recette$commandeArgs= {}>(args?: Subset<T, recette$commandeArgs>): Prisma.PrismaPromise<Array<commandeGetPayload<T>>| Null>;

    categoryrecette<T extends categoryrecetteArgs= {}>(args?: Subset<T, categoryrecetteArgs>): Prisma__categoryrecetteClient<categoryrecetteGetPayload<T> | Null>;

    recetteingr<T extends recette$recetteingrArgs= {}>(args?: Subset<T, recette$recetteingrArgs>): Prisma.PrismaPromise<Array<recetteingrGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * recette base type for findUnique actions
   */
  export type recetteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter, which recette to fetch.
     */
    where: recetteWhereUniqueInput
  }

  /**
   * recette findUnique
   */
  export interface recetteFindUniqueArgs extends recetteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recette findUniqueOrThrow
   */
  export type recetteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter, which recette to fetch.
     */
    where: recetteWhereUniqueInput
  }


  /**
   * recette base type for findFirst actions
   */
  export type recetteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter, which recette to fetch.
     */
    where?: recetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recettes to fetch.
     */
    orderBy?: Enumerable<recetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recettes.
     */
    cursor?: recetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recettes.
     */
    distinct?: Enumerable<RecetteScalarFieldEnum>
  }

  /**
   * recette findFirst
   */
  export interface recetteFindFirstArgs extends recetteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recette findFirstOrThrow
   */
  export type recetteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter, which recette to fetch.
     */
    where?: recetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recettes to fetch.
     */
    orderBy?: Enumerable<recetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recettes.
     */
    cursor?: recetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recettes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recettes.
     */
    distinct?: Enumerable<RecetteScalarFieldEnum>
  }


  /**
   * recette findMany
   */
  export type recetteFindManyArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter, which recettes to fetch.
     */
    where?: recetteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recettes to fetch.
     */
    orderBy?: Enumerable<recetteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recettes.
     */
    cursor?: recetteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recettes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recettes.
     */
    skip?: number
    distinct?: Enumerable<RecetteScalarFieldEnum>
  }


  /**
   * recette create
   */
  export type recetteCreateArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * The data needed to create a recette.
     */
    data: XOR<recetteCreateInput, recetteUncheckedCreateInput>
  }


  /**
   * recette createMany
   */
  export type recetteCreateManyArgs = {
    /**
     * The data used to create many recettes.
     */
    data: Enumerable<recetteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * recette update
   */
  export type recetteUpdateArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * The data needed to update a recette.
     */
    data: XOR<recetteUpdateInput, recetteUncheckedUpdateInput>
    /**
     * Choose, which recette to update.
     */
    where: recetteWhereUniqueInput
  }


  /**
   * recette updateMany
   */
  export type recetteUpdateManyArgs = {
    /**
     * The data used to update recettes.
     */
    data: XOR<recetteUpdateManyMutationInput, recetteUncheckedUpdateManyInput>
    /**
     * Filter which recettes to update
     */
    where?: recetteWhereInput
  }


  /**
   * recette upsert
   */
  export type recetteUpsertArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * The filter to search for the recette to update in case it exists.
     */
    where: recetteWhereUniqueInput
    /**
     * In case the recette found by the `where` argument doesn't exist, create a new recette with this data.
     */
    create: XOR<recetteCreateInput, recetteUncheckedCreateInput>
    /**
     * In case the recette was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recetteUpdateInput, recetteUncheckedUpdateInput>
  }


  /**
   * recette delete
   */
  export type recetteDeleteArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
    /**
     * Filter which recette to delete.
     */
    where: recetteWhereUniqueInput
  }


  /**
   * recette deleteMany
   */
  export type recetteDeleteManyArgs = {
    /**
     * Filter which recettes to delete
     */
    where?: recetteWhereInput
  }


  /**
   * recette.commande
   */
  export type recette$commandeArgs = {
    /**
     * Select specific fields to fetch from the commande
     */
    select?: commandeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commandeInclude | null
    where?: commandeWhereInput
    orderBy?: Enumerable<commandeOrderByWithRelationInput>
    cursor?: commandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommandeScalarFieldEnum>
  }


  /**
   * recette.recetteingr
   */
  export type recette$recetteingrArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    where?: recetteingrWhereInput
    orderBy?: Enumerable<recetteingrOrderByWithRelationInput>
    cursor?: recetteingrWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RecetteingrScalarFieldEnum>
  }


  /**
   * recette without action
   */
  export type recetteArgs = {
    /**
     * Select specific fields to fetch from the recette
     */
    select?: recetteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteInclude | null
  }



  /**
   * Model reclamation
   */


  export type AggregateReclamation = {
    _count: ReclamationCountAggregateOutputType | null
    _avg: ReclamationAvgAggregateOutputType | null
    _sum: ReclamationSumAggregateOutputType | null
    _min: ReclamationMinAggregateOutputType | null
    _max: ReclamationMaxAggregateOutputType | null
  }

  export type ReclamationAvgAggregateOutputType = {
    id: number | null
    idFacture: number | null
  }

  export type ReclamationSumAggregateOutputType = {
    id: number | null
    idFacture: number | null
  }

  export type ReclamationMinAggregateOutputType = {
    id: number | null
    idFacture: number | null
    message: string | null
    isDone: boolean | null
  }

  export type ReclamationMaxAggregateOutputType = {
    id: number | null
    idFacture: number | null
    message: string | null
    isDone: boolean | null
  }

  export type ReclamationCountAggregateOutputType = {
    id: number
    idFacture: number
    message: number
    isDone: number
    _all: number
  }


  export type ReclamationAvgAggregateInputType = {
    id?: true
    idFacture?: true
  }

  export type ReclamationSumAggregateInputType = {
    id?: true
    idFacture?: true
  }

  export type ReclamationMinAggregateInputType = {
    id?: true
    idFacture?: true
    message?: true
    isDone?: true
  }

  export type ReclamationMaxAggregateInputType = {
    id?: true
    idFacture?: true
    message?: true
    isDone?: true
  }

  export type ReclamationCountAggregateInputType = {
    id?: true
    idFacture?: true
    message?: true
    isDone?: true
    _all?: true
  }

  export type ReclamationAggregateArgs = {
    /**
     * Filter which reclamation to aggregate.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: Enumerable<reclamationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reclamations
    **/
    _count?: true | ReclamationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReclamationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReclamationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReclamationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReclamationMaxAggregateInputType
  }

  export type GetReclamationAggregateType<T extends ReclamationAggregateArgs> = {
        [P in keyof T & keyof AggregateReclamation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReclamation[P]>
      : GetScalarType<T[P], AggregateReclamation[P]>
  }




  export type ReclamationGroupByArgs = {
    where?: reclamationWhereInput
    orderBy?: Enumerable<reclamationOrderByWithAggregationInput>
    by: ReclamationScalarFieldEnum[]
    having?: reclamationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReclamationCountAggregateInputType | true
    _avg?: ReclamationAvgAggregateInputType
    _sum?: ReclamationSumAggregateInputType
    _min?: ReclamationMinAggregateInputType
    _max?: ReclamationMaxAggregateInputType
  }


  export type ReclamationGroupByOutputType = {
    id: number
    idFacture: number | null
    message: string | null
    isDone: boolean | null
    _count: ReclamationCountAggregateOutputType | null
    _avg: ReclamationAvgAggregateOutputType | null
    _sum: ReclamationSumAggregateOutputType | null
    _min: ReclamationMinAggregateOutputType | null
    _max: ReclamationMaxAggregateOutputType | null
  }

  type GetReclamationGroupByPayload<T extends ReclamationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReclamationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReclamationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReclamationGroupByOutputType[P]>
            : GetScalarType<T[P], ReclamationGroupByOutputType[P]>
        }
      >
    >


  export type reclamationSelect = {
    id?: boolean
    idFacture?: boolean
    message?: boolean
    isDone?: boolean
  }


  export type reclamationGetPayload<S extends boolean | null | undefined | reclamationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reclamation :
    S extends undefined ? never :
    S extends { include: any } & (reclamationArgs | reclamationFindManyArgs)
    ? reclamation 
    : S extends { select: any } & (reclamationArgs | reclamationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reclamation ? reclamation[P] : never
  } 
      : reclamation


  type reclamationCountArgs = 
    Omit<reclamationFindManyArgs, 'select' | 'include'> & {
      select?: ReclamationCountAggregateInputType | true
    }

  export interface reclamationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reclamation that matches the filter.
     * @param {reclamationFindUniqueArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reclamationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reclamationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reclamation'> extends True ? Prisma__reclamationClient<reclamationGetPayload<T>> : Prisma__reclamationClient<reclamationGetPayload<T> | null, null>

    /**
     * Find one Reclamation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reclamationFindUniqueOrThrowArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reclamationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reclamationFindUniqueOrThrowArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Find the first Reclamation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindFirstArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reclamationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reclamationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reclamation'> extends True ? Prisma__reclamationClient<reclamationGetPayload<T>> : Prisma__reclamationClient<reclamationGetPayload<T> | null, null>

    /**
     * Find the first Reclamation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindFirstOrThrowArgs} args - Arguments to find a Reclamation
     * @example
     * // Get one Reclamation
     * const reclamation = await prisma.reclamation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reclamationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reclamationFindFirstOrThrowArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Find zero or more Reclamations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reclamations
     * const reclamations = await prisma.reclamation.findMany()
     * 
     * // Get first 10 Reclamations
     * const reclamations = await prisma.reclamation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reclamationWithIdOnly = await prisma.reclamation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reclamationFindManyArgs>(
      args?: SelectSubset<T, reclamationFindManyArgs>
    ): Prisma.PrismaPromise<Array<reclamationGetPayload<T>>>

    /**
     * Create a Reclamation.
     * @param {reclamationCreateArgs} args - Arguments to create a Reclamation.
     * @example
     * // Create one Reclamation
     * const Reclamation = await prisma.reclamation.create({
     *   data: {
     *     // ... data to create a Reclamation
     *   }
     * })
     * 
    **/
    create<T extends reclamationCreateArgs>(
      args: SelectSubset<T, reclamationCreateArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Create many Reclamations.
     *     @param {reclamationCreateManyArgs} args - Arguments to create many Reclamations.
     *     @example
     *     // Create many Reclamations
     *     const reclamation = await prisma.reclamation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reclamationCreateManyArgs>(
      args?: SelectSubset<T, reclamationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reclamation.
     * @param {reclamationDeleteArgs} args - Arguments to delete one Reclamation.
     * @example
     * // Delete one Reclamation
     * const Reclamation = await prisma.reclamation.delete({
     *   where: {
     *     // ... filter to delete one Reclamation
     *   }
     * })
     * 
    **/
    delete<T extends reclamationDeleteArgs>(
      args: SelectSubset<T, reclamationDeleteArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Update one Reclamation.
     * @param {reclamationUpdateArgs} args - Arguments to update one Reclamation.
     * @example
     * // Update one Reclamation
     * const reclamation = await prisma.reclamation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reclamationUpdateArgs>(
      args: SelectSubset<T, reclamationUpdateArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Delete zero or more Reclamations.
     * @param {reclamationDeleteManyArgs} args - Arguments to filter Reclamations to delete.
     * @example
     * // Delete a few Reclamations
     * const { count } = await prisma.reclamation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reclamationDeleteManyArgs>(
      args?: SelectSubset<T, reclamationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reclamations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reclamations
     * const reclamation = await prisma.reclamation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reclamationUpdateManyArgs>(
      args: SelectSubset<T, reclamationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reclamation.
     * @param {reclamationUpsertArgs} args - Arguments to update or create a Reclamation.
     * @example
     * // Update or create a Reclamation
     * const reclamation = await prisma.reclamation.upsert({
     *   create: {
     *     // ... data to create a Reclamation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reclamation we want to update
     *   }
     * })
    **/
    upsert<T extends reclamationUpsertArgs>(
      args: SelectSubset<T, reclamationUpsertArgs>
    ): Prisma__reclamationClient<reclamationGetPayload<T>>

    /**
     * Count the number of Reclamations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reclamationCountArgs} args - Arguments to filter Reclamations to count.
     * @example
     * // Count the number of Reclamations
     * const count = await prisma.reclamation.count({
     *   where: {
     *     // ... the filter for the Reclamations we want to count
     *   }
     * })
    **/
    count<T extends reclamationCountArgs>(
      args?: Subset<T, reclamationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReclamationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reclamation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReclamationAggregateArgs>(args: Subset<T, ReclamationAggregateArgs>): Prisma.PrismaPromise<GetReclamationAggregateType<T>>

    /**
     * Group by Reclamation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReclamationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReclamationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReclamationGroupByArgs['orderBy'] }
        : { orderBy?: ReclamationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReclamationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReclamationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reclamation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reclamationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reclamation base type for findUnique actions
   */
  export type reclamationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter, which reclamation to fetch.
     */
    where: reclamationWhereUniqueInput
  }

  /**
   * reclamation findUnique
   */
  export interface reclamationFindUniqueArgs extends reclamationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reclamation findUniqueOrThrow
   */
  export type reclamationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter, which reclamation to fetch.
     */
    where: reclamationWhereUniqueInput
  }


  /**
   * reclamation base type for findFirst actions
   */
  export type reclamationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter, which reclamation to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: Enumerable<reclamationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reclamations.
     */
    distinct?: Enumerable<ReclamationScalarFieldEnum>
  }

  /**
   * reclamation findFirst
   */
  export interface reclamationFindFirstArgs extends reclamationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reclamation findFirstOrThrow
   */
  export type reclamationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter, which reclamation to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: Enumerable<reclamationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reclamations.
     */
    distinct?: Enumerable<ReclamationScalarFieldEnum>
  }


  /**
   * reclamation findMany
   */
  export type reclamationFindManyArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter, which reclamations to fetch.
     */
    where?: reclamationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reclamations to fetch.
     */
    orderBy?: Enumerable<reclamationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reclamations.
     */
    cursor?: reclamationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reclamations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reclamations.
     */
    skip?: number
    distinct?: Enumerable<ReclamationScalarFieldEnum>
  }


  /**
   * reclamation create
   */
  export type reclamationCreateArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * The data needed to create a reclamation.
     */
    data: XOR<reclamationCreateInput, reclamationUncheckedCreateInput>
  }


  /**
   * reclamation createMany
   */
  export type reclamationCreateManyArgs = {
    /**
     * The data used to create many reclamations.
     */
    data: Enumerable<reclamationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reclamation update
   */
  export type reclamationUpdateArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * The data needed to update a reclamation.
     */
    data: XOR<reclamationUpdateInput, reclamationUncheckedUpdateInput>
    /**
     * Choose, which reclamation to update.
     */
    where: reclamationWhereUniqueInput
  }


  /**
   * reclamation updateMany
   */
  export type reclamationUpdateManyArgs = {
    /**
     * The data used to update reclamations.
     */
    data: XOR<reclamationUpdateManyMutationInput, reclamationUncheckedUpdateManyInput>
    /**
     * Filter which reclamations to update
     */
    where?: reclamationWhereInput
  }


  /**
   * reclamation upsert
   */
  export type reclamationUpsertArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * The filter to search for the reclamation to update in case it exists.
     */
    where: reclamationWhereUniqueInput
    /**
     * In case the reclamation found by the `where` argument doesn't exist, create a new reclamation with this data.
     */
    create: XOR<reclamationCreateInput, reclamationUncheckedCreateInput>
    /**
     * In case the reclamation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reclamationUpdateInput, reclamationUncheckedUpdateInput>
  }


  /**
   * reclamation delete
   */
  export type reclamationDeleteArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
    /**
     * Filter which reclamation to delete.
     */
    where: reclamationWhereUniqueInput
  }


  /**
   * reclamation deleteMany
   */
  export type reclamationDeleteManyArgs = {
    /**
     * Filter which reclamations to delete
     */
    where?: reclamationWhereInput
  }


  /**
   * reclamation without action
   */
  export type reclamationArgs = {
    /**
     * Select specific fields to fetch from the reclamation
     */
    select?: reclamationSelect | null
  }



  /**
   * Model task
   */


  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idUser: number | null
    idEntre: number | null
    idType: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idUser: number | null
    idEntre: number | null
    idType: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idUser: number | null
    idEntre: number | null
    idType: number | null
    isDone: boolean | null
    isOpen: boolean | null
    date: string | null
    time: string | null
    message: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    idDistr: number | null
    idUser: number | null
    idEntre: number | null
    idType: number | null
    isDone: boolean | null
    isOpen: boolean | null
    date: string | null
    time: string | null
    message: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    idDistr: number
    idUser: number
    idEntre: number
    idType: number
    isDone: number
    isOpen: number
    date: number
    time: number
    message: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    idDistr?: true
    idUser?: true
    idEntre?: true
    idType?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    idDistr?: true
    idUser?: true
    idEntre?: true
    idType?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    idDistr?: true
    idUser?: true
    idEntre?: true
    idType?: true
    isDone?: true
    isOpen?: true
    date?: true
    time?: true
    message?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    idDistr?: true
    idUser?: true
    idEntre?: true
    idType?: true
    isDone?: true
    isOpen?: true
    date?: true
    time?: true
    message?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    idDistr?: true
    idUser?: true
    idEntre?: true
    idType?: true
    isDone?: true
    isOpen?: true
    date?: true
    time?: true
    message?: true
    _all?: true
  }

  export type TaskAggregateArgs = {
    /**
     * Filter which task to aggregate.
     */
    where?: taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs = {
    where?: taskWhereInput
    orderBy?: Enumerable<taskOrderByWithAggregationInput>
    by: TaskScalarFieldEnum[]
    having?: taskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }


  export type TaskGroupByOutputType = {
    id: number
    idDistr: number
    idUser: number | null
    idEntre: number
    idType: number
    isDone: boolean
    isOpen: boolean
    date: string
    time: string
    message: string
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type taskSelect = {
    id?: boolean
    idDistr?: boolean
    idUser?: boolean
    idEntre?: boolean
    idType?: boolean
    isDone?: boolean
    isOpen?: boolean
    date?: boolean
    time?: boolean
    message?: boolean
    typetask?: boolean | typetaskArgs
    userAM?: boolean | usersArgs
    entreprise?: boolean | entrepiseArgs
  }


  export type taskInclude = {
    typetask?: boolean | typetaskArgs
    userAM?: boolean | usersArgs
    entreprise?: boolean | entrepiseArgs
  }

  export type taskGetPayload<S extends boolean | null | undefined | taskArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? task :
    S extends undefined ? never :
    S extends { include: any } & (taskArgs | taskFindManyArgs)
    ? task  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'typetask' ? typetaskGetPayload<S['include'][P]> | null :
        P extends 'userAM' ? usersGetPayload<S['include'][P]> | null :
        P extends 'entreprise' ? entrepiseGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (taskArgs | taskFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'typetask' ? typetaskGetPayload<S['select'][P]> | null :
        P extends 'userAM' ? usersGetPayload<S['select'][P]> | null :
        P extends 'entreprise' ? entrepiseGetPayload<S['select'][P]> | null :  P extends keyof task ? task[P] : never
  } 
      : task


  type taskCountArgs = 
    Omit<taskFindManyArgs, 'select' | 'include'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface taskDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Task that matches the filter.
     * @param {taskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends taskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, taskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'task'> extends True ? Prisma__taskClient<taskGetPayload<T>> : Prisma__taskClient<taskGetPayload<T> | null, null>

    /**
     * Find one Task that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {taskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends taskFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, taskFindUniqueOrThrowArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends taskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, taskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'task'> extends True ? Prisma__taskClient<taskGetPayload<T>> : Prisma__taskClient<taskGetPayload<T> | null, null>

    /**
     * Find the first Task that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends taskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, taskFindFirstOrThrowArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends taskFindManyArgs>(
      args?: SelectSubset<T, taskFindManyArgs>
    ): Prisma.PrismaPromise<Array<taskGetPayload<T>>>

    /**
     * Create a Task.
     * @param {taskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
    **/
    create<T extends taskCreateArgs>(
      args: SelectSubset<T, taskCreateArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Create many Tasks.
     *     @param {taskCreateManyArgs} args - Arguments to create many Tasks.
     *     @example
     *     // Create many Tasks
     *     const task = await prisma.task.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends taskCreateManyArgs>(
      args?: SelectSubset<T, taskCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {taskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
    **/
    delete<T extends taskDeleteArgs>(
      args: SelectSubset<T, taskDeleteArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Update one Task.
     * @param {taskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends taskUpdateArgs>(
      args: SelectSubset<T, taskUpdateArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Delete zero or more Tasks.
     * @param {taskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends taskDeleteManyArgs>(
      args?: SelectSubset<T, taskDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends taskUpdateManyArgs>(
      args: SelectSubset<T, taskUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {taskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
    **/
    upsert<T extends taskUpsertArgs>(
      args: SelectSubset<T, taskUpsertArgs>
    ): Prisma__taskClient<taskGetPayload<T>>

    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends taskCountArgs>(
      args?: Subset<T, taskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__taskClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    typetask<T extends typetaskArgs= {}>(args?: Subset<T, typetaskArgs>): Prisma__typetaskClient<typetaskGetPayload<T> | Null>;

    userAM<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    entreprise<T extends entrepiseArgs= {}>(args?: Subset<T, entrepiseArgs>): Prisma__entrepiseClient<entrepiseGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * task base type for findUnique actions
   */
  export type taskFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter, which task to fetch.
     */
    where: taskWhereUniqueInput
  }

  /**
   * task findUnique
   */
  export interface taskFindUniqueArgs extends taskFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * task findUniqueOrThrow
   */
  export type taskFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter, which task to fetch.
     */
    where: taskWhereUniqueInput
  }


  /**
   * task base type for findFirst actions
   */
  export type taskFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter, which task to fetch.
     */
    where?: taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tasks.
     */
    cursor?: taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tasks.
     */
    distinct?: Enumerable<TaskScalarFieldEnum>
  }

  /**
   * task findFirst
   */
  export interface taskFindFirstArgs extends taskFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * task findFirstOrThrow
   */
  export type taskFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter, which task to fetch.
     */
    where?: taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tasks.
     */
    cursor?: taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tasks.
     */
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * task findMany
   */
  export type taskFindManyArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter, which tasks to fetch.
     */
    where?: taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tasks to fetch.
     */
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tasks.
     */
    cursor?: taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tasks.
     */
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * task create
   */
  export type taskCreateArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * The data needed to create a task.
     */
    data: XOR<taskCreateInput, taskUncheckedCreateInput>
  }


  /**
   * task createMany
   */
  export type taskCreateManyArgs = {
    /**
     * The data used to create many tasks.
     */
    data: Enumerable<taskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * task update
   */
  export type taskUpdateArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * The data needed to update a task.
     */
    data: XOR<taskUpdateInput, taskUncheckedUpdateInput>
    /**
     * Choose, which task to update.
     */
    where: taskWhereUniqueInput
  }


  /**
   * task updateMany
   */
  export type taskUpdateManyArgs = {
    /**
     * The data used to update tasks.
     */
    data: XOR<taskUpdateManyMutationInput, taskUncheckedUpdateManyInput>
    /**
     * Filter which tasks to update
     */
    where?: taskWhereInput
  }


  /**
   * task upsert
   */
  export type taskUpsertArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * The filter to search for the task to update in case it exists.
     */
    where: taskWhereUniqueInput
    /**
     * In case the task found by the `where` argument doesn't exist, create a new task with this data.
     */
    create: XOR<taskCreateInput, taskUncheckedCreateInput>
    /**
     * In case the task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taskUpdateInput, taskUncheckedUpdateInput>
  }


  /**
   * task delete
   */
  export type taskDeleteArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    /**
     * Filter which task to delete.
     */
    where: taskWhereUniqueInput
  }


  /**
   * task deleteMany
   */
  export type taskDeleteManyArgs = {
    /**
     * Filter which tasks to delete
     */
    where?: taskWhereInput
  }


  /**
   * task without action
   */
  export type taskArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    idRole: number | null
    idCreatedpar: number | null
    idEntreprise: number | null
    isActive: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    idRole: number | null
    idCreatedpar: number | null
    idEntreprise: number | null
    isActive: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    mail: string | null
    mdp: string | null
    tel: string | null
    idRole: number | null
    idCreatedpar: number | null
    idEntreprise: number | null
    isActive: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    mail: string | null
    mdp: string | null
    tel: string | null
    idRole: number | null
    idCreatedpar: number | null
    idEntreprise: number | null
    isActive: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    mail: number
    mdp: number
    tel: number
    idRole: number
    idCreatedpar: number
    idEntreprise: number
    isActive: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    idRole?: true
    idCreatedpar?: true
    idEntreprise?: true
    isActive?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    idRole?: true
    idCreatedpar?: true
    idEntreprise?: true
    isActive?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    mdp?: true
    tel?: true
    idRole?: true
    idCreatedpar?: true
    idEntreprise?: true
    isActive?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    mdp?: true
    tel?: true
    idRole?: true
    idCreatedpar?: true
    idEntreprise?: true
    isActive?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    mdp?: true
    tel?: true
    idRole?: true
    idCreatedpar?: true
    idEntreprise?: true
    isActive?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    nom: string | null
    prenom: string | null
    mail: string | null
    mdp: string | null
    tel: string | null
    idRole: number | null
    idCreatedpar: number | null
    idEntreprise: number | null
    isActive: number | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    mail?: boolean
    mdp?: boolean
    tel?: boolean
    idRole?: boolean
    idCreatedpar?: boolean
    idEntreprise?: boolean
    isActive?: boolean
    task?: boolean | users$taskArgs
    entreprise?: boolean | entrepiseArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }


  export type usersInclude = {
    task?: boolean | users$taskArgs
    entreprise?: boolean | entrepiseArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<S extends boolean | null | undefined | usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users :
    S extends undefined ? never :
    S extends { include: any } & (usersArgs | usersFindManyArgs)
    ? users  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'task' ? Array < taskGetPayload<S['include'][P]>>  :
        P extends 'entreprise' ? entrepiseGetPayload<S['include'][P]> | null :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (usersArgs | usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'task' ? Array < taskGetPayload<S['select'][P]>>  :
        P extends 'entreprise' ? entrepiseGetPayload<S['select'][P]> | null :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
      : users


  type usersCountArgs = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): Prisma.PrismaPromise<Array<usersGetPayload<T>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    task<T extends users$taskArgs= {}>(args?: Subset<T, users$taskArgs>): Prisma.PrismaPromise<Array<taskGetPayload<T>>| Null>;

    entreprise<T extends entrepiseArgs= {}>(args?: Subset<T, entrepiseArgs>): Prisma__entrepiseClient<entrepiseGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.task
   */
  export type users$taskArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    where?: taskWhereInput
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    cursor?: taskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
  }



  /**
   * Model annonceur
   */


  export type AggregateAnnonceur = {
    _count: AnnonceurCountAggregateOutputType | null
    _avg: AnnonceurAvgAggregateOutputType | null
    _sum: AnnonceurSumAggregateOutputType | null
    _min: AnnonceurMinAggregateOutputType | null
    _max: AnnonceurMaxAggregateOutputType | null
  }

  export type AnnonceurAvgAggregateOutputType = {
    id: number | null
    idCreatedpar: number | null
  }

  export type AnnonceurSumAggregateOutputType = {
    id: number | null
    idCreatedpar: number | null
  }

  export type AnnonceurMinAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    mail: string | null
    tel: string | null
    idCreatedpar: number | null
  }

  export type AnnonceurMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    prenom: string | null
    mail: string | null
    tel: string | null
    idCreatedpar: number | null
  }

  export type AnnonceurCountAggregateOutputType = {
    id: number
    nom: number
    prenom: number
    mail: number
    tel: number
    idCreatedpar: number
    _all: number
  }


  export type AnnonceurAvgAggregateInputType = {
    id?: true
    idCreatedpar?: true
  }

  export type AnnonceurSumAggregateInputType = {
    id?: true
    idCreatedpar?: true
  }

  export type AnnonceurMinAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    tel?: true
    idCreatedpar?: true
  }

  export type AnnonceurMaxAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    tel?: true
    idCreatedpar?: true
  }

  export type AnnonceurCountAggregateInputType = {
    id?: true
    nom?: true
    prenom?: true
    mail?: true
    tel?: true
    idCreatedpar?: true
    _all?: true
  }

  export type AnnonceurAggregateArgs = {
    /**
     * Filter which annonceur to aggregate.
     */
    where?: annonceurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of annonceurs to fetch.
     */
    orderBy?: Enumerable<annonceurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: annonceurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` annonceurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` annonceurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned annonceurs
    **/
    _count?: true | AnnonceurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnonceurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnonceurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnonceurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnonceurMaxAggregateInputType
  }

  export type GetAnnonceurAggregateType<T extends AnnonceurAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnonceur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnonceur[P]>
      : GetScalarType<T[P], AggregateAnnonceur[P]>
  }




  export type AnnonceurGroupByArgs = {
    where?: annonceurWhereInput
    orderBy?: Enumerable<annonceurOrderByWithAggregationInput>
    by: AnnonceurScalarFieldEnum[]
    having?: annonceurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnonceurCountAggregateInputType | true
    _avg?: AnnonceurAvgAggregateInputType
    _sum?: AnnonceurSumAggregateInputType
    _min?: AnnonceurMinAggregateInputType
    _max?: AnnonceurMaxAggregateInputType
  }


  export type AnnonceurGroupByOutputType = {
    id: number
    nom: string | null
    prenom: string | null
    mail: string | null
    tel: string | null
    idCreatedpar: number | null
    _count: AnnonceurCountAggregateOutputType | null
    _avg: AnnonceurAvgAggregateOutputType | null
    _sum: AnnonceurSumAggregateOutputType | null
    _min: AnnonceurMinAggregateOutputType | null
    _max: AnnonceurMaxAggregateOutputType | null
  }

  type GetAnnonceurGroupByPayload<T extends AnnonceurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AnnonceurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnonceurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnonceurGroupByOutputType[P]>
            : GetScalarType<T[P], AnnonceurGroupByOutputType[P]>
        }
      >
    >


  export type annonceurSelect = {
    id?: boolean
    nom?: boolean
    prenom?: boolean
    mail?: boolean
    tel?: boolean
    idCreatedpar?: boolean
  }


  export type annonceurGetPayload<S extends boolean | null | undefined | annonceurArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? annonceur :
    S extends undefined ? never :
    S extends { include: any } & (annonceurArgs | annonceurFindManyArgs)
    ? annonceur 
    : S extends { select: any } & (annonceurArgs | annonceurFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof annonceur ? annonceur[P] : never
  } 
      : annonceur


  type annonceurCountArgs = 
    Omit<annonceurFindManyArgs, 'select' | 'include'> & {
      select?: AnnonceurCountAggregateInputType | true
    }

  export interface annonceurDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Annonceur that matches the filter.
     * @param {annonceurFindUniqueArgs} args - Arguments to find a Annonceur
     * @example
     * // Get one Annonceur
     * const annonceur = await prisma.annonceur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends annonceurFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, annonceurFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'annonceur'> extends True ? Prisma__annonceurClient<annonceurGetPayload<T>> : Prisma__annonceurClient<annonceurGetPayload<T> | null, null>

    /**
     * Find one Annonceur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {annonceurFindUniqueOrThrowArgs} args - Arguments to find a Annonceur
     * @example
     * // Get one Annonceur
     * const annonceur = await prisma.annonceur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends annonceurFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, annonceurFindUniqueOrThrowArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Find the first Annonceur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {annonceurFindFirstArgs} args - Arguments to find a Annonceur
     * @example
     * // Get one Annonceur
     * const annonceur = await prisma.annonceur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends annonceurFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, annonceurFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'annonceur'> extends True ? Prisma__annonceurClient<annonceurGetPayload<T>> : Prisma__annonceurClient<annonceurGetPayload<T> | null, null>

    /**
     * Find the first Annonceur that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {annonceurFindFirstOrThrowArgs} args - Arguments to find a Annonceur
     * @example
     * // Get one Annonceur
     * const annonceur = await prisma.annonceur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends annonceurFindFirstOrThrowArgs>(
      args?: SelectSubset<T, annonceurFindFirstOrThrowArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Find zero or more Annonceurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {annonceurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annonceurs
     * const annonceurs = await prisma.annonceur.findMany()
     * 
     * // Get first 10 Annonceurs
     * const annonceurs = await prisma.annonceur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annonceurWithIdOnly = await prisma.annonceur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends annonceurFindManyArgs>(
      args?: SelectSubset<T, annonceurFindManyArgs>
    ): Prisma.PrismaPromise<Array<annonceurGetPayload<T>>>

    /**
     * Create a Annonceur.
     * @param {annonceurCreateArgs} args - Arguments to create a Annonceur.
     * @example
     * // Create one Annonceur
     * const Annonceur = await prisma.annonceur.create({
     *   data: {
     *     // ... data to create a Annonceur
     *   }
     * })
     * 
    **/
    create<T extends annonceurCreateArgs>(
      args: SelectSubset<T, annonceurCreateArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Create many Annonceurs.
     *     @param {annonceurCreateManyArgs} args - Arguments to create many Annonceurs.
     *     @example
     *     // Create many Annonceurs
     *     const annonceur = await prisma.annonceur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends annonceurCreateManyArgs>(
      args?: SelectSubset<T, annonceurCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Annonceur.
     * @param {annonceurDeleteArgs} args - Arguments to delete one Annonceur.
     * @example
     * // Delete one Annonceur
     * const Annonceur = await prisma.annonceur.delete({
     *   where: {
     *     // ... filter to delete one Annonceur
     *   }
     * })
     * 
    **/
    delete<T extends annonceurDeleteArgs>(
      args: SelectSubset<T, annonceurDeleteArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Update one Annonceur.
     * @param {annonceurUpdateArgs} args - Arguments to update one Annonceur.
     * @example
     * // Update one Annonceur
     * const annonceur = await prisma.annonceur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends annonceurUpdateArgs>(
      args: SelectSubset<T, annonceurUpdateArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Delete zero or more Annonceurs.
     * @param {annonceurDeleteManyArgs} args - Arguments to filter Annonceurs to delete.
     * @example
     * // Delete a few Annonceurs
     * const { count } = await prisma.annonceur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends annonceurDeleteManyArgs>(
      args?: SelectSubset<T, annonceurDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annonceurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {annonceurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annonceurs
     * const annonceur = await prisma.annonceur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends annonceurUpdateManyArgs>(
      args: SelectSubset<T, annonceurUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Annonceur.
     * @param {annonceurUpsertArgs} args - Arguments to update or create a Annonceur.
     * @example
     * // Update or create a Annonceur
     * const annonceur = await prisma.annonceur.upsert({
     *   create: {
     *     // ... data to create a Annonceur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annonceur we want to update
     *   }
     * })
    **/
    upsert<T extends annonceurUpsertArgs>(
      args: SelectSubset<T, annonceurUpsertArgs>
    ): Prisma__annonceurClient<annonceurGetPayload<T>>

    /**
     * Count the number of Annonceurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {annonceurCountArgs} args - Arguments to filter Annonceurs to count.
     * @example
     * // Count the number of Annonceurs
     * const count = await prisma.annonceur.count({
     *   where: {
     *     // ... the filter for the Annonceurs we want to count
     *   }
     * })
    **/
    count<T extends annonceurCountArgs>(
      args?: Subset<T, annonceurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnonceurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annonceur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnonceurAggregateArgs>(args: Subset<T, AnnonceurAggregateArgs>): Prisma.PrismaPromise<GetAnnonceurAggregateType<T>>

    /**
     * Group by Annonceur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnonceurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnonceurGroupByArgs['orderBy'] }
        : { orderBy?: AnnonceurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnonceurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnonceurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for annonceur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__annonceurClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * annonceur base type for findUnique actions
   */
  export type annonceurFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter, which annonceur to fetch.
     */
    where: annonceurWhereUniqueInput
  }

  /**
   * annonceur findUnique
   */
  export interface annonceurFindUniqueArgs extends annonceurFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * annonceur findUniqueOrThrow
   */
  export type annonceurFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter, which annonceur to fetch.
     */
    where: annonceurWhereUniqueInput
  }


  /**
   * annonceur base type for findFirst actions
   */
  export type annonceurFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter, which annonceur to fetch.
     */
    where?: annonceurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of annonceurs to fetch.
     */
    orderBy?: Enumerable<annonceurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for annonceurs.
     */
    cursor?: annonceurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` annonceurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` annonceurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of annonceurs.
     */
    distinct?: Enumerable<AnnonceurScalarFieldEnum>
  }

  /**
   * annonceur findFirst
   */
  export interface annonceurFindFirstArgs extends annonceurFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * annonceur findFirstOrThrow
   */
  export type annonceurFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter, which annonceur to fetch.
     */
    where?: annonceurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of annonceurs to fetch.
     */
    orderBy?: Enumerable<annonceurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for annonceurs.
     */
    cursor?: annonceurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` annonceurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` annonceurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of annonceurs.
     */
    distinct?: Enumerable<AnnonceurScalarFieldEnum>
  }


  /**
   * annonceur findMany
   */
  export type annonceurFindManyArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter, which annonceurs to fetch.
     */
    where?: annonceurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of annonceurs to fetch.
     */
    orderBy?: Enumerable<annonceurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing annonceurs.
     */
    cursor?: annonceurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` annonceurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` annonceurs.
     */
    skip?: number
    distinct?: Enumerable<AnnonceurScalarFieldEnum>
  }


  /**
   * annonceur create
   */
  export type annonceurCreateArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * The data needed to create a annonceur.
     */
    data: XOR<annonceurCreateInput, annonceurUncheckedCreateInput>
  }


  /**
   * annonceur createMany
   */
  export type annonceurCreateManyArgs = {
    /**
     * The data used to create many annonceurs.
     */
    data: Enumerable<annonceurCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * annonceur update
   */
  export type annonceurUpdateArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * The data needed to update a annonceur.
     */
    data: XOR<annonceurUpdateInput, annonceurUncheckedUpdateInput>
    /**
     * Choose, which annonceur to update.
     */
    where: annonceurWhereUniqueInput
  }


  /**
   * annonceur updateMany
   */
  export type annonceurUpdateManyArgs = {
    /**
     * The data used to update annonceurs.
     */
    data: XOR<annonceurUpdateManyMutationInput, annonceurUncheckedUpdateManyInput>
    /**
     * Filter which annonceurs to update
     */
    where?: annonceurWhereInput
  }


  /**
   * annonceur upsert
   */
  export type annonceurUpsertArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * The filter to search for the annonceur to update in case it exists.
     */
    where: annonceurWhereUniqueInput
    /**
     * In case the annonceur found by the `where` argument doesn't exist, create a new annonceur with this data.
     */
    create: XOR<annonceurCreateInput, annonceurUncheckedCreateInput>
    /**
     * In case the annonceur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<annonceurUpdateInput, annonceurUncheckedUpdateInput>
  }


  /**
   * annonceur delete
   */
  export type annonceurDeleteArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
    /**
     * Filter which annonceur to delete.
     */
    where: annonceurWhereUniqueInput
  }


  /**
   * annonceur deleteMany
   */
  export type annonceurDeleteManyArgs = {
    /**
     * Filter which annonceurs to delete
     */
    where?: annonceurWhereInput
  }


  /**
   * annonceur without action
   */
  export type annonceurArgs = {
    /**
     * Select specific fields to fetch from the annonceur
     */
    select?: annonceurSelect | null
  }



  /**
   * Model ingredient
   */


  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientAvgAggregateOutputType = {
    id: number | null
    type: number | null
    prixUnit: number | null
  }

  export type IngredientSumAggregateOutputType = {
    id: number | null
    type: number | null
    prixUnit: number | null
  }

  export type IngredientMinAggregateOutputType = {
    id: number | null
    type: number | null
    description: string | null
    prixUnit: number | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: number | null
    type: number | null
    description: string | null
    prixUnit: number | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    type: number
    description: number
    prixUnit: number
    _all: number
  }


  export type IngredientAvgAggregateInputType = {
    id?: true
    type?: true
    prixUnit?: true
  }

  export type IngredientSumAggregateInputType = {
    id?: true
    type?: true
    prixUnit?: true
  }

  export type IngredientMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    prixUnit?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    prixUnit?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    prixUnit?: true
    _all?: true
  }

  export type IngredientAggregateArgs = {
    /**
     * Filter which ingredient to aggregate.
     */
    where?: ingredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredients to fetch.
     */
    orderBy?: Enumerable<ingredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ingredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs = {
    where?: ingredientWhereInput
    orderBy?: Enumerable<ingredientOrderByWithAggregationInput>
    by: IngredientScalarFieldEnum[]
    having?: ingredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _avg?: IngredientAvgAggregateInputType
    _sum?: IngredientSumAggregateInputType
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }


  export type IngredientGroupByOutputType = {
    id: number
    type: number | null
    description: string | null
    prixUnit: number | null
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type ingredientSelect = {
    id?: boolean
    type?: boolean
    description?: boolean
    prixUnit?: boolean
  }


  export type ingredientGetPayload<S extends boolean | null | undefined | ingredientArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ingredient :
    S extends undefined ? never :
    S extends { include: any } & (ingredientArgs | ingredientFindManyArgs)
    ? ingredient 
    : S extends { select: any } & (ingredientArgs | ingredientFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ingredient ? ingredient[P] : never
  } 
      : ingredient


  type ingredientCountArgs = 
    Omit<ingredientFindManyArgs, 'select' | 'include'> & {
      select?: IngredientCountAggregateInputType | true
    }

  export interface ingredientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {ingredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ingredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ingredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ingredient'> extends True ? Prisma__ingredientClient<ingredientGetPayload<T>> : Prisma__ingredientClient<ingredientGetPayload<T> | null, null>

    /**
     * Find one Ingredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ingredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ingredientFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ingredientFindUniqueOrThrowArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ingredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ingredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ingredient'> extends True ? Prisma__ingredientClient<ingredientGetPayload<T>> : Prisma__ingredientClient<ingredientGetPayload<T> | null, null>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ingredientFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ingredientFindFirstOrThrowArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ingredientFindManyArgs>(
      args?: SelectSubset<T, ingredientFindManyArgs>
    ): Prisma.PrismaPromise<Array<ingredientGetPayload<T>>>

    /**
     * Create a Ingredient.
     * @param {ingredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends ingredientCreateArgs>(
      args: SelectSubset<T, ingredientCreateArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Create many Ingredients.
     *     @param {ingredientCreateManyArgs} args - Arguments to create many Ingredients.
     *     @example
     *     // Create many Ingredients
     *     const ingredient = await prisma.ingredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ingredientCreateManyArgs>(
      args?: SelectSubset<T, ingredientCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingredient.
     * @param {ingredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends ingredientDeleteArgs>(
      args: SelectSubset<T, ingredientDeleteArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Update one Ingredient.
     * @param {ingredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ingredientUpdateArgs>(
      args: SelectSubset<T, ingredientUpdateArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Delete zero or more Ingredients.
     * @param {ingredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ingredientDeleteManyArgs>(
      args?: SelectSubset<T, ingredientDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ingredientUpdateManyArgs>(
      args: SelectSubset<T, ingredientUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {ingredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends ingredientUpsertArgs>(
      args: SelectSubset<T, ingredientUpsertArgs>
    ): Prisma__ingredientClient<ingredientGetPayload<T>>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends ingredientCountArgs>(
      args?: Subset<T, ingredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ingredientClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ingredient base type for findUnique actions
   */
  export type ingredientFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter, which ingredient to fetch.
     */
    where: ingredientWhereUniqueInput
  }

  /**
   * ingredient findUnique
   */
  export interface ingredientFindUniqueArgs extends ingredientFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingredient findUniqueOrThrow
   */
  export type ingredientFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter, which ingredient to fetch.
     */
    where: ingredientWhereUniqueInput
  }


  /**
   * ingredient base type for findFirst actions
   */
  export type ingredientFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter, which ingredient to fetch.
     */
    where?: ingredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredients to fetch.
     */
    orderBy?: Enumerable<ingredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingredients.
     */
    cursor?: ingredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingredients.
     */
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }

  /**
   * ingredient findFirst
   */
  export interface ingredientFindFirstArgs extends ingredientFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingredient findFirstOrThrow
   */
  export type ingredientFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter, which ingredient to fetch.
     */
    where?: ingredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredients to fetch.
     */
    orderBy?: Enumerable<ingredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingredients.
     */
    cursor?: ingredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingredients.
     */
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }


  /**
   * ingredient findMany
   */
  export type ingredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter, which ingredients to fetch.
     */
    where?: ingredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingredients to fetch.
     */
    orderBy?: Enumerable<ingredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ingredients.
     */
    cursor?: ingredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingredients.
     */
    skip?: number
    distinct?: Enumerable<IngredientScalarFieldEnum>
  }


  /**
   * ingredient create
   */
  export type ingredientCreateArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * The data needed to create a ingredient.
     */
    data: XOR<ingredientCreateInput, ingredientUncheckedCreateInput>
  }


  /**
   * ingredient createMany
   */
  export type ingredientCreateManyArgs = {
    /**
     * The data used to create many ingredients.
     */
    data: Enumerable<ingredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ingredient update
   */
  export type ingredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * The data needed to update a ingredient.
     */
    data: XOR<ingredientUpdateInput, ingredientUncheckedUpdateInput>
    /**
     * Choose, which ingredient to update.
     */
    where: ingredientWhereUniqueInput
  }


  /**
   * ingredient updateMany
   */
  export type ingredientUpdateManyArgs = {
    /**
     * The data used to update ingredients.
     */
    data: XOR<ingredientUpdateManyMutationInput, ingredientUncheckedUpdateManyInput>
    /**
     * Filter which ingredients to update
     */
    where?: ingredientWhereInput
  }


  /**
   * ingredient upsert
   */
  export type ingredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * The filter to search for the ingredient to update in case it exists.
     */
    where: ingredientWhereUniqueInput
    /**
     * In case the ingredient found by the `where` argument doesn't exist, create a new ingredient with this data.
     */
    create: XOR<ingredientCreateInput, ingredientUncheckedCreateInput>
    /**
     * In case the ingredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ingredientUpdateInput, ingredientUncheckedUpdateInput>
  }


  /**
   * ingredient delete
   */
  export type ingredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
    /**
     * Filter which ingredient to delete.
     */
    where: ingredientWhereUniqueInput
  }


  /**
   * ingredient deleteMany
   */
  export type ingredientDeleteManyArgs = {
    /**
     * Filter which ingredients to delete
     */
    where?: ingredientWhereInput
  }


  /**
   * ingredient without action
   */
  export type ingredientArgs = {
    /**
     * Select specific fields to fetch from the ingredient
     */
    select?: ingredientSelect | null
  }



  /**
   * Model recetteingr
   */


  export type AggregateRecetteingr = {
    _count: RecetteingrCountAggregateOutputType | null
    _avg: RecetteingrAvgAggregateOutputType | null
    _sum: RecetteingrSumAggregateOutputType | null
    _min: RecetteingrMinAggregateOutputType | null
    _max: RecetteingrMaxAggregateOutputType | null
  }

  export type RecetteingrAvgAggregateOutputType = {
    idRecette: number | null
    idIngredient: number | null
  }

  export type RecetteingrSumAggregateOutputType = {
    idRecette: number | null
    idIngredient: number | null
  }

  export type RecetteingrMinAggregateOutputType = {
    idRecette: number | null
    idIngredient: number | null
    quantity: string | null
  }

  export type RecetteingrMaxAggregateOutputType = {
    idRecette: number | null
    idIngredient: number | null
    quantity: string | null
  }

  export type RecetteingrCountAggregateOutputType = {
    idRecette: number
    idIngredient: number
    quantity: number
    _all: number
  }


  export type RecetteingrAvgAggregateInputType = {
    idRecette?: true
    idIngredient?: true
  }

  export type RecetteingrSumAggregateInputType = {
    idRecette?: true
    idIngredient?: true
  }

  export type RecetteingrMinAggregateInputType = {
    idRecette?: true
    idIngredient?: true
    quantity?: true
  }

  export type RecetteingrMaxAggregateInputType = {
    idRecette?: true
    idIngredient?: true
    quantity?: true
  }

  export type RecetteingrCountAggregateInputType = {
    idRecette?: true
    idIngredient?: true
    quantity?: true
    _all?: true
  }

  export type RecetteingrAggregateArgs = {
    /**
     * Filter which recetteingr to aggregate.
     */
    where?: recetteingrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetteingrs to fetch.
     */
    orderBy?: Enumerable<recetteingrOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recetteingrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetteingrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetteingrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recetteingrs
    **/
    _count?: true | RecetteingrCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecetteingrAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecetteingrSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecetteingrMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecetteingrMaxAggregateInputType
  }

  export type GetRecetteingrAggregateType<T extends RecetteingrAggregateArgs> = {
        [P in keyof T & keyof AggregateRecetteingr]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecetteingr[P]>
      : GetScalarType<T[P], AggregateRecetteingr[P]>
  }




  export type RecetteingrGroupByArgs = {
    where?: recetteingrWhereInput
    orderBy?: Enumerable<recetteingrOrderByWithAggregationInput>
    by: RecetteingrScalarFieldEnum[]
    having?: recetteingrScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecetteingrCountAggregateInputType | true
    _avg?: RecetteingrAvgAggregateInputType
    _sum?: RecetteingrSumAggregateInputType
    _min?: RecetteingrMinAggregateInputType
    _max?: RecetteingrMaxAggregateInputType
  }


  export type RecetteingrGroupByOutputType = {
    idRecette: number
    idIngredient: number
    quantity: string | null
    _count: RecetteingrCountAggregateOutputType | null
    _avg: RecetteingrAvgAggregateOutputType | null
    _sum: RecetteingrSumAggregateOutputType | null
    _min: RecetteingrMinAggregateOutputType | null
    _max: RecetteingrMaxAggregateOutputType | null
  }

  type GetRecetteingrGroupByPayload<T extends RecetteingrGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RecetteingrGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecetteingrGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecetteingrGroupByOutputType[P]>
            : GetScalarType<T[P], RecetteingrGroupByOutputType[P]>
        }
      >
    >


  export type recetteingrSelect = {
    idRecette?: boolean
    idIngredient?: boolean
    quantity?: boolean
    recette?: boolean | recetteArgs
  }


  export type recetteingrInclude = {
    recette?: boolean | recetteArgs
  }

  export type recetteingrGetPayload<S extends boolean | null | undefined | recetteingrArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? recetteingr :
    S extends undefined ? never :
    S extends { include: any } & (recetteingrArgs | recetteingrFindManyArgs)
    ? recetteingr  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recette' ? recetteGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (recetteingrArgs | recetteingrFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recette' ? recetteGetPayload<S['select'][P]> :  P extends keyof recetteingr ? recetteingr[P] : never
  } 
      : recetteingr


  type recetteingrCountArgs = 
    Omit<recetteingrFindManyArgs, 'select' | 'include'> & {
      select?: RecetteingrCountAggregateInputType | true
    }

  export interface recetteingrDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Recetteingr that matches the filter.
     * @param {recetteingrFindUniqueArgs} args - Arguments to find a Recetteingr
     * @example
     * // Get one Recetteingr
     * const recetteingr = await prisma.recetteingr.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recetteingrFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, recetteingrFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'recetteingr'> extends True ? Prisma__recetteingrClient<recetteingrGetPayload<T>> : Prisma__recetteingrClient<recetteingrGetPayload<T> | null, null>

    /**
     * Find one Recetteingr that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {recetteingrFindUniqueOrThrowArgs} args - Arguments to find a Recetteingr
     * @example
     * // Get one Recetteingr
     * const recetteingr = await prisma.recetteingr.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends recetteingrFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, recetteingrFindUniqueOrThrowArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Find the first Recetteingr that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteingrFindFirstArgs} args - Arguments to find a Recetteingr
     * @example
     * // Get one Recetteingr
     * const recetteingr = await prisma.recetteingr.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recetteingrFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, recetteingrFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'recetteingr'> extends True ? Prisma__recetteingrClient<recetteingrGetPayload<T>> : Prisma__recetteingrClient<recetteingrGetPayload<T> | null, null>

    /**
     * Find the first Recetteingr that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteingrFindFirstOrThrowArgs} args - Arguments to find a Recetteingr
     * @example
     * // Get one Recetteingr
     * const recetteingr = await prisma.recetteingr.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends recetteingrFindFirstOrThrowArgs>(
      args?: SelectSubset<T, recetteingrFindFirstOrThrowArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Find zero or more Recetteingrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteingrFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recetteingrs
     * const recetteingrs = await prisma.recetteingr.findMany()
     * 
     * // Get first 10 Recetteingrs
     * const recetteingrs = await prisma.recetteingr.findMany({ take: 10 })
     * 
     * // Only select the `idRecette`
     * const recetteingrWithIdRecetteOnly = await prisma.recetteingr.findMany({ select: { idRecette: true } })
     * 
    **/
    findMany<T extends recetteingrFindManyArgs>(
      args?: SelectSubset<T, recetteingrFindManyArgs>
    ): Prisma.PrismaPromise<Array<recetteingrGetPayload<T>>>

    /**
     * Create a Recetteingr.
     * @param {recetteingrCreateArgs} args - Arguments to create a Recetteingr.
     * @example
     * // Create one Recetteingr
     * const Recetteingr = await prisma.recetteingr.create({
     *   data: {
     *     // ... data to create a Recetteingr
     *   }
     * })
     * 
    **/
    create<T extends recetteingrCreateArgs>(
      args: SelectSubset<T, recetteingrCreateArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Create many Recetteingrs.
     *     @param {recetteingrCreateManyArgs} args - Arguments to create many Recetteingrs.
     *     @example
     *     // Create many Recetteingrs
     *     const recetteingr = await prisma.recetteingr.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recetteingrCreateManyArgs>(
      args?: SelectSubset<T, recetteingrCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recetteingr.
     * @param {recetteingrDeleteArgs} args - Arguments to delete one Recetteingr.
     * @example
     * // Delete one Recetteingr
     * const Recetteingr = await prisma.recetteingr.delete({
     *   where: {
     *     // ... filter to delete one Recetteingr
     *   }
     * })
     * 
    **/
    delete<T extends recetteingrDeleteArgs>(
      args: SelectSubset<T, recetteingrDeleteArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Update one Recetteingr.
     * @param {recetteingrUpdateArgs} args - Arguments to update one Recetteingr.
     * @example
     * // Update one Recetteingr
     * const recetteingr = await prisma.recetteingr.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recetteingrUpdateArgs>(
      args: SelectSubset<T, recetteingrUpdateArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Delete zero or more Recetteingrs.
     * @param {recetteingrDeleteManyArgs} args - Arguments to filter Recetteingrs to delete.
     * @example
     * // Delete a few Recetteingrs
     * const { count } = await prisma.recetteingr.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recetteingrDeleteManyArgs>(
      args?: SelectSubset<T, recetteingrDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recetteingrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteingrUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recetteingrs
     * const recetteingr = await prisma.recetteingr.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recetteingrUpdateManyArgs>(
      args: SelectSubset<T, recetteingrUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recetteingr.
     * @param {recetteingrUpsertArgs} args - Arguments to update or create a Recetteingr.
     * @example
     * // Update or create a Recetteingr
     * const recetteingr = await prisma.recetteingr.upsert({
     *   create: {
     *     // ... data to create a Recetteingr
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recetteingr we want to update
     *   }
     * })
    **/
    upsert<T extends recetteingrUpsertArgs>(
      args: SelectSubset<T, recetteingrUpsertArgs>
    ): Prisma__recetteingrClient<recetteingrGetPayload<T>>

    /**
     * Count the number of Recetteingrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recetteingrCountArgs} args - Arguments to filter Recetteingrs to count.
     * @example
     * // Count the number of Recetteingrs
     * const count = await prisma.recetteingr.count({
     *   where: {
     *     // ... the filter for the Recetteingrs we want to count
     *   }
     * })
    **/
    count<T extends recetteingrCountArgs>(
      args?: Subset<T, recetteingrCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecetteingrCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recetteingr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteingrAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecetteingrAggregateArgs>(args: Subset<T, RecetteingrAggregateArgs>): Prisma.PrismaPromise<GetRecetteingrAggregateType<T>>

    /**
     * Group by Recetteingr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecetteingrGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecetteingrGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecetteingrGroupByArgs['orderBy'] }
        : { orderBy?: RecetteingrGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecetteingrGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecetteingrGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for recetteingr.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__recetteingrClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    recette<T extends recetteArgs= {}>(args?: Subset<T, recetteArgs>): Prisma__recetteClient<recetteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * recetteingr base type for findUnique actions
   */
  export type recetteingrFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter, which recetteingr to fetch.
     */
    where: recetteingrWhereUniqueInput
  }

  /**
   * recetteingr findUnique
   */
  export interface recetteingrFindUniqueArgs extends recetteingrFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recetteingr findUniqueOrThrow
   */
  export type recetteingrFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter, which recetteingr to fetch.
     */
    where: recetteingrWhereUniqueInput
  }


  /**
   * recetteingr base type for findFirst actions
   */
  export type recetteingrFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter, which recetteingr to fetch.
     */
    where?: recetteingrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetteingrs to fetch.
     */
    orderBy?: Enumerable<recetteingrOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetteingrs.
     */
    cursor?: recetteingrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetteingrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetteingrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetteingrs.
     */
    distinct?: Enumerable<RecetteingrScalarFieldEnum>
  }

  /**
   * recetteingr findFirst
   */
  export interface recetteingrFindFirstArgs extends recetteingrFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recetteingr findFirstOrThrow
   */
  export type recetteingrFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter, which recetteingr to fetch.
     */
    where?: recetteingrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetteingrs to fetch.
     */
    orderBy?: Enumerable<recetteingrOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recetteingrs.
     */
    cursor?: recetteingrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetteingrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetteingrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recetteingrs.
     */
    distinct?: Enumerable<RecetteingrScalarFieldEnum>
  }


  /**
   * recetteingr findMany
   */
  export type recetteingrFindManyArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter, which recetteingrs to fetch.
     */
    where?: recetteingrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recetteingrs to fetch.
     */
    orderBy?: Enumerable<recetteingrOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recetteingrs.
     */
    cursor?: recetteingrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recetteingrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recetteingrs.
     */
    skip?: number
    distinct?: Enumerable<RecetteingrScalarFieldEnum>
  }


  /**
   * recetteingr create
   */
  export type recetteingrCreateArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * The data needed to create a recetteingr.
     */
    data: XOR<recetteingrCreateInput, recetteingrUncheckedCreateInput>
  }


  /**
   * recetteingr createMany
   */
  export type recetteingrCreateManyArgs = {
    /**
     * The data used to create many recetteingrs.
     */
    data: Enumerable<recetteingrCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * recetteingr update
   */
  export type recetteingrUpdateArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * The data needed to update a recetteingr.
     */
    data: XOR<recetteingrUpdateInput, recetteingrUncheckedUpdateInput>
    /**
     * Choose, which recetteingr to update.
     */
    where: recetteingrWhereUniqueInput
  }


  /**
   * recetteingr updateMany
   */
  export type recetteingrUpdateManyArgs = {
    /**
     * The data used to update recetteingrs.
     */
    data: XOR<recetteingrUpdateManyMutationInput, recetteingrUncheckedUpdateManyInput>
    /**
     * Filter which recetteingrs to update
     */
    where?: recetteingrWhereInput
  }


  /**
   * recetteingr upsert
   */
  export type recetteingrUpsertArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * The filter to search for the recetteingr to update in case it exists.
     */
    where: recetteingrWhereUniqueInput
    /**
     * In case the recetteingr found by the `where` argument doesn't exist, create a new recetteingr with this data.
     */
    create: XOR<recetteingrCreateInput, recetteingrUncheckedCreateInput>
    /**
     * In case the recetteingr was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recetteingrUpdateInput, recetteingrUncheckedUpdateInput>
  }


  /**
   * recetteingr delete
   */
  export type recetteingrDeleteArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
    /**
     * Filter which recetteingr to delete.
     */
    where: recetteingrWhereUniqueInput
  }


  /**
   * recetteingr deleteMany
   */
  export type recetteingrDeleteManyArgs = {
    /**
     * Filter which recetteingrs to delete
     */
    where?: recetteingrWhereInput
  }


  /**
   * recetteingr without action
   */
  export type recetteingrArgs = {
    /**
     * Select specific fields to fetch from the recetteingr
     */
    select?: recetteingrSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recetteingrInclude | null
  }



  /**
   * Model role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: roleWhereInput
    orderBy?: Enumerable<roleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect = {
    id?: boolean
    description?: boolean
  }


  export type roleGetPayload<S extends boolean | null | undefined | roleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? role :
    S extends undefined ? never :
    S extends { include: any } & (roleArgs | roleFindManyArgs)
    ? role 
    : S extends { select: any } & (roleArgs | roleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof role ? role[P] : never
  } 
      : role


  type roleCountArgs = 
    Omit<roleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, roleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'role'> extends True ? Prisma__roleClient<roleGetPayload<T>> : Prisma__roleClient<roleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, roleFindUniqueOrThrowArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, roleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'role'> extends True ? Prisma__roleClient<roleGetPayload<T>> : Prisma__roleClient<roleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, roleFindFirstOrThrowArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends roleFindManyArgs>(
      args?: SelectSubset<T, roleFindManyArgs>
    ): Prisma.PrismaPromise<Array<roleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends roleCreateArgs>(
      args: SelectSubset<T, roleCreateArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {roleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends roleCreateManyArgs>(
      args?: SelectSubset<T, roleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends roleDeleteArgs>(
      args: SelectSubset<T, roleDeleteArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roleUpdateArgs>(
      args: SelectSubset<T, roleUpdateArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roleDeleteManyArgs>(
      args?: SelectSubset<T, roleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roleUpdateManyArgs>(
      args: SelectSubset<T, roleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends roleUpsertArgs>(
      args: SelectSubset<T, roleUpsertArgs>
    ): Prisma__roleClient<roleGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__roleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * role base type for findUnique actions
   */
  export type roleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUnique
   */
  export interface roleFindUniqueArgs extends roleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role base type for findFirst actions
   */
  export type roleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * role findFirst
   */
  export interface roleFindFirstArgs extends roleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * role findMany
   */
  export type roleFindManyArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: Enumerable<roleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * role create
   */
  export type roleCreateArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }


  /**
   * role createMany
   */
  export type roleCreateManyArgs = {
    /**
     * The data used to create many roles.
     */
    data: Enumerable<roleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * role update
   */
  export type roleUpdateArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role updateMany
   */
  export type roleUpdateManyArgs = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
  }


  /**
   * role upsert
   */
  export type roleUpsertArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }


  /**
   * role delete
   */
  export type roleDeleteArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }


  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
  }


  /**
   * role without action
   */
  export type roleArgs = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect | null
  }



  /**
   * Model typetask
   */


  export type AggregateTypetask = {
    _count: TypetaskCountAggregateOutputType | null
    _avg: TypetaskAvgAggregateOutputType | null
    _sum: TypetaskSumAggregateOutputType | null
    _min: TypetaskMinAggregateOutputType | null
    _max: TypetaskMaxAggregateOutputType | null
  }

  export type TypetaskAvgAggregateOutputType = {
    id: number | null
  }

  export type TypetaskSumAggregateOutputType = {
    id: number | null
  }

  export type TypetaskMinAggregateOutputType = {
    id: number | null
    identifiant: string | null
    description: string | null
  }

  export type TypetaskMaxAggregateOutputType = {
    id: number | null
    identifiant: string | null
    description: string | null
  }

  export type TypetaskCountAggregateOutputType = {
    id: number
    identifiant: number
    description: number
    _all: number
  }


  export type TypetaskAvgAggregateInputType = {
    id?: true
  }

  export type TypetaskSumAggregateInputType = {
    id?: true
  }

  export type TypetaskMinAggregateInputType = {
    id?: true
    identifiant?: true
    description?: true
  }

  export type TypetaskMaxAggregateInputType = {
    id?: true
    identifiant?: true
    description?: true
  }

  export type TypetaskCountAggregateInputType = {
    id?: true
    identifiant?: true
    description?: true
    _all?: true
  }

  export type TypetaskAggregateArgs = {
    /**
     * Filter which typetask to aggregate.
     */
    where?: typetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typetasks to fetch.
     */
    orderBy?: Enumerable<typetaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: typetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned typetasks
    **/
    _count?: true | TypetaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypetaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypetaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypetaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypetaskMaxAggregateInputType
  }

  export type GetTypetaskAggregateType<T extends TypetaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTypetask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypetask[P]>
      : GetScalarType<T[P], AggregateTypetask[P]>
  }




  export type TypetaskGroupByArgs = {
    where?: typetaskWhereInput
    orderBy?: Enumerable<typetaskOrderByWithAggregationInput>
    by: TypetaskScalarFieldEnum[]
    having?: typetaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypetaskCountAggregateInputType | true
    _avg?: TypetaskAvgAggregateInputType
    _sum?: TypetaskSumAggregateInputType
    _min?: TypetaskMinAggregateInputType
    _max?: TypetaskMaxAggregateInputType
  }


  export type TypetaskGroupByOutputType = {
    id: number
    identifiant: string
    description: string | null
    _count: TypetaskCountAggregateOutputType | null
    _avg: TypetaskAvgAggregateOutputType | null
    _sum: TypetaskSumAggregateOutputType | null
    _min: TypetaskMinAggregateOutputType | null
    _max: TypetaskMaxAggregateOutputType | null
  }

  type GetTypetaskGroupByPayload<T extends TypetaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypetaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypetaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypetaskGroupByOutputType[P]>
            : GetScalarType<T[P], TypetaskGroupByOutputType[P]>
        }
      >
    >


  export type typetaskSelect = {
    id?: boolean
    identifiant?: boolean
    description?: boolean
    task?: boolean | typetask$taskArgs
    _count?: boolean | TypetaskCountOutputTypeArgs
  }


  export type typetaskInclude = {
    task?: boolean | typetask$taskArgs
    _count?: boolean | TypetaskCountOutputTypeArgs
  }

  export type typetaskGetPayload<S extends boolean | null | undefined | typetaskArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? typetask :
    S extends undefined ? never :
    S extends { include: any } & (typetaskArgs | typetaskFindManyArgs)
    ? typetask  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'task' ? Array < taskGetPayload<S['include'][P]>>  :
        P extends '_count' ? TypetaskCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (typetaskArgs | typetaskFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'task' ? Array < taskGetPayload<S['select'][P]>>  :
        P extends '_count' ? TypetaskCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof typetask ? typetask[P] : never
  } 
      : typetask


  type typetaskCountArgs = 
    Omit<typetaskFindManyArgs, 'select' | 'include'> & {
      select?: TypetaskCountAggregateInputType | true
    }

  export interface typetaskDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Typetask that matches the filter.
     * @param {typetaskFindUniqueArgs} args - Arguments to find a Typetask
     * @example
     * // Get one Typetask
     * const typetask = await prisma.typetask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends typetaskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, typetaskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'typetask'> extends True ? Prisma__typetaskClient<typetaskGetPayload<T>> : Prisma__typetaskClient<typetaskGetPayload<T> | null, null>

    /**
     * Find one Typetask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {typetaskFindUniqueOrThrowArgs} args - Arguments to find a Typetask
     * @example
     * // Get one Typetask
     * const typetask = await prisma.typetask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends typetaskFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, typetaskFindUniqueOrThrowArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Find the first Typetask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typetaskFindFirstArgs} args - Arguments to find a Typetask
     * @example
     * // Get one Typetask
     * const typetask = await prisma.typetask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends typetaskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, typetaskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'typetask'> extends True ? Prisma__typetaskClient<typetaskGetPayload<T>> : Prisma__typetaskClient<typetaskGetPayload<T> | null, null>

    /**
     * Find the first Typetask that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typetaskFindFirstOrThrowArgs} args - Arguments to find a Typetask
     * @example
     * // Get one Typetask
     * const typetask = await prisma.typetask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends typetaskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, typetaskFindFirstOrThrowArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Find zero or more Typetasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typetaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Typetasks
     * const typetasks = await prisma.typetask.findMany()
     * 
     * // Get first 10 Typetasks
     * const typetasks = await prisma.typetask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typetaskWithIdOnly = await prisma.typetask.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends typetaskFindManyArgs>(
      args?: SelectSubset<T, typetaskFindManyArgs>
    ): Prisma.PrismaPromise<Array<typetaskGetPayload<T>>>

    /**
     * Create a Typetask.
     * @param {typetaskCreateArgs} args - Arguments to create a Typetask.
     * @example
     * // Create one Typetask
     * const Typetask = await prisma.typetask.create({
     *   data: {
     *     // ... data to create a Typetask
     *   }
     * })
     * 
    **/
    create<T extends typetaskCreateArgs>(
      args: SelectSubset<T, typetaskCreateArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Create many Typetasks.
     *     @param {typetaskCreateManyArgs} args - Arguments to create many Typetasks.
     *     @example
     *     // Create many Typetasks
     *     const typetask = await prisma.typetask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends typetaskCreateManyArgs>(
      args?: SelectSubset<T, typetaskCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Typetask.
     * @param {typetaskDeleteArgs} args - Arguments to delete one Typetask.
     * @example
     * // Delete one Typetask
     * const Typetask = await prisma.typetask.delete({
     *   where: {
     *     // ... filter to delete one Typetask
     *   }
     * })
     * 
    **/
    delete<T extends typetaskDeleteArgs>(
      args: SelectSubset<T, typetaskDeleteArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Update one Typetask.
     * @param {typetaskUpdateArgs} args - Arguments to update one Typetask.
     * @example
     * // Update one Typetask
     * const typetask = await prisma.typetask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends typetaskUpdateArgs>(
      args: SelectSubset<T, typetaskUpdateArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Delete zero or more Typetasks.
     * @param {typetaskDeleteManyArgs} args - Arguments to filter Typetasks to delete.
     * @example
     * // Delete a few Typetasks
     * const { count } = await prisma.typetask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends typetaskDeleteManyArgs>(
      args?: SelectSubset<T, typetaskDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Typetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typetaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Typetasks
     * const typetask = await prisma.typetask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends typetaskUpdateManyArgs>(
      args: SelectSubset<T, typetaskUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Typetask.
     * @param {typetaskUpsertArgs} args - Arguments to update or create a Typetask.
     * @example
     * // Update or create a Typetask
     * const typetask = await prisma.typetask.upsert({
     *   create: {
     *     // ... data to create a Typetask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Typetask we want to update
     *   }
     * })
    **/
    upsert<T extends typetaskUpsertArgs>(
      args: SelectSubset<T, typetaskUpsertArgs>
    ): Prisma__typetaskClient<typetaskGetPayload<T>>

    /**
     * Count the number of Typetasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typetaskCountArgs} args - Arguments to filter Typetasks to count.
     * @example
     * // Count the number of Typetasks
     * const count = await prisma.typetask.count({
     *   where: {
     *     // ... the filter for the Typetasks we want to count
     *   }
     * })
    **/
    count<T extends typetaskCountArgs>(
      args?: Subset<T, typetaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypetaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Typetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypetaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypetaskAggregateArgs>(args: Subset<T, TypetaskAggregateArgs>): Prisma.PrismaPromise<GetTypetaskAggregateType<T>>

    /**
     * Group by Typetask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypetaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypetaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypetaskGroupByArgs['orderBy'] }
        : { orderBy?: TypetaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypetaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypetaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for typetask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__typetaskClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    task<T extends typetask$taskArgs= {}>(args?: Subset<T, typetask$taskArgs>): Prisma.PrismaPromise<Array<taskGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * typetask base type for findUnique actions
   */
  export type typetaskFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter, which typetask to fetch.
     */
    where: typetaskWhereUniqueInput
  }

  /**
   * typetask findUnique
   */
  export interface typetaskFindUniqueArgs extends typetaskFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * typetask findUniqueOrThrow
   */
  export type typetaskFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter, which typetask to fetch.
     */
    where: typetaskWhereUniqueInput
  }


  /**
   * typetask base type for findFirst actions
   */
  export type typetaskFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter, which typetask to fetch.
     */
    where?: typetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typetasks to fetch.
     */
    orderBy?: Enumerable<typetaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for typetasks.
     */
    cursor?: typetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of typetasks.
     */
    distinct?: Enumerable<TypetaskScalarFieldEnum>
  }

  /**
   * typetask findFirst
   */
  export interface typetaskFindFirstArgs extends typetaskFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * typetask findFirstOrThrow
   */
  export type typetaskFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter, which typetask to fetch.
     */
    where?: typetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typetasks to fetch.
     */
    orderBy?: Enumerable<typetaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for typetasks.
     */
    cursor?: typetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typetasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of typetasks.
     */
    distinct?: Enumerable<TypetaskScalarFieldEnum>
  }


  /**
   * typetask findMany
   */
  export type typetaskFindManyArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter, which typetasks to fetch.
     */
    where?: typetaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of typetasks to fetch.
     */
    orderBy?: Enumerable<typetaskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing typetasks.
     */
    cursor?: typetaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` typetasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` typetasks.
     */
    skip?: number
    distinct?: Enumerable<TypetaskScalarFieldEnum>
  }


  /**
   * typetask create
   */
  export type typetaskCreateArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * The data needed to create a typetask.
     */
    data: XOR<typetaskCreateInput, typetaskUncheckedCreateInput>
  }


  /**
   * typetask createMany
   */
  export type typetaskCreateManyArgs = {
    /**
     * The data used to create many typetasks.
     */
    data: Enumerable<typetaskCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * typetask update
   */
  export type typetaskUpdateArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * The data needed to update a typetask.
     */
    data: XOR<typetaskUpdateInput, typetaskUncheckedUpdateInput>
    /**
     * Choose, which typetask to update.
     */
    where: typetaskWhereUniqueInput
  }


  /**
   * typetask updateMany
   */
  export type typetaskUpdateManyArgs = {
    /**
     * The data used to update typetasks.
     */
    data: XOR<typetaskUpdateManyMutationInput, typetaskUncheckedUpdateManyInput>
    /**
     * Filter which typetasks to update
     */
    where?: typetaskWhereInput
  }


  /**
   * typetask upsert
   */
  export type typetaskUpsertArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * The filter to search for the typetask to update in case it exists.
     */
    where: typetaskWhereUniqueInput
    /**
     * In case the typetask found by the `where` argument doesn't exist, create a new typetask with this data.
     */
    create: XOR<typetaskCreateInput, typetaskUncheckedCreateInput>
    /**
     * In case the typetask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<typetaskUpdateInput, typetaskUncheckedUpdateInput>
  }


  /**
   * typetask delete
   */
  export type typetaskDeleteArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
    /**
     * Filter which typetask to delete.
     */
    where: typetaskWhereUniqueInput
  }


  /**
   * typetask deleteMany
   */
  export type typetaskDeleteManyArgs = {
    /**
     * Filter which typetasks to delete
     */
    where?: typetaskWhereInput
  }


  /**
   * typetask.task
   */
  export type typetask$taskArgs = {
    /**
     * Select specific fields to fetch from the task
     */
    select?: taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: taskInclude | null
    where?: taskWhereInput
    orderBy?: Enumerable<taskOrderByWithRelationInput>
    cursor?: taskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TaskScalarFieldEnum>
  }


  /**
   * typetask without action
   */
  export type typetaskArgs = {
    /**
     * Select specific fields to fetch from the typetask
     */
    select?: typetaskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: typetaskInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AnnonceurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    mail: 'mail',
    tel: 'tel',
    idCreatedpar: 'idCreatedpar'
  };

  export type AnnonceurScalarFieldEnum = (typeof AnnonceurScalarFieldEnum)[keyof typeof AnnonceurScalarFieldEnum]


  export const CategorieScalarFieldEnum: {
    id: 'id',
    categorie: 'categorie'
  };

  export type CategorieScalarFieldEnum = (typeof CategorieScalarFieldEnum)[keyof typeof CategorieScalarFieldEnum]


  export const CategoryrecetteScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type CategoryrecetteScalarFieldEnum = (typeof CategoryrecetteScalarFieldEnum)[keyof typeof CategoryrecetteScalarFieldEnum]


  export const CategorysensorsScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor'
  };

  export type CategorysensorsScalarFieldEnum = (typeof CategorysensorsScalarFieldEnum)[keyof typeof CategorysensorsScalarFieldEnum]


  export const CommandeScalarFieldEnum: {
    id: 'id',
    idRecette: 'idRecette',
    idIngredient: 'idIngredient',
    quantity: 'quantity'
  };

  export type CommandeScalarFieldEnum = (typeof CommandeScalarFieldEnum)[keyof typeof CommandeScalarFieldEnum]


  export const DistributeurScalarFieldEnum: {
    id: 'id',
    identifiant: 'identifiant',
    capaciteGoblet: 'capaciteGoblet',
    capaciteSucre: 'capaciteSucre',
    capaciteSpoon: 'capaciteSpoon'
  };

  export type DistributeurScalarFieldEnum = (typeof DistributeurScalarFieldEnum)[keyof typeof DistributeurScalarFieldEnum]


  export const EntrepiseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    adresse: 'adresse',
    mail: 'mail',
    tel: 'tel',
    link: 'link'
  };

  export type EntrepiseScalarFieldEnum = (typeof EntrepiseScalarFieldEnum)[keyof typeof EntrepiseScalarFieldEnum]


  export const FactureScalarFieldEnum: {
    id: 'id',
    idDistr: 'idDistr',
    idComm: 'idComm',
    idInfoPaiment: 'idInfoPaiment'
  };

  export type FactureScalarFieldEnum = (typeof FactureScalarFieldEnum)[keyof typeof FactureScalarFieldEnum]


  export const InfopaimentScalarFieldEnum: {
    id: 'id',
    mail: 'mail',
    cartePaiment: 'cartePaiment',
    ccv: 'ccv'
  };

  export type InfopaimentScalarFieldEnum = (typeof InfopaimentScalarFieldEnum)[keyof typeof InfopaimentScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    prixUnit: 'prixUnit'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const PackScalarFieldEnum: {
    idDistr: 'idDistr',
    idEntre: 'idEntre',
    codeverou: 'codeverou',
    localisation: 'localisation',
    state: 'state'
  };

  export type PackScalarFieldEnum = (typeof PackScalarFieldEnum)[keyof typeof PackScalarFieldEnum]


  export const PubliciteScalarFieldEnum: {
    id: 'id',
    url: 'url',
    idCategorie: 'idCategorie',
    idCategRecette: 'idCategRecette',
    idAnnonceur: 'idAnnonceur'
  };

  export type PubliciteScalarFieldEnum = (typeof PubliciteScalarFieldEnum)[keyof typeof PubliciteScalarFieldEnum]


  export const RecetteScalarFieldEnum: {
    id: 'id',
    idCategRecette: 'idCategRecette',
    name: 'name',
    description: 'description',
    price: 'price',
    imageLink: 'imageLink'
  };

  export type RecetteScalarFieldEnum = (typeof RecetteScalarFieldEnum)[keyof typeof RecetteScalarFieldEnum]


  export const RecetteingrScalarFieldEnum: {
    idRecette: 'idRecette',
    idIngredient: 'idIngredient',
    quantity: 'quantity'
  };

  export type RecetteingrScalarFieldEnum = (typeof RecetteingrScalarFieldEnum)[keyof typeof RecetteingrScalarFieldEnum]


  export const ReclamationScalarFieldEnum: {
    id: 'id',
    idFacture: 'idFacture',
    message: 'message',
    isDone: 'isDone'
  };

  export type ReclamationScalarFieldEnum = (typeof ReclamationScalarFieldEnum)[keyof typeof ReclamationScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SensorsScalarFieldEnum: {
    id: 'id',
    idDistr: 'idDistr',
    idSensor: 'idSensor',
    value: 'value'
  };

  export type SensorsScalarFieldEnum = (typeof SensorsScalarFieldEnum)[keyof typeof SensorsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TaskScalarFieldEnum: {
    id: 'id',
    idDistr: 'idDistr',
    idUser: 'idUser',
    idEntre: 'idEntre',
    idType: 'idType',
    isDone: 'isDone',
    isOpen: 'isOpen',
    date: 'date',
    time: 'time',
    message: 'message'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TypetaskScalarFieldEnum: {
    id: 'id',
    identifiant: 'identifiant',
    description: 'description'
  };

  export type TypetaskScalarFieldEnum = (typeof TypetaskScalarFieldEnum)[keyof typeof TypetaskScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    prenom: 'prenom',
    mail: 'mail',
    mdp: 'mdp',
    tel: 'tel',
    idRole: 'idRole',
    idCreatedpar: 'idCreatedpar',
    idEntreprise: 'idEntreprise',
    isActive: 'isActive'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type categorysensorsWhereInput = {
    AND?: Enumerable<categorysensorsWhereInput>
    OR?: Enumerable<categorysensorsWhereInput>
    NOT?: Enumerable<categorysensorsWhereInput>
    id?: IntFilter | number
    sensor?: StringNullableFilter | string | null
    sensors?: SensorsListRelationFilter
  }

  export type categorysensorsOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    sensors?: sensorsOrderByRelationAggregateInput
  }

  export type categorysensorsWhereUniqueInput = {
    id?: number
  }

  export type categorysensorsOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    _count?: categorysensorsCountOrderByAggregateInput
    _avg?: categorysensorsAvgOrderByAggregateInput
    _max?: categorysensorsMaxOrderByAggregateInput
    _min?: categorysensorsMinOrderByAggregateInput
    _sum?: categorysensorsSumOrderByAggregateInput
  }

  export type categorysensorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categorysensorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<categorysensorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categorysensorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringNullableWithAggregatesFilter | string | null
  }

  export type sensorsWhereInput = {
    AND?: Enumerable<sensorsWhereInput>
    OR?: Enumerable<sensorsWhereInput>
    NOT?: Enumerable<sensorsWhereInput>
    id?: IntFilter | number
    idDistr?: IntFilter | number
    idSensor?: IntFilter | number
    value?: StringFilter | string
    distr?: XOR<DistributeurRelationFilter, distributeurWhereInput>
    categorysensors?: XOR<CategorysensorsRelationFilter, categorysensorsWhereInput>
  }

  export type sensorsOrderByWithRelationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
    value?: SortOrder
    distr?: distributeurOrderByWithRelationInput
    categorysensors?: categorysensorsOrderByWithRelationInput
  }

  export type sensorsWhereUniqueInput = {
    id?: number
  }

  export type sensorsOrderByWithAggregationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
    value?: SortOrder
    _count?: sensorsCountOrderByAggregateInput
    _avg?: sensorsAvgOrderByAggregateInput
    _max?: sensorsMaxOrderByAggregateInput
    _min?: sensorsMinOrderByAggregateInput
    _sum?: sensorsSumOrderByAggregateInput
  }

  export type sensorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sensorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<sensorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sensorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idDistr?: IntWithAggregatesFilter | number
    idSensor?: IntWithAggregatesFilter | number
    value?: StringWithAggregatesFilter | string
  }

  export type categorieWhereInput = {
    AND?: Enumerable<categorieWhereInput>
    OR?: Enumerable<categorieWhereInput>
    NOT?: Enumerable<categorieWhereInput>
    id?: IntFilter | number
    categorie?: StringNullableFilter | string | null
  }

  export type categorieOrderByWithRelationInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type categorieWhereUniqueInput = {
    id?: number
  }

  export type categorieOrderByWithAggregationInput = {
    id?: SortOrder
    categorie?: SortOrder
    _count?: categorieCountOrderByAggregateInput
    _avg?: categorieAvgOrderByAggregateInput
    _max?: categorieMaxOrderByAggregateInput
    _min?: categorieMinOrderByAggregateInput
    _sum?: categorieSumOrderByAggregateInput
  }

  export type categorieScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categorieScalarWhereWithAggregatesInput>
    OR?: Enumerable<categorieScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categorieScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    categorie?: StringNullableWithAggregatesFilter | string | null
  }

  export type categoryrecetteWhereInput = {
    AND?: Enumerable<categoryrecetteWhereInput>
    OR?: Enumerable<categoryrecetteWhereInput>
    NOT?: Enumerable<categoryrecetteWhereInput>
    id?: IntFilter | number
    description?: StringNullableFilter | string | null
    recette?: RecetteListRelationFilter
    publicite?: PubliciteListRelationFilter
  }

  export type categoryrecetteOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    recette?: recetteOrderByRelationAggregateInput
    publicite?: publiciteOrderByRelationAggregateInput
  }

  export type categoryrecetteWhereUniqueInput = {
    id?: number
  }

  export type categoryrecetteOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    _count?: categoryrecetteCountOrderByAggregateInput
    _avg?: categoryrecetteAvgOrderByAggregateInput
    _max?: categoryrecetteMaxOrderByAggregateInput
    _min?: categoryrecetteMinOrderByAggregateInput
    _sum?: categoryrecetteSumOrderByAggregateInput
  }

  export type categoryrecetteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoryrecetteScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoryrecetteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoryrecetteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type commandeWhereInput = {
    AND?: Enumerable<commandeWhereInput>
    OR?: Enumerable<commandeWhereInput>
    NOT?: Enumerable<commandeWhereInput>
    id?: IntFilter | number
    idRecette?: IntFilter | number
    idIngredient?: IntNullableFilter | number | null
    quantity?: StringFilter | string
    recette?: XOR<RecetteRelationFilter, recetteWhereInput>
  }

  export type commandeOrderByWithRelationInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
    recette?: recetteOrderByWithRelationInput
  }

  export type commandeWhereUniqueInput = {
    id?: number
  }

  export type commandeOrderByWithAggregationInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
    _count?: commandeCountOrderByAggregateInput
    _avg?: commandeAvgOrderByAggregateInput
    _max?: commandeMaxOrderByAggregateInput
    _min?: commandeMinOrderByAggregateInput
    _sum?: commandeSumOrderByAggregateInput
  }

  export type commandeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<commandeScalarWhereWithAggregatesInput>
    OR?: Enumerable<commandeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<commandeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idRecette?: IntWithAggregatesFilter | number
    idIngredient?: IntNullableWithAggregatesFilter | number | null
    quantity?: StringWithAggregatesFilter | string
  }

  export type distributeurWhereInput = {
    AND?: Enumerable<distributeurWhereInput>
    OR?: Enumerable<distributeurWhereInput>
    NOT?: Enumerable<distributeurWhereInput>
    id?: IntFilter | number
    identifiant?: StringFilter | string
    capaciteGoblet?: IntNullableFilter | number | null
    capaciteSucre?: IntNullableFilter | number | null
    capaciteSpoon?: IntNullableFilter | number | null
    pack?: XOR<PackRelationFilter, packWhereInput> | null
    sensors?: SensorsListRelationFilter
  }

  export type distributeurOrderByWithRelationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
    pack?: packOrderByWithRelationInput
    sensors?: sensorsOrderByRelationAggregateInput
  }

  export type distributeurWhereUniqueInput = {
    id?: number
    identifiant?: string
  }

  export type distributeurOrderByWithAggregationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
    _count?: distributeurCountOrderByAggregateInput
    _avg?: distributeurAvgOrderByAggregateInput
    _max?: distributeurMaxOrderByAggregateInput
    _min?: distributeurMinOrderByAggregateInput
    _sum?: distributeurSumOrderByAggregateInput
  }

  export type distributeurScalarWhereWithAggregatesInput = {
    AND?: Enumerable<distributeurScalarWhereWithAggregatesInput>
    OR?: Enumerable<distributeurScalarWhereWithAggregatesInput>
    NOT?: Enumerable<distributeurScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    identifiant?: StringWithAggregatesFilter | string
    capaciteGoblet?: IntNullableWithAggregatesFilter | number | null
    capaciteSucre?: IntNullableWithAggregatesFilter | number | null
    capaciteSpoon?: IntNullableWithAggregatesFilter | number | null
  }

  export type entrepiseWhereInput = {
    AND?: Enumerable<entrepiseWhereInput>
    OR?: Enumerable<entrepiseWhereInput>
    NOT?: Enumerable<entrepiseWhereInput>
    id?: IntFilter | number
    nom?: StringNullableFilter | string | null
    adresse?: StringNullableFilter | string | null
    mail?: StringNullableFilter | string | null
    tel?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    pack?: PackListRelationFilter
    users?: UsersListRelationFilter
    task?: TaskListRelationFilter
  }

  export type entrepiseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    link?: SortOrder
    pack?: packOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    task?: taskOrderByRelationAggregateInput
  }

  export type entrepiseWhereUniqueInput = {
    id?: number
  }

  export type entrepiseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    link?: SortOrder
    _count?: entrepiseCountOrderByAggregateInput
    _avg?: entrepiseAvgOrderByAggregateInput
    _max?: entrepiseMaxOrderByAggregateInput
    _min?: entrepiseMinOrderByAggregateInput
    _sum?: entrepiseSumOrderByAggregateInput
  }

  export type entrepiseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<entrepiseScalarWhereWithAggregatesInput>
    OR?: Enumerable<entrepiseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<entrepiseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringNullableWithAggregatesFilter | string | null
    adresse?: StringNullableWithAggregatesFilter | string | null
    mail?: StringNullableWithAggregatesFilter | string | null
    tel?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
  }

  export type factureWhereInput = {
    AND?: Enumerable<factureWhereInput>
    OR?: Enumerable<factureWhereInput>
    NOT?: Enumerable<factureWhereInput>
    id?: IntFilter | number
    idDistr?: IntNullableFilter | number | null
    idComm?: IntNullableFilter | number | null
    idInfoPaiment?: IntNullableFilter | number | null
  }

  export type factureOrderByWithRelationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type factureWhereUniqueInput = {
    id?: number
  }

  export type factureOrderByWithAggregationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
    _count?: factureCountOrderByAggregateInput
    _avg?: factureAvgOrderByAggregateInput
    _max?: factureMaxOrderByAggregateInput
    _min?: factureMinOrderByAggregateInput
    _sum?: factureSumOrderByAggregateInput
  }

  export type factureScalarWhereWithAggregatesInput = {
    AND?: Enumerable<factureScalarWhereWithAggregatesInput>
    OR?: Enumerable<factureScalarWhereWithAggregatesInput>
    NOT?: Enumerable<factureScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idDistr?: IntNullableWithAggregatesFilter | number | null
    idComm?: IntNullableWithAggregatesFilter | number | null
    idInfoPaiment?: IntNullableWithAggregatesFilter | number | null
  }

  export type infopaimentWhereInput = {
    AND?: Enumerable<infopaimentWhereInput>
    OR?: Enumerable<infopaimentWhereInput>
    NOT?: Enumerable<infopaimentWhereInput>
    id?: IntFilter | number
    mail?: StringNullableFilter | string | null
    cartePaiment?: StringNullableFilter | string | null
    ccv?: StringNullableFilter | string | null
  }

  export type infopaimentOrderByWithRelationInput = {
    id?: SortOrder
    mail?: SortOrder
    cartePaiment?: SortOrder
    ccv?: SortOrder
  }

  export type infopaimentWhereUniqueInput = {
    id?: number
  }

  export type infopaimentOrderByWithAggregationInput = {
    id?: SortOrder
    mail?: SortOrder
    cartePaiment?: SortOrder
    ccv?: SortOrder
    _count?: infopaimentCountOrderByAggregateInput
    _avg?: infopaimentAvgOrderByAggregateInput
    _max?: infopaimentMaxOrderByAggregateInput
    _min?: infopaimentMinOrderByAggregateInput
    _sum?: infopaimentSumOrderByAggregateInput
  }

  export type infopaimentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<infopaimentScalarWhereWithAggregatesInput>
    OR?: Enumerable<infopaimentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<infopaimentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    mail?: StringNullableWithAggregatesFilter | string | null
    cartePaiment?: StringNullableWithAggregatesFilter | string | null
    ccv?: StringNullableWithAggregatesFilter | string | null
  }

  export type packWhereInput = {
    AND?: Enumerable<packWhereInput>
    OR?: Enumerable<packWhereInput>
    NOT?: Enumerable<packWhereInput>
    idDistr?: IntFilter | number
    idEntre?: IntFilter | number
    codeverou?: StringNullableFilter | string | null
    localisation?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    distr?: XOR<DistributeurRelationFilter, distributeurWhereInput>
    entre?: XOR<EntrepiseRelationFilter, entrepiseWhereInput>
  }

  export type packOrderByWithRelationInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
    codeverou?: SortOrder
    localisation?: SortOrder
    state?: SortOrder
    distr?: distributeurOrderByWithRelationInput
    entre?: entrepiseOrderByWithRelationInput
  }

  export type packWhereUniqueInput = {
    idDistr?: number
    idDistr_idEntre?: packIdDistrIdEntreCompoundUniqueInput
  }

  export type packOrderByWithAggregationInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
    codeverou?: SortOrder
    localisation?: SortOrder
    state?: SortOrder
    _count?: packCountOrderByAggregateInput
    _avg?: packAvgOrderByAggregateInput
    _max?: packMaxOrderByAggregateInput
    _min?: packMinOrderByAggregateInput
    _sum?: packSumOrderByAggregateInput
  }

  export type packScalarWhereWithAggregatesInput = {
    AND?: Enumerable<packScalarWhereWithAggregatesInput>
    OR?: Enumerable<packScalarWhereWithAggregatesInput>
    NOT?: Enumerable<packScalarWhereWithAggregatesInput>
    idDistr?: IntWithAggregatesFilter | number
    idEntre?: IntWithAggregatesFilter | number
    codeverou?: StringNullableWithAggregatesFilter | string | null
    localisation?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
  }

  export type publiciteWhereInput = {
    AND?: Enumerable<publiciteWhereInput>
    OR?: Enumerable<publiciteWhereInput>
    NOT?: Enumerable<publiciteWhereInput>
    id?: IntFilter | number
    url?: StringNullableFilter | string | null
    idCategorie?: IntNullableFilter | number | null
    idCategRecette?: IntNullableFilter | number | null
    idAnnonceur?: IntNullableFilter | number | null
    categoryrecette?: XOR<CategoryrecetteRelationFilter, categoryrecetteWhereInput> | null
  }

  export type publiciteOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
    categoryrecette?: categoryrecetteOrderByWithRelationInput
  }

  export type publiciteWhereUniqueInput = {
    id?: number
  }

  export type publiciteOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
    _count?: publiciteCountOrderByAggregateInput
    _avg?: publiciteAvgOrderByAggregateInput
    _max?: publiciteMaxOrderByAggregateInput
    _min?: publiciteMinOrderByAggregateInput
    _sum?: publiciteSumOrderByAggregateInput
  }

  export type publiciteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<publiciteScalarWhereWithAggregatesInput>
    OR?: Enumerable<publiciteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<publiciteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    url?: StringNullableWithAggregatesFilter | string | null
    idCategorie?: IntNullableWithAggregatesFilter | number | null
    idCategRecette?: IntNullableWithAggregatesFilter | number | null
    idAnnonceur?: IntNullableWithAggregatesFilter | number | null
  }

  export type recetteWhereInput = {
    AND?: Enumerable<recetteWhereInput>
    OR?: Enumerable<recetteWhereInput>
    NOT?: Enumerable<recetteWhereInput>
    id?: IntFilter | number
    idCategRecette?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imageLink?: StringNullableFilter | string | null
    commande?: CommandeListRelationFilter
    categoryrecette?: XOR<CategoryrecetteRelationFilter, categoryrecetteWhereInput> | null
    recetteingr?: RecetteingrListRelationFilter
  }

  export type recetteOrderByWithRelationInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageLink?: SortOrder
    commande?: commandeOrderByRelationAggregateInput
    categoryrecette?: categoryrecetteOrderByWithRelationInput
    recetteingr?: recetteingrOrderByRelationAggregateInput
  }

  export type recetteWhereUniqueInput = {
    id?: number
  }

  export type recetteOrderByWithAggregationInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageLink?: SortOrder
    _count?: recetteCountOrderByAggregateInput
    _avg?: recetteAvgOrderByAggregateInput
    _max?: recetteMaxOrderByAggregateInput
    _min?: recetteMinOrderByAggregateInput
    _sum?: recetteSumOrderByAggregateInput
  }

  export type recetteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<recetteScalarWhereWithAggregatesInput>
    OR?: Enumerable<recetteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<recetteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idCategRecette?: IntNullableWithAggregatesFilter | number | null
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    imageLink?: StringNullableWithAggregatesFilter | string | null
  }

  export type reclamationWhereInput = {
    AND?: Enumerable<reclamationWhereInput>
    OR?: Enumerable<reclamationWhereInput>
    NOT?: Enumerable<reclamationWhereInput>
    id?: IntFilter | number
    idFacture?: IntNullableFilter | number | null
    message?: StringNullableFilter | string | null
    isDone?: BoolNullableFilter | boolean | null
  }

  export type reclamationOrderByWithRelationInput = {
    id?: SortOrder
    idFacture?: SortOrder
    message?: SortOrder
    isDone?: SortOrder
  }

  export type reclamationWhereUniqueInput = {
    id?: number
  }

  export type reclamationOrderByWithAggregationInput = {
    id?: SortOrder
    idFacture?: SortOrder
    message?: SortOrder
    isDone?: SortOrder
    _count?: reclamationCountOrderByAggregateInput
    _avg?: reclamationAvgOrderByAggregateInput
    _max?: reclamationMaxOrderByAggregateInput
    _min?: reclamationMinOrderByAggregateInput
    _sum?: reclamationSumOrderByAggregateInput
  }

  export type reclamationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reclamationScalarWhereWithAggregatesInput>
    OR?: Enumerable<reclamationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reclamationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idFacture?: IntNullableWithAggregatesFilter | number | null
    message?: StringNullableWithAggregatesFilter | string | null
    isDone?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type taskWhereInput = {
    AND?: Enumerable<taskWhereInput>
    OR?: Enumerable<taskWhereInput>
    NOT?: Enumerable<taskWhereInput>
    id?: IntFilter | number
    idDistr?: IntFilter | number
    idUser?: IntNullableFilter | number | null
    idEntre?: IntFilter | number
    idType?: IntFilter | number
    isDone?: BoolFilter | boolean
    isOpen?: BoolFilter | boolean
    date?: StringFilter | string
    time?: StringFilter | string
    message?: StringFilter | string
    typetask?: XOR<TypetaskRelationFilter, typetaskWhereInput> | null
    userAM?: XOR<UsersRelationFilter, usersWhereInput> | null
    entreprise?: XOR<EntrepiseRelationFilter, entrepiseWhereInput> | null
  }

  export type taskOrderByWithRelationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
    isDone?: SortOrder
    isOpen?: SortOrder
    date?: SortOrder
    time?: SortOrder
    message?: SortOrder
    typetask?: typetaskOrderByWithRelationInput
    userAM?: usersOrderByWithRelationInput
    entreprise?: entrepiseOrderByWithRelationInput
  }

  export type taskWhereUniqueInput = {
    id?: number
  }

  export type taskOrderByWithAggregationInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
    isDone?: SortOrder
    isOpen?: SortOrder
    date?: SortOrder
    time?: SortOrder
    message?: SortOrder
    _count?: taskCountOrderByAggregateInput
    _avg?: taskAvgOrderByAggregateInput
    _max?: taskMaxOrderByAggregateInput
    _min?: taskMinOrderByAggregateInput
    _sum?: taskSumOrderByAggregateInput
  }

  export type taskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<taskScalarWhereWithAggregatesInput>
    OR?: Enumerable<taskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<taskScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idDistr?: IntWithAggregatesFilter | number
    idUser?: IntNullableWithAggregatesFilter | number | null
    idEntre?: IntWithAggregatesFilter | number
    idType?: IntWithAggregatesFilter | number
    isDone?: BoolWithAggregatesFilter | boolean
    isOpen?: BoolWithAggregatesFilter | boolean
    date?: StringWithAggregatesFilter | string
    time?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    nom?: StringNullableFilter | string | null
    prenom?: StringNullableFilter | string | null
    mail?: StringNullableFilter | string | null
    mdp?: StringNullableFilter | string | null
    tel?: StringNullableFilter | string | null
    idRole?: IntNullableFilter | number | null
    idCreatedpar?: IntNullableFilter | number | null
    idEntreprise?: IntNullableFilter | number | null
    isActive?: IntNullableFilter | number | null
    task?: TaskListRelationFilter
    entreprise?: XOR<EntrepiseRelationFilter, entrepiseWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    mdp?: SortOrder
    tel?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
    task?: taskOrderByRelationAggregateInput
    entreprise?: entrepiseOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = {
    id?: number
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    mdp?: SortOrder
    tel?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringNullableWithAggregatesFilter | string | null
    prenom?: StringNullableWithAggregatesFilter | string | null
    mail?: StringNullableWithAggregatesFilter | string | null
    mdp?: StringNullableWithAggregatesFilter | string | null
    tel?: StringNullableWithAggregatesFilter | string | null
    idRole?: IntNullableWithAggregatesFilter | number | null
    idCreatedpar?: IntNullableWithAggregatesFilter | number | null
    idEntreprise?: IntNullableWithAggregatesFilter | number | null
    isActive?: IntNullableWithAggregatesFilter | number | null
  }

  export type annonceurWhereInput = {
    AND?: Enumerable<annonceurWhereInput>
    OR?: Enumerable<annonceurWhereInput>
    NOT?: Enumerable<annonceurWhereInput>
    id?: IntFilter | number
    nom?: StringNullableFilter | string | null
    prenom?: StringNullableFilter | string | null
    mail?: StringNullableFilter | string | null
    tel?: StringNullableFilter | string | null
    idCreatedpar?: IntNullableFilter | number | null
  }

  export type annonceurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type annonceurWhereUniqueInput = {
    id?: number
  }

  export type annonceurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    idCreatedpar?: SortOrder
    _count?: annonceurCountOrderByAggregateInput
    _avg?: annonceurAvgOrderByAggregateInput
    _max?: annonceurMaxOrderByAggregateInput
    _min?: annonceurMinOrderByAggregateInput
    _sum?: annonceurSumOrderByAggregateInput
  }

  export type annonceurScalarWhereWithAggregatesInput = {
    AND?: Enumerable<annonceurScalarWhereWithAggregatesInput>
    OR?: Enumerable<annonceurScalarWhereWithAggregatesInput>
    NOT?: Enumerable<annonceurScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringNullableWithAggregatesFilter | string | null
    prenom?: StringNullableWithAggregatesFilter | string | null
    mail?: StringNullableWithAggregatesFilter | string | null
    tel?: StringNullableWithAggregatesFilter | string | null
    idCreatedpar?: IntNullableWithAggregatesFilter | number | null
  }

  export type ingredientWhereInput = {
    AND?: Enumerable<ingredientWhereInput>
    OR?: Enumerable<ingredientWhereInput>
    NOT?: Enumerable<ingredientWhereInput>
    id?: IntFilter | number
    type?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    prixUnit?: IntNullableFilter | number | null
  }

  export type ingredientOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    prixUnit?: SortOrder
  }

  export type ingredientWhereUniqueInput = {
    id?: number
  }

  export type ingredientOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    prixUnit?: SortOrder
    _count?: ingredientCountOrderByAggregateInput
    _avg?: ingredientAvgOrderByAggregateInput
    _max?: ingredientMaxOrderByAggregateInput
    _min?: ingredientMinOrderByAggregateInput
    _sum?: ingredientSumOrderByAggregateInput
  }

  export type ingredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ingredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ingredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ingredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    prixUnit?: IntNullableWithAggregatesFilter | number | null
  }

  export type recetteingrWhereInput = {
    AND?: Enumerable<recetteingrWhereInput>
    OR?: Enumerable<recetteingrWhereInput>
    NOT?: Enumerable<recetteingrWhereInput>
    idRecette?: IntFilter | number
    idIngredient?: IntFilter | number
    quantity?: StringNullableFilter | string | null
    recette?: XOR<RecetteRelationFilter, recetteWhereInput>
  }

  export type recetteingrOrderByWithRelationInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
    recette?: recetteOrderByWithRelationInput
  }

  export type recetteingrWhereUniqueInput = {
    idRecette_idIngredient?: recetteingrIdRecetteIdIngredientCompoundUniqueInput
  }

  export type recetteingrOrderByWithAggregationInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
    _count?: recetteingrCountOrderByAggregateInput
    _avg?: recetteingrAvgOrderByAggregateInput
    _max?: recetteingrMaxOrderByAggregateInput
    _min?: recetteingrMinOrderByAggregateInput
    _sum?: recetteingrSumOrderByAggregateInput
  }

  export type recetteingrScalarWhereWithAggregatesInput = {
    AND?: Enumerable<recetteingrScalarWhereWithAggregatesInput>
    OR?: Enumerable<recetteingrScalarWhereWithAggregatesInput>
    NOT?: Enumerable<recetteingrScalarWhereWithAggregatesInput>
    idRecette?: IntWithAggregatesFilter | number
    idIngredient?: IntWithAggregatesFilter | number
    quantity?: StringNullableWithAggregatesFilter | string | null
  }

  export type roleWhereInput = {
    AND?: Enumerable<roleWhereInput>
    OR?: Enumerable<roleWhereInput>
    NOT?: Enumerable<roleWhereInput>
    id?: IntFilter | number
    description?: StringNullableFilter | string | null
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type roleWhereUniqueInput = {
    id?: number
  }

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<roleScalarWhereWithAggregatesInput>
    OR?: Enumerable<roleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<roleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type typetaskWhereInput = {
    AND?: Enumerable<typetaskWhereInput>
    OR?: Enumerable<typetaskWhereInput>
    NOT?: Enumerable<typetaskWhereInput>
    id?: IntFilter | number
    identifiant?: StringFilter | string
    description?: StringNullableFilter | string | null
    task?: TaskListRelationFilter
  }

  export type typetaskOrderByWithRelationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    description?: SortOrder
    task?: taskOrderByRelationAggregateInput
  }

  export type typetaskWhereUniqueInput = {
    id?: number
    identifiant?: string
  }

  export type typetaskOrderByWithAggregationInput = {
    id?: SortOrder
    identifiant?: SortOrder
    description?: SortOrder
    _count?: typetaskCountOrderByAggregateInput
    _avg?: typetaskAvgOrderByAggregateInput
    _max?: typetaskMaxOrderByAggregateInput
    _min?: typetaskMinOrderByAggregateInput
    _sum?: typetaskSumOrderByAggregateInput
  }

  export type typetaskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<typetaskScalarWhereWithAggregatesInput>
    OR?: Enumerable<typetaskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<typetaskScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    identifiant?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type categorysensorsCreateInput = {
    sensor?: string | null
    sensors?: sensorsCreateNestedManyWithoutCategorysensorsInput
  }

  export type categorysensorsUncheckedCreateInput = {
    id?: number
    sensor?: string | null
    sensors?: sensorsUncheckedCreateNestedManyWithoutCategorysensorsInput
  }

  export type categorysensorsUpdateInput = {
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: sensorsUpdateManyWithoutCategorysensorsNestedInput
  }

  export type categorysensorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
    sensors?: sensorsUncheckedUpdateManyWithoutCategorysensorsNestedInput
  }

  export type categorysensorsCreateManyInput = {
    id?: number
    sensor?: string | null
  }

  export type categorysensorsUpdateManyMutationInput = {
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categorysensorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sensorsCreateInput = {
    value: string
    distr: distributeurCreateNestedOneWithoutSensorsInput
    categorysensors: categorysensorsCreateNestedOneWithoutSensorsInput
  }

  export type sensorsUncheckedCreateInput = {
    id?: number
    idDistr: number
    idSensor: number
    value: string
  }

  export type sensorsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    distr?: distributeurUpdateOneRequiredWithoutSensorsNestedInput
    categorysensors?: categorysensorsUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type sensorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idSensor?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type sensorsCreateManyInput = {
    id?: number
    idDistr: number
    idSensor: number
    value: string
  }

  export type sensorsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type sensorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idSensor?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type categorieCreateInput = {
    categorie?: string | null
  }

  export type categorieUncheckedCreateInput = {
    id?: number
    categorie?: string | null
  }

  export type categorieUpdateInput = {
    categorie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categorieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categorieCreateManyInput = {
    id?: number
    categorie?: string | null
  }

  export type categorieUpdateManyMutationInput = {
    categorie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categorieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryrecetteCreateInput = {
    description?: string | null
    recette?: recetteCreateNestedManyWithoutCategoryrecetteInput
    publicite?: publiciteCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteUncheckedCreateInput = {
    id?: number
    description?: string | null
    recette?: recetteUncheckedCreateNestedManyWithoutCategoryrecetteInput
    publicite?: publiciteUncheckedCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: recetteUpdateManyWithoutCategoryrecetteNestedInput
    publicite?: publiciteUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type categoryrecetteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: recetteUncheckedUpdateManyWithoutCategoryrecetteNestedInput
    publicite?: publiciteUncheckedUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type categoryrecetteCreateManyInput = {
    id?: number
    description?: string | null
  }

  export type categoryrecetteUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryrecetteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commandeCreateInput = {
    idIngredient?: number | null
    quantity: string
    recette: recetteCreateNestedOneWithoutCommandeInput
  }

  export type commandeUncheckedCreateInput = {
    id?: number
    idRecette: number
    idIngredient?: number | null
    quantity: string
  }

  export type commandeUpdateInput = {
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
    recette?: recetteUpdateOneRequiredWithoutCommandeNestedInput
  }

  export type commandeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRecette?: IntFieldUpdateOperationsInput | number
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type commandeCreateManyInput = {
    id?: number
    idRecette: number
    idIngredient?: number | null
    quantity: string
  }

  export type commandeUpdateManyMutationInput = {
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type commandeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRecette?: IntFieldUpdateOperationsInput | number
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type distributeurCreateInput = {
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    pack?: packCreateNestedOneWithoutDistrInput
    sensors?: sensorsCreateNestedManyWithoutDistrInput
  }

  export type distributeurUncheckedCreateInput = {
    id?: number
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    pack?: packUncheckedCreateNestedOneWithoutDistrInput
    sensors?: sensorsUncheckedCreateNestedManyWithoutDistrInput
  }

  export type distributeurUpdateInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    pack?: packUpdateOneWithoutDistrNestedInput
    sensors?: sensorsUpdateManyWithoutDistrNestedInput
  }

  export type distributeurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    pack?: packUncheckedUpdateOneWithoutDistrNestedInput
    sensors?: sensorsUncheckedUpdateManyWithoutDistrNestedInput
  }

  export type distributeurCreateManyInput = {
    id?: number
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
  }

  export type distributeurUpdateManyMutationInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type distributeurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type entrepiseCreateInput = {
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packCreateNestedManyWithoutEntreInput
    users?: usersCreateNestedManyWithoutEntrepriseInput
    task?: taskCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseUncheckedCreateInput = {
    id?: number
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packUncheckedCreateNestedManyWithoutEntreInput
    users?: usersUncheckedCreateNestedManyWithoutEntrepriseInput
    task?: taskUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUpdateManyWithoutEntreNestedInput
    users?: usersUpdateManyWithoutEntrepriseNestedInput
    task?: taskUpdateManyWithoutEntrepriseNestedInput
  }

  export type entrepiseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUncheckedUpdateManyWithoutEntreNestedInput
    users?: usersUncheckedUpdateManyWithoutEntrepriseNestedInput
    task?: taskUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type entrepiseCreateManyInput = {
    id?: number
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
  }

  export type entrepiseUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entrepiseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type factureCreateInput = {
    idDistr?: number | null
    idComm?: number | null
    idInfoPaiment?: number | null
  }

  export type factureUncheckedCreateInput = {
    id?: number
    idDistr?: number | null
    idComm?: number | null
    idInfoPaiment?: number | null
  }

  export type factureUpdateInput = {
    idDistr?: NullableIntFieldUpdateOperationsInput | number | null
    idComm?: NullableIntFieldUpdateOperationsInput | number | null
    idInfoPaiment?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type factureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: NullableIntFieldUpdateOperationsInput | number | null
    idComm?: NullableIntFieldUpdateOperationsInput | number | null
    idInfoPaiment?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type factureCreateManyInput = {
    id?: number
    idDistr?: number | null
    idComm?: number | null
    idInfoPaiment?: number | null
  }

  export type factureUpdateManyMutationInput = {
    idDistr?: NullableIntFieldUpdateOperationsInput | number | null
    idComm?: NullableIntFieldUpdateOperationsInput | number | null
    idInfoPaiment?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type factureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: NullableIntFieldUpdateOperationsInput | number | null
    idComm?: NullableIntFieldUpdateOperationsInput | number | null
    idInfoPaiment?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type infopaimentCreateInput = {
    mail?: string | null
    cartePaiment?: string | null
    ccv?: string | null
  }

  export type infopaimentUncheckedCreateInput = {
    id?: number
    mail?: string | null
    cartePaiment?: string | null
    ccv?: string | null
  }

  export type infopaimentUpdateInput = {
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    cartePaiment?: NullableStringFieldUpdateOperationsInput | string | null
    ccv?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infopaimentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    cartePaiment?: NullableStringFieldUpdateOperationsInput | string | null
    ccv?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infopaimentCreateManyInput = {
    id?: number
    mail?: string | null
    cartePaiment?: string | null
    ccv?: string | null
  }

  export type infopaimentUpdateManyMutationInput = {
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    cartePaiment?: NullableStringFieldUpdateOperationsInput | string | null
    ccv?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type infopaimentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    cartePaiment?: NullableStringFieldUpdateOperationsInput | string | null
    ccv?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packCreateInput = {
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
    distr: distributeurCreateNestedOneWithoutPackInput
    entre: entrepiseCreateNestedOneWithoutPackInput
  }

  export type packUncheckedCreateInput = {
    idDistr: number
    idEntre: number
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
  }

  export type packUpdateInput = {
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    distr?: distributeurUpdateOneRequiredWithoutPackNestedInput
    entre?: entrepiseUpdateOneRequiredWithoutPackNestedInput
  }

  export type packUncheckedUpdateInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    idEntre?: IntFieldUpdateOperationsInput | number
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packCreateManyInput = {
    idDistr: number
    idEntre: number
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
  }

  export type packUpdateManyMutationInput = {
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packUncheckedUpdateManyInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    idEntre?: IntFieldUpdateOperationsInput | number
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publiciteCreateInput = {
    url?: string | null
    idCategorie?: number | null
    idAnnonceur?: number | null
    categoryrecette?: categoryrecetteCreateNestedOneWithoutPubliciteInput
  }

  export type publiciteUncheckedCreateInput = {
    id?: number
    url?: string | null
    idCategorie?: number | null
    idCategRecette?: number | null
    idAnnonceur?: number | null
  }

  export type publiciteUpdateInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
    categoryrecette?: categoryrecetteUpdateOneWithoutPubliciteNestedInput
  }

  export type publiciteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publiciteCreateManyInput = {
    id?: number
    url?: string | null
    idCategorie?: number | null
    idCategRecette?: number | null
    idAnnonceur?: number | null
  }

  export type publiciteUpdateManyMutationInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publiciteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type recetteCreateInput = {
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeCreateNestedManyWithoutRecetteInput
    categoryrecette?: categoryrecetteCreateNestedOneWithoutRecetteInput
    recetteingr?: recetteingrCreateNestedManyWithoutRecetteInput
  }

  export type recetteUncheckedCreateInput = {
    id?: number
    idCategRecette?: number | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeUncheckedCreateNestedManyWithoutRecetteInput
    recetteingr?: recetteingrUncheckedCreateNestedManyWithoutRecetteInput
  }

  export type recetteUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUpdateManyWithoutRecetteNestedInput
    categoryrecette?: categoryrecetteUpdateOneWithoutRecetteNestedInput
    recetteingr?: recetteingrUpdateManyWithoutRecetteNestedInput
  }

  export type recetteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUncheckedUpdateManyWithoutRecetteNestedInput
    recetteingr?: recetteingrUncheckedUpdateManyWithoutRecetteNestedInput
  }

  export type recetteCreateManyInput = {
    id?: number
    idCategRecette?: number | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
  }

  export type recetteUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reclamationCreateInput = {
    idFacture?: number | null
    message?: string | null
    isDone?: boolean | null
  }

  export type reclamationUncheckedCreateInput = {
    id?: number
    idFacture?: number | null
    message?: string | null
    isDone?: boolean | null
  }

  export type reclamationUpdateInput = {
    idFacture?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type reclamationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idFacture?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type reclamationCreateManyInput = {
    id?: number
    idFacture?: number | null
    message?: string | null
    isDone?: boolean | null
  }

  export type reclamationUpdateManyMutationInput = {
    idFacture?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type reclamationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idFacture?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isDone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type taskCreateInput = {
    idDistr: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
    typetask?: typetaskCreateNestedOneWithoutTaskInput
    userAM?: usersCreateNestedOneWithoutTaskInput
    entreprise?: entrepiseCreateNestedOneWithoutTaskInput
  }

  export type taskUncheckedCreateInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idEntre: number
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskUpdateInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    typetask?: typetaskUpdateOneWithoutTaskNestedInput
    userAM?: usersUpdateOneWithoutTaskNestedInput
    entreprise?: entrepiseUpdateOneWithoutTaskNestedInput
  }

  export type taskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idUser?: NullableIntFieldUpdateOperationsInput | number | null
    idEntre?: IntFieldUpdateOperationsInput | number
    idType?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type taskCreateManyInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idEntre: number
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskUpdateManyMutationInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type taskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idUser?: NullableIntFieldUpdateOperationsInput | number | null
    idEntre?: IntFieldUpdateOperationsInput | number
    idType?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    isActive?: number | null
    task?: taskCreateNestedManyWithoutUserAMInput
    entreprise?: entrepiseCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    idEntreprise?: number | null
    isActive?: number | null
    task?: taskUncheckedCreateNestedManyWithoutUserAMInput
  }

  export type usersUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
    task?: taskUpdateManyWithoutUserAMNestedInput
    entreprise?: entrepiseUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    idEntreprise?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
    task?: taskUncheckedUpdateManyWithoutUserAMNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    idEntreprise?: number | null
    isActive?: number | null
  }

  export type usersUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    idEntreprise?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type annonceurCreateInput = {
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    tel?: string | null
    idCreatedpar?: number | null
  }

  export type annonceurUncheckedCreateInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    tel?: string | null
    idCreatedpar?: number | null
  }

  export type annonceurUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type annonceurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type annonceurCreateManyInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    tel?: string | null
    idCreatedpar?: number | null
  }

  export type annonceurUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type annonceurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientCreateInput = {
    type?: number | null
    description?: string | null
    prixUnit?: number | null
  }

  export type ingredientUncheckedCreateInput = {
    id?: number
    type?: number | null
    description?: string | null
    prixUnit?: number | null
  }

  export type ingredientUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prixUnit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prixUnit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientCreateManyInput = {
    id?: number
    type?: number | null
    description?: string | null
    prixUnit?: number | null
  }

  export type ingredientUpdateManyMutationInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prixUnit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prixUnit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type recetteingrCreateInput = {
    idIngredient: number
    quantity?: string | null
    recette: recetteCreateNestedOneWithoutRecetteingrInput
  }

  export type recetteingrUncheckedCreateInput = {
    idRecette: number
    idIngredient: number
    quantity?: string | null
  }

  export type recetteingrUpdateInput = {
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: recetteUpdateOneRequiredWithoutRecetteingrNestedInput
  }

  export type recetteingrUncheckedUpdateInput = {
    idRecette?: IntFieldUpdateOperationsInput | number
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteingrCreateManyInput = {
    idRecette: number
    idIngredient: number
    quantity?: string | null
  }

  export type recetteingrUpdateManyMutationInput = {
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteingrUncheckedUpdateManyInput = {
    idRecette?: IntFieldUpdateOperationsInput | number
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleCreateInput = {
    description?: string | null
  }

  export type roleUncheckedCreateInput = {
    id?: number
    description?: string | null
  }

  export type roleUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleCreateManyInput = {
    id?: number
    description?: string | null
  }

  export type roleUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type typetaskCreateInput = {
    identifiant: string
    description?: string | null
    task?: taskCreateNestedManyWithoutTypetaskInput
  }

  export type typetaskUncheckedCreateInput = {
    id?: number
    identifiant: string
    description?: string | null
    task?: taskUncheckedCreateNestedManyWithoutTypetaskInput
  }

  export type typetaskUpdateInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: taskUpdateManyWithoutTypetaskNestedInput
  }

  export type typetaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: taskUncheckedUpdateManyWithoutTypetaskNestedInput
  }

  export type typetaskCreateManyInput = {
    id?: number
    identifiant: string
    description?: string | null
  }

  export type typetaskUpdateManyMutationInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type typetaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type SensorsListRelationFilter = {
    every?: sensorsWhereInput
    some?: sensorsWhereInput
    none?: sensorsWhereInput
  }

  export type sensorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categorysensorsCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
  }

  export type categorysensorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categorysensorsMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
  }

  export type categorysensorsMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
  }

  export type categorysensorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DistributeurRelationFilter = {
    is?: distributeurWhereInput
    isNot?: distributeurWhereInput
  }

  export type CategorysensorsRelationFilter = {
    is?: categorysensorsWhereInput
    isNot?: categorysensorsWhereInput
  }

  export type sensorsCountOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
    value?: SortOrder
  }

  export type sensorsAvgOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
  }

  export type sensorsMaxOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
    value?: SortOrder
  }

  export type sensorsMinOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
    value?: SortOrder
  }

  export type sensorsSumOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idSensor?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type categorieCountOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type categorieAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categorieMaxOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type categorieMinOrderByAggregateInput = {
    id?: SortOrder
    categorie?: SortOrder
  }

  export type categorieSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecetteListRelationFilter = {
    every?: recetteWhereInput
    some?: recetteWhereInput
    none?: recetteWhereInput
  }

  export type PubliciteListRelationFilter = {
    every?: publiciteWhereInput
    some?: publiciteWhereInput
    none?: publiciteWhereInput
  }

  export type recetteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publiciteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryrecetteCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type categoryrecetteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryrecetteMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type categoryrecetteMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type categoryrecetteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type RecetteRelationFilter = {
    is?: recetteWhereInput
    isNot?: recetteWhereInput
  }

  export type commandeCountOrderByAggregateInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type commandeAvgOrderByAggregateInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
  }

  export type commandeMaxOrderByAggregateInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type commandeMinOrderByAggregateInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type commandeSumOrderByAggregateInput = {
    id?: SortOrder
    idRecette?: SortOrder
    idIngredient?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type PackRelationFilter = {
    is?: packWhereInput | null
    isNot?: packWhereInput | null
  }

  export type distributeurCountOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
  }

  export type distributeurAvgOrderByAggregateInput = {
    id?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
  }

  export type distributeurMaxOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
  }

  export type distributeurMinOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
  }

  export type distributeurSumOrderByAggregateInput = {
    id?: SortOrder
    capaciteGoblet?: SortOrder
    capaciteSucre?: SortOrder
    capaciteSpoon?: SortOrder
  }

  export type PackListRelationFilter = {
    every?: packWhereInput
    some?: packWhereInput
    none?: packWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type TaskListRelationFilter = {
    every?: taskWhereInput
    some?: taskWhereInput
    none?: taskWhereInput
  }

  export type packOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type taskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entrepiseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    link?: SortOrder
  }

  export type entrepiseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type entrepiseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    link?: SortOrder
  }

  export type entrepiseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    link?: SortOrder
  }

  export type entrepiseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type factureCountOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type factureAvgOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type factureMaxOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type factureMinOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type factureSumOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idComm?: SortOrder
    idInfoPaiment?: SortOrder
  }

  export type infopaimentCountOrderByAggregateInput = {
    id?: SortOrder
    mail?: SortOrder
    cartePaiment?: SortOrder
    ccv?: SortOrder
  }

  export type infopaimentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type infopaimentMaxOrderByAggregateInput = {
    id?: SortOrder
    mail?: SortOrder
    cartePaiment?: SortOrder
    ccv?: SortOrder
  }

  export type infopaimentMinOrderByAggregateInput = {
    id?: SortOrder
    mail?: SortOrder
    cartePaiment?: SortOrder
    ccv?: SortOrder
  }

  export type infopaimentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EntrepiseRelationFilter = {
    is?: entrepiseWhereInput | null
    isNot?: entrepiseWhereInput | null
  }

  export type packIdDistrIdEntreCompoundUniqueInput = {
    idDistr: number
    idEntre: number
  }

  export type packCountOrderByAggregateInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
    codeverou?: SortOrder
    localisation?: SortOrder
    state?: SortOrder
  }

  export type packAvgOrderByAggregateInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
  }

  export type packMaxOrderByAggregateInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
    codeverou?: SortOrder
    localisation?: SortOrder
    state?: SortOrder
  }

  export type packMinOrderByAggregateInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
    codeverou?: SortOrder
    localisation?: SortOrder
    state?: SortOrder
  }

  export type packSumOrderByAggregateInput = {
    idDistr?: SortOrder
    idEntre?: SortOrder
  }

  export type CategoryrecetteRelationFilter = {
    is?: categoryrecetteWhereInput | null
    isNot?: categoryrecetteWhereInput | null
  }

  export type publiciteCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
  }

  export type publiciteAvgOrderByAggregateInput = {
    id?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
  }

  export type publiciteMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
  }

  export type publiciteMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
  }

  export type publiciteSumOrderByAggregateInput = {
    id?: SortOrder
    idCategorie?: SortOrder
    idCategRecette?: SortOrder
    idAnnonceur?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type CommandeListRelationFilter = {
    every?: commandeWhereInput
    some?: commandeWhereInput
    none?: commandeWhereInput
  }

  export type RecetteingrListRelationFilter = {
    every?: recetteingrWhereInput
    some?: recetteingrWhereInput
    none?: recetteingrWhereInput
  }

  export type commandeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recetteingrOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recetteCountOrderByAggregateInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageLink?: SortOrder
  }

  export type recetteAvgOrderByAggregateInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    price?: SortOrder
  }

  export type recetteMaxOrderByAggregateInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageLink?: SortOrder
  }

  export type recetteMinOrderByAggregateInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    imageLink?: SortOrder
  }

  export type recetteSumOrderByAggregateInput = {
    id?: SortOrder
    idCategRecette?: SortOrder
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type reclamationCountOrderByAggregateInput = {
    id?: SortOrder
    idFacture?: SortOrder
    message?: SortOrder
    isDone?: SortOrder
  }

  export type reclamationAvgOrderByAggregateInput = {
    id?: SortOrder
    idFacture?: SortOrder
  }

  export type reclamationMaxOrderByAggregateInput = {
    id?: SortOrder
    idFacture?: SortOrder
    message?: SortOrder
    isDone?: SortOrder
  }

  export type reclamationMinOrderByAggregateInput = {
    id?: SortOrder
    idFacture?: SortOrder
    message?: SortOrder
    isDone?: SortOrder
  }

  export type reclamationSumOrderByAggregateInput = {
    id?: SortOrder
    idFacture?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TypetaskRelationFilter = {
    is?: typetaskWhereInput | null
    isNot?: typetaskWhereInput | null
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type taskCountOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
    isDone?: SortOrder
    isOpen?: SortOrder
    date?: SortOrder
    time?: SortOrder
    message?: SortOrder
  }

  export type taskAvgOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
  }

  export type taskMaxOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
    isDone?: SortOrder
    isOpen?: SortOrder
    date?: SortOrder
    time?: SortOrder
    message?: SortOrder
  }

  export type taskMinOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
    isDone?: SortOrder
    isOpen?: SortOrder
    date?: SortOrder
    time?: SortOrder
    message?: SortOrder
  }

  export type taskSumOrderByAggregateInput = {
    id?: SortOrder
    idDistr?: SortOrder
    idUser?: SortOrder
    idEntre?: SortOrder
    idType?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    mdp?: SortOrder
    tel?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    mdp?: SortOrder
    tel?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    mdp?: SortOrder
    tel?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    idRole?: SortOrder
    idCreatedpar?: SortOrder
    idEntreprise?: SortOrder
    isActive?: SortOrder
  }

  export type annonceurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type annonceurAvgOrderByAggregateInput = {
    id?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type annonceurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type annonceurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    mail?: SortOrder
    tel?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type annonceurSumOrderByAggregateInput = {
    id?: SortOrder
    idCreatedpar?: SortOrder
  }

  export type ingredientCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    prixUnit?: SortOrder
  }

  export type ingredientAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    prixUnit?: SortOrder
  }

  export type ingredientMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    prixUnit?: SortOrder
  }

  export type ingredientMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    prixUnit?: SortOrder
  }

  export type ingredientSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    prixUnit?: SortOrder
  }

  export type recetteingrIdRecetteIdIngredientCompoundUniqueInput = {
    idRecette: number
    idIngredient: number
  }

  export type recetteingrCountOrderByAggregateInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type recetteingrAvgOrderByAggregateInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
  }

  export type recetteingrMaxOrderByAggregateInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type recetteingrMinOrderByAggregateInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
    quantity?: SortOrder
  }

  export type recetteingrSumOrderByAggregateInput = {
    idRecette?: SortOrder
    idIngredient?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typetaskCountOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    description?: SortOrder
  }

  export type typetaskAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typetaskMaxOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    description?: SortOrder
  }

  export type typetaskMinOrderByAggregateInput = {
    id?: SortOrder
    identifiant?: SortOrder
    description?: SortOrder
  }

  export type typetaskSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sensorsCreateNestedManyWithoutCategorysensorsInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutCategorysensorsInput>, Enumerable<sensorsUncheckedCreateWithoutCategorysensorsInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutCategorysensorsInput>
    createMany?: sensorsCreateManyCategorysensorsInputEnvelope
    connect?: Enumerable<sensorsWhereUniqueInput>
  }

  export type sensorsUncheckedCreateNestedManyWithoutCategorysensorsInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutCategorysensorsInput>, Enumerable<sensorsUncheckedCreateWithoutCategorysensorsInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutCategorysensorsInput>
    createMany?: sensorsCreateManyCategorysensorsInputEnvelope
    connect?: Enumerable<sensorsWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type sensorsUpdateManyWithoutCategorysensorsNestedInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutCategorysensorsInput>, Enumerable<sensorsUncheckedCreateWithoutCategorysensorsInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutCategorysensorsInput>
    upsert?: Enumerable<sensorsUpsertWithWhereUniqueWithoutCategorysensorsInput>
    createMany?: sensorsCreateManyCategorysensorsInputEnvelope
    set?: Enumerable<sensorsWhereUniqueInput>
    disconnect?: Enumerable<sensorsWhereUniqueInput>
    delete?: Enumerable<sensorsWhereUniqueInput>
    connect?: Enumerable<sensorsWhereUniqueInput>
    update?: Enumerable<sensorsUpdateWithWhereUniqueWithoutCategorysensorsInput>
    updateMany?: Enumerable<sensorsUpdateManyWithWhereWithoutCategorysensorsInput>
    deleteMany?: Enumerable<sensorsScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type sensorsUncheckedUpdateManyWithoutCategorysensorsNestedInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutCategorysensorsInput>, Enumerable<sensorsUncheckedCreateWithoutCategorysensorsInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutCategorysensorsInput>
    upsert?: Enumerable<sensorsUpsertWithWhereUniqueWithoutCategorysensorsInput>
    createMany?: sensorsCreateManyCategorysensorsInputEnvelope
    set?: Enumerable<sensorsWhereUniqueInput>
    disconnect?: Enumerable<sensorsWhereUniqueInput>
    delete?: Enumerable<sensorsWhereUniqueInput>
    connect?: Enumerable<sensorsWhereUniqueInput>
    update?: Enumerable<sensorsUpdateWithWhereUniqueWithoutCategorysensorsInput>
    updateMany?: Enumerable<sensorsUpdateManyWithWhereWithoutCategorysensorsInput>
    deleteMany?: Enumerable<sensorsScalarWhereInput>
  }

  export type distributeurCreateNestedOneWithoutSensorsInput = {
    create?: XOR<distributeurCreateWithoutSensorsInput, distributeurUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: distributeurCreateOrConnectWithoutSensorsInput
    connect?: distributeurWhereUniqueInput
  }

  export type categorysensorsCreateNestedOneWithoutSensorsInput = {
    create?: XOR<categorysensorsCreateWithoutSensorsInput, categorysensorsUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: categorysensorsCreateOrConnectWithoutSensorsInput
    connect?: categorysensorsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type distributeurUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<distributeurCreateWithoutSensorsInput, distributeurUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: distributeurCreateOrConnectWithoutSensorsInput
    upsert?: distributeurUpsertWithoutSensorsInput
    connect?: distributeurWhereUniqueInput
    update?: XOR<distributeurUpdateWithoutSensorsInput, distributeurUncheckedUpdateWithoutSensorsInput>
  }

  export type categorysensorsUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<categorysensorsCreateWithoutSensorsInput, categorysensorsUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: categorysensorsCreateOrConnectWithoutSensorsInput
    upsert?: categorysensorsUpsertWithoutSensorsInput
    connect?: categorysensorsWhereUniqueInput
    update?: XOR<categorysensorsUpdateWithoutSensorsInput, categorysensorsUncheckedUpdateWithoutSensorsInput>
  }

  export type recetteCreateNestedManyWithoutCategoryrecetteInput = {
    create?: XOR<Enumerable<recetteCreateWithoutCategoryrecetteInput>, Enumerable<recetteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<recetteCreateOrConnectWithoutCategoryrecetteInput>
    createMany?: recetteCreateManyCategoryrecetteInputEnvelope
    connect?: Enumerable<recetteWhereUniqueInput>
  }

  export type publiciteCreateNestedManyWithoutCategoryrecetteInput = {
    create?: XOR<Enumerable<publiciteCreateWithoutCategoryrecetteInput>, Enumerable<publiciteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<publiciteCreateOrConnectWithoutCategoryrecetteInput>
    createMany?: publiciteCreateManyCategoryrecetteInputEnvelope
    connect?: Enumerable<publiciteWhereUniqueInput>
  }

  export type recetteUncheckedCreateNestedManyWithoutCategoryrecetteInput = {
    create?: XOR<Enumerable<recetteCreateWithoutCategoryrecetteInput>, Enumerable<recetteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<recetteCreateOrConnectWithoutCategoryrecetteInput>
    createMany?: recetteCreateManyCategoryrecetteInputEnvelope
    connect?: Enumerable<recetteWhereUniqueInput>
  }

  export type publiciteUncheckedCreateNestedManyWithoutCategoryrecetteInput = {
    create?: XOR<Enumerable<publiciteCreateWithoutCategoryrecetteInput>, Enumerable<publiciteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<publiciteCreateOrConnectWithoutCategoryrecetteInput>
    createMany?: publiciteCreateManyCategoryrecetteInputEnvelope
    connect?: Enumerable<publiciteWhereUniqueInput>
  }

  export type recetteUpdateManyWithoutCategoryrecetteNestedInput = {
    create?: XOR<Enumerable<recetteCreateWithoutCategoryrecetteInput>, Enumerable<recetteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<recetteCreateOrConnectWithoutCategoryrecetteInput>
    upsert?: Enumerable<recetteUpsertWithWhereUniqueWithoutCategoryrecetteInput>
    createMany?: recetteCreateManyCategoryrecetteInputEnvelope
    set?: Enumerable<recetteWhereUniqueInput>
    disconnect?: Enumerable<recetteWhereUniqueInput>
    delete?: Enumerable<recetteWhereUniqueInput>
    connect?: Enumerable<recetteWhereUniqueInput>
    update?: Enumerable<recetteUpdateWithWhereUniqueWithoutCategoryrecetteInput>
    updateMany?: Enumerable<recetteUpdateManyWithWhereWithoutCategoryrecetteInput>
    deleteMany?: Enumerable<recetteScalarWhereInput>
  }

  export type publiciteUpdateManyWithoutCategoryrecetteNestedInput = {
    create?: XOR<Enumerable<publiciteCreateWithoutCategoryrecetteInput>, Enumerable<publiciteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<publiciteCreateOrConnectWithoutCategoryrecetteInput>
    upsert?: Enumerable<publiciteUpsertWithWhereUniqueWithoutCategoryrecetteInput>
    createMany?: publiciteCreateManyCategoryrecetteInputEnvelope
    set?: Enumerable<publiciteWhereUniqueInput>
    disconnect?: Enumerable<publiciteWhereUniqueInput>
    delete?: Enumerable<publiciteWhereUniqueInput>
    connect?: Enumerable<publiciteWhereUniqueInput>
    update?: Enumerable<publiciteUpdateWithWhereUniqueWithoutCategoryrecetteInput>
    updateMany?: Enumerable<publiciteUpdateManyWithWhereWithoutCategoryrecetteInput>
    deleteMany?: Enumerable<publiciteScalarWhereInput>
  }

  export type recetteUncheckedUpdateManyWithoutCategoryrecetteNestedInput = {
    create?: XOR<Enumerable<recetteCreateWithoutCategoryrecetteInput>, Enumerable<recetteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<recetteCreateOrConnectWithoutCategoryrecetteInput>
    upsert?: Enumerable<recetteUpsertWithWhereUniqueWithoutCategoryrecetteInput>
    createMany?: recetteCreateManyCategoryrecetteInputEnvelope
    set?: Enumerable<recetteWhereUniqueInput>
    disconnect?: Enumerable<recetteWhereUniqueInput>
    delete?: Enumerable<recetteWhereUniqueInput>
    connect?: Enumerable<recetteWhereUniqueInput>
    update?: Enumerable<recetteUpdateWithWhereUniqueWithoutCategoryrecetteInput>
    updateMany?: Enumerable<recetteUpdateManyWithWhereWithoutCategoryrecetteInput>
    deleteMany?: Enumerable<recetteScalarWhereInput>
  }

  export type publiciteUncheckedUpdateManyWithoutCategoryrecetteNestedInput = {
    create?: XOR<Enumerable<publiciteCreateWithoutCategoryrecetteInput>, Enumerable<publiciteUncheckedCreateWithoutCategoryrecetteInput>>
    connectOrCreate?: Enumerable<publiciteCreateOrConnectWithoutCategoryrecetteInput>
    upsert?: Enumerable<publiciteUpsertWithWhereUniqueWithoutCategoryrecetteInput>
    createMany?: publiciteCreateManyCategoryrecetteInputEnvelope
    set?: Enumerable<publiciteWhereUniqueInput>
    disconnect?: Enumerable<publiciteWhereUniqueInput>
    delete?: Enumerable<publiciteWhereUniqueInput>
    connect?: Enumerable<publiciteWhereUniqueInput>
    update?: Enumerable<publiciteUpdateWithWhereUniqueWithoutCategoryrecetteInput>
    updateMany?: Enumerable<publiciteUpdateManyWithWhereWithoutCategoryrecetteInput>
    deleteMany?: Enumerable<publiciteScalarWhereInput>
  }

  export type recetteCreateNestedOneWithoutCommandeInput = {
    create?: XOR<recetteCreateWithoutCommandeInput, recetteUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: recetteCreateOrConnectWithoutCommandeInput
    connect?: recetteWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type recetteUpdateOneRequiredWithoutCommandeNestedInput = {
    create?: XOR<recetteCreateWithoutCommandeInput, recetteUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: recetteCreateOrConnectWithoutCommandeInput
    upsert?: recetteUpsertWithoutCommandeInput
    connect?: recetteWhereUniqueInput
    update?: XOR<recetteUpdateWithoutCommandeInput, recetteUncheckedUpdateWithoutCommandeInput>
  }

  export type packCreateNestedOneWithoutDistrInput = {
    create?: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
    connectOrCreate?: packCreateOrConnectWithoutDistrInput
    connect?: packWhereUniqueInput
  }

  export type sensorsCreateNestedManyWithoutDistrInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutDistrInput>, Enumerable<sensorsUncheckedCreateWithoutDistrInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutDistrInput>
    createMany?: sensorsCreateManyDistrInputEnvelope
    connect?: Enumerable<sensorsWhereUniqueInput>
  }

  export type packUncheckedCreateNestedOneWithoutDistrInput = {
    create?: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
    connectOrCreate?: packCreateOrConnectWithoutDistrInput
    connect?: packWhereUniqueInput
  }

  export type sensorsUncheckedCreateNestedManyWithoutDistrInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutDistrInput>, Enumerable<sensorsUncheckedCreateWithoutDistrInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutDistrInput>
    createMany?: sensorsCreateManyDistrInputEnvelope
    connect?: Enumerable<sensorsWhereUniqueInput>
  }

  export type packUpdateOneWithoutDistrNestedInput = {
    create?: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
    connectOrCreate?: packCreateOrConnectWithoutDistrInput
    upsert?: packUpsertWithoutDistrInput
    disconnect?: boolean
    delete?: boolean
    connect?: packWhereUniqueInput
    update?: XOR<packUpdateWithoutDistrInput, packUncheckedUpdateWithoutDistrInput>
  }

  export type sensorsUpdateManyWithoutDistrNestedInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutDistrInput>, Enumerable<sensorsUncheckedCreateWithoutDistrInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutDistrInput>
    upsert?: Enumerable<sensorsUpsertWithWhereUniqueWithoutDistrInput>
    createMany?: sensorsCreateManyDistrInputEnvelope
    set?: Enumerable<sensorsWhereUniqueInput>
    disconnect?: Enumerable<sensorsWhereUniqueInput>
    delete?: Enumerable<sensorsWhereUniqueInput>
    connect?: Enumerable<sensorsWhereUniqueInput>
    update?: Enumerable<sensorsUpdateWithWhereUniqueWithoutDistrInput>
    updateMany?: Enumerable<sensorsUpdateManyWithWhereWithoutDistrInput>
    deleteMany?: Enumerable<sensorsScalarWhereInput>
  }

  export type packUncheckedUpdateOneWithoutDistrNestedInput = {
    create?: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
    connectOrCreate?: packCreateOrConnectWithoutDistrInput
    upsert?: packUpsertWithoutDistrInput
    disconnect?: boolean
    delete?: boolean
    connect?: packWhereUniqueInput
    update?: XOR<packUpdateWithoutDistrInput, packUncheckedUpdateWithoutDistrInput>
  }

  export type sensorsUncheckedUpdateManyWithoutDistrNestedInput = {
    create?: XOR<Enumerable<sensorsCreateWithoutDistrInput>, Enumerable<sensorsUncheckedCreateWithoutDistrInput>>
    connectOrCreate?: Enumerable<sensorsCreateOrConnectWithoutDistrInput>
    upsert?: Enumerable<sensorsUpsertWithWhereUniqueWithoutDistrInput>
    createMany?: sensorsCreateManyDistrInputEnvelope
    set?: Enumerable<sensorsWhereUniqueInput>
    disconnect?: Enumerable<sensorsWhereUniqueInput>
    delete?: Enumerable<sensorsWhereUniqueInput>
    connect?: Enumerable<sensorsWhereUniqueInput>
    update?: Enumerable<sensorsUpdateWithWhereUniqueWithoutDistrInput>
    updateMany?: Enumerable<sensorsUpdateManyWithWhereWithoutDistrInput>
    deleteMany?: Enumerable<sensorsScalarWhereInput>
  }

  export type packCreateNestedManyWithoutEntreInput = {
    create?: XOR<Enumerable<packCreateWithoutEntreInput>, Enumerable<packUncheckedCreateWithoutEntreInput>>
    connectOrCreate?: Enumerable<packCreateOrConnectWithoutEntreInput>
    createMany?: packCreateManyEntreInputEnvelope
    connect?: Enumerable<packWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<Enumerable<usersCreateWithoutEntrepriseInput>, Enumerable<usersUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutEntrepriseInput>
    createMany?: usersCreateManyEntrepriseInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type taskCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<Enumerable<taskCreateWithoutEntrepriseInput>, Enumerable<taskUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutEntrepriseInput>
    createMany?: taskCreateManyEntrepriseInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type packUncheckedCreateNestedManyWithoutEntreInput = {
    create?: XOR<Enumerable<packCreateWithoutEntreInput>, Enumerable<packUncheckedCreateWithoutEntreInput>>
    connectOrCreate?: Enumerable<packCreateOrConnectWithoutEntreInput>
    createMany?: packCreateManyEntreInputEnvelope
    connect?: Enumerable<packWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<Enumerable<usersCreateWithoutEntrepriseInput>, Enumerable<usersUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutEntrepriseInput>
    createMany?: usersCreateManyEntrepriseInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type taskUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<Enumerable<taskCreateWithoutEntrepriseInput>, Enumerable<taskUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutEntrepriseInput>
    createMany?: taskCreateManyEntrepriseInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type packUpdateManyWithoutEntreNestedInput = {
    create?: XOR<Enumerable<packCreateWithoutEntreInput>, Enumerable<packUncheckedCreateWithoutEntreInput>>
    connectOrCreate?: Enumerable<packCreateOrConnectWithoutEntreInput>
    upsert?: Enumerable<packUpsertWithWhereUniqueWithoutEntreInput>
    createMany?: packCreateManyEntreInputEnvelope
    set?: Enumerable<packWhereUniqueInput>
    disconnect?: Enumerable<packWhereUniqueInput>
    delete?: Enumerable<packWhereUniqueInput>
    connect?: Enumerable<packWhereUniqueInput>
    update?: Enumerable<packUpdateWithWhereUniqueWithoutEntreInput>
    updateMany?: Enumerable<packUpdateManyWithWhereWithoutEntreInput>
    deleteMany?: Enumerable<packScalarWhereInput>
  }

  export type usersUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutEntrepriseInput>, Enumerable<usersUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutEntrepriseInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutEntrepriseInput>
    createMany?: usersCreateManyEntrepriseInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutEntrepriseInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutEntrepriseInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type taskUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutEntrepriseInput>, Enumerable<taskUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutEntrepriseInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutEntrepriseInput>
    createMany?: taskCreateManyEntrepriseInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutEntrepriseInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutEntrepriseInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type packUncheckedUpdateManyWithoutEntreNestedInput = {
    create?: XOR<Enumerable<packCreateWithoutEntreInput>, Enumerable<packUncheckedCreateWithoutEntreInput>>
    connectOrCreate?: Enumerable<packCreateOrConnectWithoutEntreInput>
    upsert?: Enumerable<packUpsertWithWhereUniqueWithoutEntreInput>
    createMany?: packCreateManyEntreInputEnvelope
    set?: Enumerable<packWhereUniqueInput>
    disconnect?: Enumerable<packWhereUniqueInput>
    delete?: Enumerable<packWhereUniqueInput>
    connect?: Enumerable<packWhereUniqueInput>
    update?: Enumerable<packUpdateWithWhereUniqueWithoutEntreInput>
    updateMany?: Enumerable<packUpdateManyWithWhereWithoutEntreInput>
    deleteMany?: Enumerable<packScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutEntrepriseInput>, Enumerable<usersUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutEntrepriseInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutEntrepriseInput>
    createMany?: usersCreateManyEntrepriseInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutEntrepriseInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutEntrepriseInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type taskUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutEntrepriseInput>, Enumerable<taskUncheckedCreateWithoutEntrepriseInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutEntrepriseInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutEntrepriseInput>
    createMany?: taskCreateManyEntrepriseInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutEntrepriseInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutEntrepriseInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type distributeurCreateNestedOneWithoutPackInput = {
    create?: XOR<distributeurCreateWithoutPackInput, distributeurUncheckedCreateWithoutPackInput>
    connectOrCreate?: distributeurCreateOrConnectWithoutPackInput
    connect?: distributeurWhereUniqueInput
  }

  export type entrepiseCreateNestedOneWithoutPackInput = {
    create?: XOR<entrepiseCreateWithoutPackInput, entrepiseUncheckedCreateWithoutPackInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutPackInput
    connect?: entrepiseWhereUniqueInput
  }

  export type distributeurUpdateOneRequiredWithoutPackNestedInput = {
    create?: XOR<distributeurCreateWithoutPackInput, distributeurUncheckedCreateWithoutPackInput>
    connectOrCreate?: distributeurCreateOrConnectWithoutPackInput
    upsert?: distributeurUpsertWithoutPackInput
    connect?: distributeurWhereUniqueInput
    update?: XOR<distributeurUpdateWithoutPackInput, distributeurUncheckedUpdateWithoutPackInput>
  }

  export type entrepiseUpdateOneRequiredWithoutPackNestedInput = {
    create?: XOR<entrepiseCreateWithoutPackInput, entrepiseUncheckedCreateWithoutPackInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutPackInput
    upsert?: entrepiseUpsertWithoutPackInput
    connect?: entrepiseWhereUniqueInput
    update?: XOR<entrepiseUpdateWithoutPackInput, entrepiseUncheckedUpdateWithoutPackInput>
  }

  export type categoryrecetteCreateNestedOneWithoutPubliciteInput = {
    create?: XOR<categoryrecetteCreateWithoutPubliciteInput, categoryrecetteUncheckedCreateWithoutPubliciteInput>
    connectOrCreate?: categoryrecetteCreateOrConnectWithoutPubliciteInput
    connect?: categoryrecetteWhereUniqueInput
  }

  export type categoryrecetteUpdateOneWithoutPubliciteNestedInput = {
    create?: XOR<categoryrecetteCreateWithoutPubliciteInput, categoryrecetteUncheckedCreateWithoutPubliciteInput>
    connectOrCreate?: categoryrecetteCreateOrConnectWithoutPubliciteInput
    upsert?: categoryrecetteUpsertWithoutPubliciteInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoryrecetteWhereUniqueInput
    update?: XOR<categoryrecetteUpdateWithoutPubliciteInput, categoryrecetteUncheckedUpdateWithoutPubliciteInput>
  }

  export type commandeCreateNestedManyWithoutRecetteInput = {
    create?: XOR<Enumerable<commandeCreateWithoutRecetteInput>, Enumerable<commandeUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<commandeCreateOrConnectWithoutRecetteInput>
    createMany?: commandeCreateManyRecetteInputEnvelope
    connect?: Enumerable<commandeWhereUniqueInput>
  }

  export type categoryrecetteCreateNestedOneWithoutRecetteInput = {
    create?: XOR<categoryrecetteCreateWithoutRecetteInput, categoryrecetteUncheckedCreateWithoutRecetteInput>
    connectOrCreate?: categoryrecetteCreateOrConnectWithoutRecetteInput
    connect?: categoryrecetteWhereUniqueInput
  }

  export type recetteingrCreateNestedManyWithoutRecetteInput = {
    create?: XOR<Enumerable<recetteingrCreateWithoutRecetteInput>, Enumerable<recetteingrUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<recetteingrCreateOrConnectWithoutRecetteInput>
    createMany?: recetteingrCreateManyRecetteInputEnvelope
    connect?: Enumerable<recetteingrWhereUniqueInput>
  }

  export type commandeUncheckedCreateNestedManyWithoutRecetteInput = {
    create?: XOR<Enumerable<commandeCreateWithoutRecetteInput>, Enumerable<commandeUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<commandeCreateOrConnectWithoutRecetteInput>
    createMany?: commandeCreateManyRecetteInputEnvelope
    connect?: Enumerable<commandeWhereUniqueInput>
  }

  export type recetteingrUncheckedCreateNestedManyWithoutRecetteInput = {
    create?: XOR<Enumerable<recetteingrCreateWithoutRecetteInput>, Enumerable<recetteingrUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<recetteingrCreateOrConnectWithoutRecetteInput>
    createMany?: recetteingrCreateManyRecetteInputEnvelope
    connect?: Enumerable<recetteingrWhereUniqueInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type commandeUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<Enumerable<commandeCreateWithoutRecetteInput>, Enumerable<commandeUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<commandeCreateOrConnectWithoutRecetteInput>
    upsert?: Enumerable<commandeUpsertWithWhereUniqueWithoutRecetteInput>
    createMany?: commandeCreateManyRecetteInputEnvelope
    set?: Enumerable<commandeWhereUniqueInput>
    disconnect?: Enumerable<commandeWhereUniqueInput>
    delete?: Enumerable<commandeWhereUniqueInput>
    connect?: Enumerable<commandeWhereUniqueInput>
    update?: Enumerable<commandeUpdateWithWhereUniqueWithoutRecetteInput>
    updateMany?: Enumerable<commandeUpdateManyWithWhereWithoutRecetteInput>
    deleteMany?: Enumerable<commandeScalarWhereInput>
  }

  export type categoryrecetteUpdateOneWithoutRecetteNestedInput = {
    create?: XOR<categoryrecetteCreateWithoutRecetteInput, categoryrecetteUncheckedCreateWithoutRecetteInput>
    connectOrCreate?: categoryrecetteCreateOrConnectWithoutRecetteInput
    upsert?: categoryrecetteUpsertWithoutRecetteInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoryrecetteWhereUniqueInput
    update?: XOR<categoryrecetteUpdateWithoutRecetteInput, categoryrecetteUncheckedUpdateWithoutRecetteInput>
  }

  export type recetteingrUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<Enumerable<recetteingrCreateWithoutRecetteInput>, Enumerable<recetteingrUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<recetteingrCreateOrConnectWithoutRecetteInput>
    upsert?: Enumerable<recetteingrUpsertWithWhereUniqueWithoutRecetteInput>
    createMany?: recetteingrCreateManyRecetteInputEnvelope
    set?: Enumerable<recetteingrWhereUniqueInput>
    disconnect?: Enumerable<recetteingrWhereUniqueInput>
    delete?: Enumerable<recetteingrWhereUniqueInput>
    connect?: Enumerable<recetteingrWhereUniqueInput>
    update?: Enumerable<recetteingrUpdateWithWhereUniqueWithoutRecetteInput>
    updateMany?: Enumerable<recetteingrUpdateManyWithWhereWithoutRecetteInput>
    deleteMany?: Enumerable<recetteingrScalarWhereInput>
  }

  export type commandeUncheckedUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<Enumerable<commandeCreateWithoutRecetteInput>, Enumerable<commandeUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<commandeCreateOrConnectWithoutRecetteInput>
    upsert?: Enumerable<commandeUpsertWithWhereUniqueWithoutRecetteInput>
    createMany?: commandeCreateManyRecetteInputEnvelope
    set?: Enumerable<commandeWhereUniqueInput>
    disconnect?: Enumerable<commandeWhereUniqueInput>
    delete?: Enumerable<commandeWhereUniqueInput>
    connect?: Enumerable<commandeWhereUniqueInput>
    update?: Enumerable<commandeUpdateWithWhereUniqueWithoutRecetteInput>
    updateMany?: Enumerable<commandeUpdateManyWithWhereWithoutRecetteInput>
    deleteMany?: Enumerable<commandeScalarWhereInput>
  }

  export type recetteingrUncheckedUpdateManyWithoutRecetteNestedInput = {
    create?: XOR<Enumerable<recetteingrCreateWithoutRecetteInput>, Enumerable<recetteingrUncheckedCreateWithoutRecetteInput>>
    connectOrCreate?: Enumerable<recetteingrCreateOrConnectWithoutRecetteInput>
    upsert?: Enumerable<recetteingrUpsertWithWhereUniqueWithoutRecetteInput>
    createMany?: recetteingrCreateManyRecetteInputEnvelope
    set?: Enumerable<recetteingrWhereUniqueInput>
    disconnect?: Enumerable<recetteingrWhereUniqueInput>
    delete?: Enumerable<recetteingrWhereUniqueInput>
    connect?: Enumerable<recetteingrWhereUniqueInput>
    update?: Enumerable<recetteingrUpdateWithWhereUniqueWithoutRecetteInput>
    updateMany?: Enumerable<recetteingrUpdateManyWithWhereWithoutRecetteInput>
    deleteMany?: Enumerable<recetteingrScalarWhereInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type typetaskCreateNestedOneWithoutTaskInput = {
    create?: XOR<typetaskCreateWithoutTaskInput, typetaskUncheckedCreateWithoutTaskInput>
    connectOrCreate?: typetaskCreateOrConnectWithoutTaskInput
    connect?: typetaskWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTaskInput = {
    create?: XOR<usersCreateWithoutTaskInput, usersUncheckedCreateWithoutTaskInput>
    connectOrCreate?: usersCreateOrConnectWithoutTaskInput
    connect?: usersWhereUniqueInput
  }

  export type entrepiseCreateNestedOneWithoutTaskInput = {
    create?: XOR<entrepiseCreateWithoutTaskInput, entrepiseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutTaskInput
    connect?: entrepiseWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type typetaskUpdateOneWithoutTaskNestedInput = {
    create?: XOR<typetaskCreateWithoutTaskInput, typetaskUncheckedCreateWithoutTaskInput>
    connectOrCreate?: typetaskCreateOrConnectWithoutTaskInput
    upsert?: typetaskUpsertWithoutTaskInput
    disconnect?: boolean
    delete?: boolean
    connect?: typetaskWhereUniqueInput
    update?: XOR<typetaskUpdateWithoutTaskInput, typetaskUncheckedUpdateWithoutTaskInput>
  }

  export type usersUpdateOneWithoutTaskNestedInput = {
    create?: XOR<usersCreateWithoutTaskInput, usersUncheckedCreateWithoutTaskInput>
    connectOrCreate?: usersCreateOrConnectWithoutTaskInput
    upsert?: usersUpsertWithoutTaskInput
    disconnect?: boolean
    delete?: boolean
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutTaskInput, usersUncheckedUpdateWithoutTaskInput>
  }

  export type entrepiseUpdateOneWithoutTaskNestedInput = {
    create?: XOR<entrepiseCreateWithoutTaskInput, entrepiseUncheckedCreateWithoutTaskInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutTaskInput
    upsert?: entrepiseUpsertWithoutTaskInput
    disconnect?: boolean
    delete?: boolean
    connect?: entrepiseWhereUniqueInput
    update?: XOR<entrepiseUpdateWithoutTaskInput, entrepiseUncheckedUpdateWithoutTaskInput>
  }

  export type taskCreateNestedManyWithoutUserAMInput = {
    create?: XOR<Enumerable<taskCreateWithoutUserAMInput>, Enumerable<taskUncheckedCreateWithoutUserAMInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutUserAMInput>
    createMany?: taskCreateManyUserAMInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type entrepiseCreateNestedOneWithoutUsersInput = {
    create?: XOR<entrepiseCreateWithoutUsersInput, entrepiseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutUsersInput
    connect?: entrepiseWhereUniqueInput
  }

  export type taskUncheckedCreateNestedManyWithoutUserAMInput = {
    create?: XOR<Enumerable<taskCreateWithoutUserAMInput>, Enumerable<taskUncheckedCreateWithoutUserAMInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutUserAMInput>
    createMany?: taskCreateManyUserAMInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type taskUpdateManyWithoutUserAMNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutUserAMInput>, Enumerable<taskUncheckedCreateWithoutUserAMInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutUserAMInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutUserAMInput>
    createMany?: taskCreateManyUserAMInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutUserAMInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutUserAMInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type entrepiseUpdateOneWithoutUsersNestedInput = {
    create?: XOR<entrepiseCreateWithoutUsersInput, entrepiseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: entrepiseCreateOrConnectWithoutUsersInput
    upsert?: entrepiseUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: entrepiseWhereUniqueInput
    update?: XOR<entrepiseUpdateWithoutUsersInput, entrepiseUncheckedUpdateWithoutUsersInput>
  }

  export type taskUncheckedUpdateManyWithoutUserAMNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutUserAMInput>, Enumerable<taskUncheckedCreateWithoutUserAMInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutUserAMInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutUserAMInput>
    createMany?: taskCreateManyUserAMInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutUserAMInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutUserAMInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type recetteCreateNestedOneWithoutRecetteingrInput = {
    create?: XOR<recetteCreateWithoutRecetteingrInput, recetteUncheckedCreateWithoutRecetteingrInput>
    connectOrCreate?: recetteCreateOrConnectWithoutRecetteingrInput
    connect?: recetteWhereUniqueInput
  }

  export type recetteUpdateOneRequiredWithoutRecetteingrNestedInput = {
    create?: XOR<recetteCreateWithoutRecetteingrInput, recetteUncheckedCreateWithoutRecetteingrInput>
    connectOrCreate?: recetteCreateOrConnectWithoutRecetteingrInput
    upsert?: recetteUpsertWithoutRecetteingrInput
    connect?: recetteWhereUniqueInput
    update?: XOR<recetteUpdateWithoutRecetteingrInput, recetteUncheckedUpdateWithoutRecetteingrInput>
  }

  export type taskCreateNestedManyWithoutTypetaskInput = {
    create?: XOR<Enumerable<taskCreateWithoutTypetaskInput>, Enumerable<taskUncheckedCreateWithoutTypetaskInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutTypetaskInput>
    createMany?: taskCreateManyTypetaskInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type taskUncheckedCreateNestedManyWithoutTypetaskInput = {
    create?: XOR<Enumerable<taskCreateWithoutTypetaskInput>, Enumerable<taskUncheckedCreateWithoutTypetaskInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutTypetaskInput>
    createMany?: taskCreateManyTypetaskInputEnvelope
    connect?: Enumerable<taskWhereUniqueInput>
  }

  export type taskUpdateManyWithoutTypetaskNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutTypetaskInput>, Enumerable<taskUncheckedCreateWithoutTypetaskInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutTypetaskInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutTypetaskInput>
    createMany?: taskCreateManyTypetaskInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutTypetaskInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutTypetaskInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type taskUncheckedUpdateManyWithoutTypetaskNestedInput = {
    create?: XOR<Enumerable<taskCreateWithoutTypetaskInput>, Enumerable<taskUncheckedCreateWithoutTypetaskInput>>
    connectOrCreate?: Enumerable<taskCreateOrConnectWithoutTypetaskInput>
    upsert?: Enumerable<taskUpsertWithWhereUniqueWithoutTypetaskInput>
    createMany?: taskCreateManyTypetaskInputEnvelope
    set?: Enumerable<taskWhereUniqueInput>
    disconnect?: Enumerable<taskWhereUniqueInput>
    delete?: Enumerable<taskWhereUniqueInput>
    connect?: Enumerable<taskWhereUniqueInput>
    update?: Enumerable<taskUpdateWithWhereUniqueWithoutTypetaskInput>
    updateMany?: Enumerable<taskUpdateManyWithWhereWithoutTypetaskInput>
    deleteMany?: Enumerable<taskScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type sensorsCreateWithoutCategorysensorsInput = {
    value: string
    distr: distributeurCreateNestedOneWithoutSensorsInput
  }

  export type sensorsUncheckedCreateWithoutCategorysensorsInput = {
    id?: number
    idDistr: number
    value: string
  }

  export type sensorsCreateOrConnectWithoutCategorysensorsInput = {
    where: sensorsWhereUniqueInput
    create: XOR<sensorsCreateWithoutCategorysensorsInput, sensorsUncheckedCreateWithoutCategorysensorsInput>
  }

  export type sensorsCreateManyCategorysensorsInputEnvelope = {
    data: Enumerable<sensorsCreateManyCategorysensorsInput>
    skipDuplicates?: boolean
  }

  export type sensorsUpsertWithWhereUniqueWithoutCategorysensorsInput = {
    where: sensorsWhereUniqueInput
    update: XOR<sensorsUpdateWithoutCategorysensorsInput, sensorsUncheckedUpdateWithoutCategorysensorsInput>
    create: XOR<sensorsCreateWithoutCategorysensorsInput, sensorsUncheckedCreateWithoutCategorysensorsInput>
  }

  export type sensorsUpdateWithWhereUniqueWithoutCategorysensorsInput = {
    where: sensorsWhereUniqueInput
    data: XOR<sensorsUpdateWithoutCategorysensorsInput, sensorsUncheckedUpdateWithoutCategorysensorsInput>
  }

  export type sensorsUpdateManyWithWhereWithoutCategorysensorsInput = {
    where: sensorsScalarWhereInput
    data: XOR<sensorsUpdateManyMutationInput, sensorsUncheckedUpdateManyWithoutSensorsInput>
  }

  export type sensorsScalarWhereInput = {
    AND?: Enumerable<sensorsScalarWhereInput>
    OR?: Enumerable<sensorsScalarWhereInput>
    NOT?: Enumerable<sensorsScalarWhereInput>
    id?: IntFilter | number
    idDistr?: IntFilter | number
    idSensor?: IntFilter | number
    value?: StringFilter | string
  }

  export type distributeurCreateWithoutSensorsInput = {
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    pack?: packCreateNestedOneWithoutDistrInput
  }

  export type distributeurUncheckedCreateWithoutSensorsInput = {
    id?: number
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    pack?: packUncheckedCreateNestedOneWithoutDistrInput
  }

  export type distributeurCreateOrConnectWithoutSensorsInput = {
    where: distributeurWhereUniqueInput
    create: XOR<distributeurCreateWithoutSensorsInput, distributeurUncheckedCreateWithoutSensorsInput>
  }

  export type categorysensorsCreateWithoutSensorsInput = {
    sensor?: string | null
  }

  export type categorysensorsUncheckedCreateWithoutSensorsInput = {
    id?: number
    sensor?: string | null
  }

  export type categorysensorsCreateOrConnectWithoutSensorsInput = {
    where: categorysensorsWhereUniqueInput
    create: XOR<categorysensorsCreateWithoutSensorsInput, categorysensorsUncheckedCreateWithoutSensorsInput>
  }

  export type distributeurUpsertWithoutSensorsInput = {
    update: XOR<distributeurUpdateWithoutSensorsInput, distributeurUncheckedUpdateWithoutSensorsInput>
    create: XOR<distributeurCreateWithoutSensorsInput, distributeurUncheckedCreateWithoutSensorsInput>
  }

  export type distributeurUpdateWithoutSensorsInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    pack?: packUpdateOneWithoutDistrNestedInput
  }

  export type distributeurUncheckedUpdateWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    pack?: packUncheckedUpdateOneWithoutDistrNestedInput
  }

  export type categorysensorsUpsertWithoutSensorsInput = {
    update: XOR<categorysensorsUpdateWithoutSensorsInput, categorysensorsUncheckedUpdateWithoutSensorsInput>
    create: XOR<categorysensorsCreateWithoutSensorsInput, categorysensorsUncheckedCreateWithoutSensorsInput>
  }

  export type categorysensorsUpdateWithoutSensorsInput = {
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categorysensorsUncheckedUpdateWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteCreateWithoutCategoryrecetteInput = {
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeCreateNestedManyWithoutRecetteInput
    recetteingr?: recetteingrCreateNestedManyWithoutRecetteInput
  }

  export type recetteUncheckedCreateWithoutCategoryrecetteInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeUncheckedCreateNestedManyWithoutRecetteInput
    recetteingr?: recetteingrUncheckedCreateNestedManyWithoutRecetteInput
  }

  export type recetteCreateOrConnectWithoutCategoryrecetteInput = {
    where: recetteWhereUniqueInput
    create: XOR<recetteCreateWithoutCategoryrecetteInput, recetteUncheckedCreateWithoutCategoryrecetteInput>
  }

  export type recetteCreateManyCategoryrecetteInputEnvelope = {
    data: Enumerable<recetteCreateManyCategoryrecetteInput>
    skipDuplicates?: boolean
  }

  export type publiciteCreateWithoutCategoryrecetteInput = {
    url?: string | null
    idCategorie?: number | null
    idAnnonceur?: number | null
  }

  export type publiciteUncheckedCreateWithoutCategoryrecetteInput = {
    id?: number
    url?: string | null
    idCategorie?: number | null
    idAnnonceur?: number | null
  }

  export type publiciteCreateOrConnectWithoutCategoryrecetteInput = {
    where: publiciteWhereUniqueInput
    create: XOR<publiciteCreateWithoutCategoryrecetteInput, publiciteUncheckedCreateWithoutCategoryrecetteInput>
  }

  export type publiciteCreateManyCategoryrecetteInputEnvelope = {
    data: Enumerable<publiciteCreateManyCategoryrecetteInput>
    skipDuplicates?: boolean
  }

  export type recetteUpsertWithWhereUniqueWithoutCategoryrecetteInput = {
    where: recetteWhereUniqueInput
    update: XOR<recetteUpdateWithoutCategoryrecetteInput, recetteUncheckedUpdateWithoutCategoryrecetteInput>
    create: XOR<recetteCreateWithoutCategoryrecetteInput, recetteUncheckedCreateWithoutCategoryrecetteInput>
  }

  export type recetteUpdateWithWhereUniqueWithoutCategoryrecetteInput = {
    where: recetteWhereUniqueInput
    data: XOR<recetteUpdateWithoutCategoryrecetteInput, recetteUncheckedUpdateWithoutCategoryrecetteInput>
  }

  export type recetteUpdateManyWithWhereWithoutCategoryrecetteInput = {
    where: recetteScalarWhereInput
    data: XOR<recetteUpdateManyMutationInput, recetteUncheckedUpdateManyWithoutRecetteInput>
  }

  export type recetteScalarWhereInput = {
    AND?: Enumerable<recetteScalarWhereInput>
    OR?: Enumerable<recetteScalarWhereInput>
    NOT?: Enumerable<recetteScalarWhereInput>
    id?: IntFilter | number
    idCategRecette?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    imageLink?: StringNullableFilter | string | null
  }

  export type publiciteUpsertWithWhereUniqueWithoutCategoryrecetteInput = {
    where: publiciteWhereUniqueInput
    update: XOR<publiciteUpdateWithoutCategoryrecetteInput, publiciteUncheckedUpdateWithoutCategoryrecetteInput>
    create: XOR<publiciteCreateWithoutCategoryrecetteInput, publiciteUncheckedCreateWithoutCategoryrecetteInput>
  }

  export type publiciteUpdateWithWhereUniqueWithoutCategoryrecetteInput = {
    where: publiciteWhereUniqueInput
    data: XOR<publiciteUpdateWithoutCategoryrecetteInput, publiciteUncheckedUpdateWithoutCategoryrecetteInput>
  }

  export type publiciteUpdateManyWithWhereWithoutCategoryrecetteInput = {
    where: publiciteScalarWhereInput
    data: XOR<publiciteUpdateManyMutationInput, publiciteUncheckedUpdateManyWithoutPubliciteInput>
  }

  export type publiciteScalarWhereInput = {
    AND?: Enumerable<publiciteScalarWhereInput>
    OR?: Enumerable<publiciteScalarWhereInput>
    NOT?: Enumerable<publiciteScalarWhereInput>
    id?: IntFilter | number
    url?: StringNullableFilter | string | null
    idCategorie?: IntNullableFilter | number | null
    idCategRecette?: IntNullableFilter | number | null
    idAnnonceur?: IntNullableFilter | number | null
  }

  export type recetteCreateWithoutCommandeInput = {
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    categoryrecette?: categoryrecetteCreateNestedOneWithoutRecetteInput
    recetteingr?: recetteingrCreateNestedManyWithoutRecetteInput
  }

  export type recetteUncheckedCreateWithoutCommandeInput = {
    id?: number
    idCategRecette?: number | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    recetteingr?: recetteingrUncheckedCreateNestedManyWithoutRecetteInput
  }

  export type recetteCreateOrConnectWithoutCommandeInput = {
    where: recetteWhereUniqueInput
    create: XOR<recetteCreateWithoutCommandeInput, recetteUncheckedCreateWithoutCommandeInput>
  }

  export type recetteUpsertWithoutCommandeInput = {
    update: XOR<recetteUpdateWithoutCommandeInput, recetteUncheckedUpdateWithoutCommandeInput>
    create: XOR<recetteCreateWithoutCommandeInput, recetteUncheckedCreateWithoutCommandeInput>
  }

  export type recetteUpdateWithoutCommandeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryrecette?: categoryrecetteUpdateOneWithoutRecetteNestedInput
    recetteingr?: recetteingrUpdateManyWithoutRecetteNestedInput
  }

  export type recetteUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    recetteingr?: recetteingrUncheckedUpdateManyWithoutRecetteNestedInput
  }

  export type packCreateWithoutDistrInput = {
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
    entre: entrepiseCreateNestedOneWithoutPackInput
  }

  export type packUncheckedCreateWithoutDistrInput = {
    idEntre: number
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
  }

  export type packCreateOrConnectWithoutDistrInput = {
    where: packWhereUniqueInput
    create: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
  }

  export type sensorsCreateWithoutDistrInput = {
    value: string
    categorysensors: categorysensorsCreateNestedOneWithoutSensorsInput
  }

  export type sensorsUncheckedCreateWithoutDistrInput = {
    id?: number
    idSensor: number
    value: string
  }

  export type sensorsCreateOrConnectWithoutDistrInput = {
    where: sensorsWhereUniqueInput
    create: XOR<sensorsCreateWithoutDistrInput, sensorsUncheckedCreateWithoutDistrInput>
  }

  export type sensorsCreateManyDistrInputEnvelope = {
    data: Enumerable<sensorsCreateManyDistrInput>
    skipDuplicates?: boolean
  }

  export type packUpsertWithoutDistrInput = {
    update: XOR<packUpdateWithoutDistrInput, packUncheckedUpdateWithoutDistrInput>
    create: XOR<packCreateWithoutDistrInput, packUncheckedCreateWithoutDistrInput>
  }

  export type packUpdateWithoutDistrInput = {
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    entre?: entrepiseUpdateOneRequiredWithoutPackNestedInput
  }

  export type packUncheckedUpdateWithoutDistrInput = {
    idEntre?: IntFieldUpdateOperationsInput | number
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sensorsUpsertWithWhereUniqueWithoutDistrInput = {
    where: sensorsWhereUniqueInput
    update: XOR<sensorsUpdateWithoutDistrInput, sensorsUncheckedUpdateWithoutDistrInput>
    create: XOR<sensorsCreateWithoutDistrInput, sensorsUncheckedCreateWithoutDistrInput>
  }

  export type sensorsUpdateWithWhereUniqueWithoutDistrInput = {
    where: sensorsWhereUniqueInput
    data: XOR<sensorsUpdateWithoutDistrInput, sensorsUncheckedUpdateWithoutDistrInput>
  }

  export type sensorsUpdateManyWithWhereWithoutDistrInput = {
    where: sensorsScalarWhereInput
    data: XOR<sensorsUpdateManyMutationInput, sensorsUncheckedUpdateManyWithoutSensorsInput>
  }

  export type packCreateWithoutEntreInput = {
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
    distr: distributeurCreateNestedOneWithoutPackInput
  }

  export type packUncheckedCreateWithoutEntreInput = {
    idDistr: number
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
  }

  export type packCreateOrConnectWithoutEntreInput = {
    where: packWhereUniqueInput
    create: XOR<packCreateWithoutEntreInput, packUncheckedCreateWithoutEntreInput>
  }

  export type packCreateManyEntreInputEnvelope = {
    data: Enumerable<packCreateManyEntreInput>
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutEntrepriseInput = {
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    isActive?: number | null
    task?: taskCreateNestedManyWithoutUserAMInput
  }

  export type usersUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    isActive?: number | null
    task?: taskUncheckedCreateNestedManyWithoutUserAMInput
  }

  export type usersCreateOrConnectWithoutEntrepriseInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEntrepriseInput, usersUncheckedCreateWithoutEntrepriseInput>
  }

  export type usersCreateManyEntrepriseInputEnvelope = {
    data: Enumerable<usersCreateManyEntrepriseInput>
    skipDuplicates?: boolean
  }

  export type taskCreateWithoutEntrepriseInput = {
    idDistr: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
    typetask?: typetaskCreateNestedOneWithoutTaskInput
    userAM?: usersCreateNestedOneWithoutTaskInput
  }

  export type taskUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskCreateOrConnectWithoutEntrepriseInput = {
    where: taskWhereUniqueInput
    create: XOR<taskCreateWithoutEntrepriseInput, taskUncheckedCreateWithoutEntrepriseInput>
  }

  export type taskCreateManyEntrepriseInputEnvelope = {
    data: Enumerable<taskCreateManyEntrepriseInput>
    skipDuplicates?: boolean
  }

  export type packUpsertWithWhereUniqueWithoutEntreInput = {
    where: packWhereUniqueInput
    update: XOR<packUpdateWithoutEntreInput, packUncheckedUpdateWithoutEntreInput>
    create: XOR<packCreateWithoutEntreInput, packUncheckedCreateWithoutEntreInput>
  }

  export type packUpdateWithWhereUniqueWithoutEntreInput = {
    where: packWhereUniqueInput
    data: XOR<packUpdateWithoutEntreInput, packUncheckedUpdateWithoutEntreInput>
  }

  export type packUpdateManyWithWhereWithoutEntreInput = {
    where: packScalarWhereInput
    data: XOR<packUpdateManyMutationInput, packUncheckedUpdateManyWithoutPackInput>
  }

  export type packScalarWhereInput = {
    AND?: Enumerable<packScalarWhereInput>
    OR?: Enumerable<packScalarWhereInput>
    NOT?: Enumerable<packScalarWhereInput>
    idDistr?: IntFilter | number
    idEntre?: IntFilter | number
    codeverou?: StringNullableFilter | string | null
    localisation?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
  }

  export type usersUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutEntrepriseInput, usersUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<usersCreateWithoutEntrepriseInput, usersUncheckedCreateWithoutEntrepriseInput>
  }

  export type usersUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutEntrepriseInput, usersUncheckedUpdateWithoutEntrepriseInput>
  }

  export type usersUpdateManyWithWhereWithoutEntrepriseInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id?: IntFilter | number
    nom?: StringNullableFilter | string | null
    prenom?: StringNullableFilter | string | null
    mail?: StringNullableFilter | string | null
    mdp?: StringNullableFilter | string | null
    tel?: StringNullableFilter | string | null
    idRole?: IntNullableFilter | number | null
    idCreatedpar?: IntNullableFilter | number | null
    idEntreprise?: IntNullableFilter | number | null
    isActive?: IntNullableFilter | number | null
  }

  export type taskUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: taskWhereUniqueInput
    update: XOR<taskUpdateWithoutEntrepriseInput, taskUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<taskCreateWithoutEntrepriseInput, taskUncheckedCreateWithoutEntrepriseInput>
  }

  export type taskUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: taskWhereUniqueInput
    data: XOR<taskUpdateWithoutEntrepriseInput, taskUncheckedUpdateWithoutEntrepriseInput>
  }

  export type taskUpdateManyWithWhereWithoutEntrepriseInput = {
    where: taskScalarWhereInput
    data: XOR<taskUpdateManyMutationInput, taskUncheckedUpdateManyWithoutTaskInput>
  }

  export type taskScalarWhereInput = {
    AND?: Enumerable<taskScalarWhereInput>
    OR?: Enumerable<taskScalarWhereInput>
    NOT?: Enumerable<taskScalarWhereInput>
    id?: IntFilter | number
    idDistr?: IntFilter | number
    idUser?: IntNullableFilter | number | null
    idEntre?: IntFilter | number
    idType?: IntFilter | number
    isDone?: BoolFilter | boolean
    isOpen?: BoolFilter | boolean
    date?: StringFilter | string
    time?: StringFilter | string
    message?: StringFilter | string
  }

  export type distributeurCreateWithoutPackInput = {
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    sensors?: sensorsCreateNestedManyWithoutDistrInput
  }

  export type distributeurUncheckedCreateWithoutPackInput = {
    id?: number
    identifiant: string
    capaciteGoblet?: number | null
    capaciteSucre?: number | null
    capaciteSpoon?: number | null
    sensors?: sensorsUncheckedCreateNestedManyWithoutDistrInput
  }

  export type distributeurCreateOrConnectWithoutPackInput = {
    where: distributeurWhereUniqueInput
    create: XOR<distributeurCreateWithoutPackInput, distributeurUncheckedCreateWithoutPackInput>
  }

  export type entrepiseCreateWithoutPackInput = {
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    users?: usersCreateNestedManyWithoutEntrepriseInput
    task?: taskCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseUncheckedCreateWithoutPackInput = {
    id?: number
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    users?: usersUncheckedCreateNestedManyWithoutEntrepriseInput
    task?: taskUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseCreateOrConnectWithoutPackInput = {
    where: entrepiseWhereUniqueInput
    create: XOR<entrepiseCreateWithoutPackInput, entrepiseUncheckedCreateWithoutPackInput>
  }

  export type distributeurUpsertWithoutPackInput = {
    update: XOR<distributeurUpdateWithoutPackInput, distributeurUncheckedUpdateWithoutPackInput>
    create: XOR<distributeurCreateWithoutPackInput, distributeurUncheckedCreateWithoutPackInput>
  }

  export type distributeurUpdateWithoutPackInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    sensors?: sensorsUpdateManyWithoutDistrNestedInput
  }

  export type distributeurUncheckedUpdateWithoutPackInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    capaciteGoblet?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSucre?: NullableIntFieldUpdateOperationsInput | number | null
    capaciteSpoon?: NullableIntFieldUpdateOperationsInput | number | null
    sensors?: sensorsUncheckedUpdateManyWithoutDistrNestedInput
  }

  export type entrepiseUpsertWithoutPackInput = {
    update: XOR<entrepiseUpdateWithoutPackInput, entrepiseUncheckedUpdateWithoutPackInput>
    create: XOR<entrepiseCreateWithoutPackInput, entrepiseUncheckedCreateWithoutPackInput>
  }

  export type entrepiseUpdateWithoutPackInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateManyWithoutEntrepriseNestedInput
    task?: taskUpdateManyWithoutEntrepriseNestedInput
  }

  export type entrepiseUncheckedUpdateWithoutPackInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUncheckedUpdateManyWithoutEntrepriseNestedInput
    task?: taskUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type categoryrecetteCreateWithoutPubliciteInput = {
    description?: string | null
    recette?: recetteCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteUncheckedCreateWithoutPubliciteInput = {
    id?: number
    description?: string | null
    recette?: recetteUncheckedCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteCreateOrConnectWithoutPubliciteInput = {
    where: categoryrecetteWhereUniqueInput
    create: XOR<categoryrecetteCreateWithoutPubliciteInput, categoryrecetteUncheckedCreateWithoutPubliciteInput>
  }

  export type categoryrecetteUpsertWithoutPubliciteInput = {
    update: XOR<categoryrecetteUpdateWithoutPubliciteInput, categoryrecetteUncheckedUpdateWithoutPubliciteInput>
    create: XOR<categoryrecetteCreateWithoutPubliciteInput, categoryrecetteUncheckedCreateWithoutPubliciteInput>
  }

  export type categoryrecetteUpdateWithoutPubliciteInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: recetteUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type categoryrecetteUncheckedUpdateWithoutPubliciteInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: recetteUncheckedUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type commandeCreateWithoutRecetteInput = {
    idIngredient?: number | null
    quantity: string
  }

  export type commandeUncheckedCreateWithoutRecetteInput = {
    id?: number
    idIngredient?: number | null
    quantity: string
  }

  export type commandeCreateOrConnectWithoutRecetteInput = {
    where: commandeWhereUniqueInput
    create: XOR<commandeCreateWithoutRecetteInput, commandeUncheckedCreateWithoutRecetteInput>
  }

  export type commandeCreateManyRecetteInputEnvelope = {
    data: Enumerable<commandeCreateManyRecetteInput>
    skipDuplicates?: boolean
  }

  export type categoryrecetteCreateWithoutRecetteInput = {
    description?: string | null
    publicite?: publiciteCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteUncheckedCreateWithoutRecetteInput = {
    id?: number
    description?: string | null
    publicite?: publiciteUncheckedCreateNestedManyWithoutCategoryrecetteInput
  }

  export type categoryrecetteCreateOrConnectWithoutRecetteInput = {
    where: categoryrecetteWhereUniqueInput
    create: XOR<categoryrecetteCreateWithoutRecetteInput, categoryrecetteUncheckedCreateWithoutRecetteInput>
  }

  export type recetteingrCreateWithoutRecetteInput = {
    idIngredient: number
    quantity?: string | null
  }

  export type recetteingrUncheckedCreateWithoutRecetteInput = {
    idIngredient: number
    quantity?: string | null
  }

  export type recetteingrCreateOrConnectWithoutRecetteInput = {
    where: recetteingrWhereUniqueInput
    create: XOR<recetteingrCreateWithoutRecetteInput, recetteingrUncheckedCreateWithoutRecetteInput>
  }

  export type recetteingrCreateManyRecetteInputEnvelope = {
    data: Enumerable<recetteingrCreateManyRecetteInput>
    skipDuplicates?: boolean
  }

  export type commandeUpsertWithWhereUniqueWithoutRecetteInput = {
    where: commandeWhereUniqueInput
    update: XOR<commandeUpdateWithoutRecetteInput, commandeUncheckedUpdateWithoutRecetteInput>
    create: XOR<commandeCreateWithoutRecetteInput, commandeUncheckedCreateWithoutRecetteInput>
  }

  export type commandeUpdateWithWhereUniqueWithoutRecetteInput = {
    where: commandeWhereUniqueInput
    data: XOR<commandeUpdateWithoutRecetteInput, commandeUncheckedUpdateWithoutRecetteInput>
  }

  export type commandeUpdateManyWithWhereWithoutRecetteInput = {
    where: commandeScalarWhereInput
    data: XOR<commandeUpdateManyMutationInput, commandeUncheckedUpdateManyWithoutCommandeInput>
  }

  export type commandeScalarWhereInput = {
    AND?: Enumerable<commandeScalarWhereInput>
    OR?: Enumerable<commandeScalarWhereInput>
    NOT?: Enumerable<commandeScalarWhereInput>
    id?: IntFilter | number
    idRecette?: IntFilter | number
    idIngredient?: IntNullableFilter | number | null
    quantity?: StringFilter | string
  }

  export type categoryrecetteUpsertWithoutRecetteInput = {
    update: XOR<categoryrecetteUpdateWithoutRecetteInput, categoryrecetteUncheckedUpdateWithoutRecetteInput>
    create: XOR<categoryrecetteCreateWithoutRecetteInput, categoryrecetteUncheckedCreateWithoutRecetteInput>
  }

  export type categoryrecetteUpdateWithoutRecetteInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicite?: publiciteUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type categoryrecetteUncheckedUpdateWithoutRecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publicite?: publiciteUncheckedUpdateManyWithoutCategoryrecetteNestedInput
  }

  export type recetteingrUpsertWithWhereUniqueWithoutRecetteInput = {
    where: recetteingrWhereUniqueInput
    update: XOR<recetteingrUpdateWithoutRecetteInput, recetteingrUncheckedUpdateWithoutRecetteInput>
    create: XOR<recetteingrCreateWithoutRecetteInput, recetteingrUncheckedCreateWithoutRecetteInput>
  }

  export type recetteingrUpdateWithWhereUniqueWithoutRecetteInput = {
    where: recetteingrWhereUniqueInput
    data: XOR<recetteingrUpdateWithoutRecetteInput, recetteingrUncheckedUpdateWithoutRecetteInput>
  }

  export type recetteingrUpdateManyWithWhereWithoutRecetteInput = {
    where: recetteingrScalarWhereInput
    data: XOR<recetteingrUpdateManyMutationInput, recetteingrUncheckedUpdateManyWithoutRecetteingrInput>
  }

  export type recetteingrScalarWhereInput = {
    AND?: Enumerable<recetteingrScalarWhereInput>
    OR?: Enumerable<recetteingrScalarWhereInput>
    NOT?: Enumerable<recetteingrScalarWhereInput>
    idRecette?: IntFilter | number
    idIngredient?: IntFilter | number
    quantity?: StringNullableFilter | string | null
  }

  export type typetaskCreateWithoutTaskInput = {
    identifiant: string
    description?: string | null
  }

  export type typetaskUncheckedCreateWithoutTaskInput = {
    id?: number
    identifiant: string
    description?: string | null
  }

  export type typetaskCreateOrConnectWithoutTaskInput = {
    where: typetaskWhereUniqueInput
    create: XOR<typetaskCreateWithoutTaskInput, typetaskUncheckedCreateWithoutTaskInput>
  }

  export type usersCreateWithoutTaskInput = {
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    isActive?: number | null
    entreprise?: entrepiseCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTaskInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    idEntreprise?: number | null
    isActive?: number | null
  }

  export type usersCreateOrConnectWithoutTaskInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTaskInput, usersUncheckedCreateWithoutTaskInput>
  }

  export type entrepiseCreateWithoutTaskInput = {
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packCreateNestedManyWithoutEntreInput
    users?: usersCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseUncheckedCreateWithoutTaskInput = {
    id?: number
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packUncheckedCreateNestedManyWithoutEntreInput
    users?: usersUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseCreateOrConnectWithoutTaskInput = {
    where: entrepiseWhereUniqueInput
    create: XOR<entrepiseCreateWithoutTaskInput, entrepiseUncheckedCreateWithoutTaskInput>
  }

  export type typetaskUpsertWithoutTaskInput = {
    update: XOR<typetaskUpdateWithoutTaskInput, typetaskUncheckedUpdateWithoutTaskInput>
    create: XOR<typetaskCreateWithoutTaskInput, typetaskUncheckedCreateWithoutTaskInput>
  }

  export type typetaskUpdateWithoutTaskInput = {
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type typetaskUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifiant?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutTaskInput = {
    update: XOR<usersUpdateWithoutTaskInput, usersUncheckedUpdateWithoutTaskInput>
    create: XOR<usersCreateWithoutTaskInput, usersUncheckedCreateWithoutTaskInput>
  }

  export type usersUpdateWithoutTaskInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
    entreprise?: entrepiseUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    idEntreprise?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type entrepiseUpsertWithoutTaskInput = {
    update: XOR<entrepiseUpdateWithoutTaskInput, entrepiseUncheckedUpdateWithoutTaskInput>
    create: XOR<entrepiseCreateWithoutTaskInput, entrepiseUncheckedCreateWithoutTaskInput>
  }

  export type entrepiseUpdateWithoutTaskInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUpdateManyWithoutEntreNestedInput
    users?: usersUpdateManyWithoutEntrepriseNestedInput
  }

  export type entrepiseUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUncheckedUpdateManyWithoutEntreNestedInput
    users?: usersUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type taskCreateWithoutUserAMInput = {
    idDistr: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
    typetask?: typetaskCreateNestedOneWithoutTaskInput
    entreprise?: entrepiseCreateNestedOneWithoutTaskInput
  }

  export type taskUncheckedCreateWithoutUserAMInput = {
    id?: number
    idDistr: number
    idEntre: number
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskCreateOrConnectWithoutUserAMInput = {
    where: taskWhereUniqueInput
    create: XOR<taskCreateWithoutUserAMInput, taskUncheckedCreateWithoutUserAMInput>
  }

  export type taskCreateManyUserAMInputEnvelope = {
    data: Enumerable<taskCreateManyUserAMInput>
    skipDuplicates?: boolean
  }

  export type entrepiseCreateWithoutUsersInput = {
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packCreateNestedManyWithoutEntreInput
    task?: taskCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseUncheckedCreateWithoutUsersInput = {
    id?: number
    nom?: string | null
    adresse?: string | null
    mail?: string | null
    tel?: string | null
    link?: string | null
    pack?: packUncheckedCreateNestedManyWithoutEntreInput
    task?: taskUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type entrepiseCreateOrConnectWithoutUsersInput = {
    where: entrepiseWhereUniqueInput
    create: XOR<entrepiseCreateWithoutUsersInput, entrepiseUncheckedCreateWithoutUsersInput>
  }

  export type taskUpsertWithWhereUniqueWithoutUserAMInput = {
    where: taskWhereUniqueInput
    update: XOR<taskUpdateWithoutUserAMInput, taskUncheckedUpdateWithoutUserAMInput>
    create: XOR<taskCreateWithoutUserAMInput, taskUncheckedCreateWithoutUserAMInput>
  }

  export type taskUpdateWithWhereUniqueWithoutUserAMInput = {
    where: taskWhereUniqueInput
    data: XOR<taskUpdateWithoutUserAMInput, taskUncheckedUpdateWithoutUserAMInput>
  }

  export type taskUpdateManyWithWhereWithoutUserAMInput = {
    where: taskScalarWhereInput
    data: XOR<taskUpdateManyMutationInput, taskUncheckedUpdateManyWithoutTaskInput>
  }

  export type entrepiseUpsertWithoutUsersInput = {
    update: XOR<entrepiseUpdateWithoutUsersInput, entrepiseUncheckedUpdateWithoutUsersInput>
    create: XOR<entrepiseCreateWithoutUsersInput, entrepiseUncheckedCreateWithoutUsersInput>
  }

  export type entrepiseUpdateWithoutUsersInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUpdateManyWithoutEntreNestedInput
    task?: taskUpdateManyWithoutEntrepriseNestedInput
  }

  export type entrepiseUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    pack?: packUncheckedUpdateManyWithoutEntreNestedInput
    task?: taskUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type recetteCreateWithoutRecetteingrInput = {
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeCreateNestedManyWithoutRecetteInput
    categoryrecette?: categoryrecetteCreateNestedOneWithoutRecetteInput
  }

  export type recetteUncheckedCreateWithoutRecetteingrInput = {
    id?: number
    idCategRecette?: number | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
    commande?: commandeUncheckedCreateNestedManyWithoutRecetteInput
  }

  export type recetteCreateOrConnectWithoutRecetteingrInput = {
    where: recetteWhereUniqueInput
    create: XOR<recetteCreateWithoutRecetteingrInput, recetteUncheckedCreateWithoutRecetteingrInput>
  }

  export type recetteUpsertWithoutRecetteingrInput = {
    update: XOR<recetteUpdateWithoutRecetteingrInput, recetteUncheckedUpdateWithoutRecetteingrInput>
    create: XOR<recetteCreateWithoutRecetteingrInput, recetteUncheckedCreateWithoutRecetteingrInput>
  }

  export type recetteUpdateWithoutRecetteingrInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUpdateManyWithoutRecetteNestedInput
    categoryrecette?: categoryrecetteUpdateOneWithoutRecetteNestedInput
  }

  export type recetteUncheckedUpdateWithoutRecetteingrInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCategRecette?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUncheckedUpdateManyWithoutRecetteNestedInput
  }

  export type taskCreateWithoutTypetaskInput = {
    idDistr: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
    userAM?: usersCreateNestedOneWithoutTaskInput
    entreprise?: entrepiseCreateNestedOneWithoutTaskInput
  }

  export type taskUncheckedCreateWithoutTypetaskInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idEntre: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskCreateOrConnectWithoutTypetaskInput = {
    where: taskWhereUniqueInput
    create: XOR<taskCreateWithoutTypetaskInput, taskUncheckedCreateWithoutTypetaskInput>
  }

  export type taskCreateManyTypetaskInputEnvelope = {
    data: Enumerable<taskCreateManyTypetaskInput>
    skipDuplicates?: boolean
  }

  export type taskUpsertWithWhereUniqueWithoutTypetaskInput = {
    where: taskWhereUniqueInput
    update: XOR<taskUpdateWithoutTypetaskInput, taskUncheckedUpdateWithoutTypetaskInput>
    create: XOR<taskCreateWithoutTypetaskInput, taskUncheckedCreateWithoutTypetaskInput>
  }

  export type taskUpdateWithWhereUniqueWithoutTypetaskInput = {
    where: taskWhereUniqueInput
    data: XOR<taskUpdateWithoutTypetaskInput, taskUncheckedUpdateWithoutTypetaskInput>
  }

  export type taskUpdateManyWithWhereWithoutTypetaskInput = {
    where: taskScalarWhereInput
    data: XOR<taskUpdateManyMutationInput, taskUncheckedUpdateManyWithoutTaskInput>
  }

  export type sensorsCreateManyCategorysensorsInput = {
    id?: number
    idDistr: number
    value: string
  }

  export type sensorsUpdateWithoutCategorysensorsInput = {
    value?: StringFieldUpdateOperationsInput | string
    distr?: distributeurUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type sensorsUncheckedUpdateWithoutCategorysensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type sensorsUncheckedUpdateManyWithoutSensorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type recetteCreateManyCategoryrecetteInput = {
    id?: number
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    imageLink?: string | null
  }

  export type publiciteCreateManyCategoryrecetteInput = {
    id?: number
    url?: string | null
    idCategorie?: number | null
    idAnnonceur?: number | null
  }

  export type recetteUpdateWithoutCategoryrecetteInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUpdateManyWithoutRecetteNestedInput
    recetteingr?: recetteingrUpdateManyWithoutRecetteNestedInput
  }

  export type recetteUncheckedUpdateWithoutCategoryrecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
    commande?: commandeUncheckedUpdateManyWithoutRecetteNestedInput
    recetteingr?: recetteingrUncheckedUpdateManyWithoutRecetteNestedInput
  }

  export type recetteUncheckedUpdateManyWithoutRecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publiciteUpdateWithoutCategoryrecetteInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publiciteUncheckedUpdateWithoutCategoryrecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type publiciteUncheckedUpdateManyWithoutPubliciteInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    idCategorie?: NullableIntFieldUpdateOperationsInput | number | null
    idAnnonceur?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sensorsCreateManyDistrInput = {
    id?: number
    idSensor: number
    value: string
  }

  export type sensorsUpdateWithoutDistrInput = {
    value?: StringFieldUpdateOperationsInput | string
    categorysensors?: categorysensorsUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type sensorsUncheckedUpdateWithoutDistrInput = {
    id?: IntFieldUpdateOperationsInput | number
    idSensor?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type packCreateManyEntreInput = {
    idDistr: number
    codeverou?: string | null
    localisation?: string | null
    state?: string | null
  }

  export type usersCreateManyEntrepriseInput = {
    id?: number
    nom?: string | null
    prenom?: string | null
    mail?: string | null
    mdp?: string | null
    tel?: string | null
    idRole?: number | null
    idCreatedpar?: number | null
    isActive?: number | null
  }

  export type taskCreateManyEntrepriseInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type packUpdateWithoutEntreInput = {
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    distr?: distributeurUpdateOneRequiredWithoutPackNestedInput
  }

  export type packUncheckedUpdateWithoutEntreInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packUncheckedUpdateManyWithoutPackInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    codeverou?: NullableStringFieldUpdateOperationsInput | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpdateWithoutEntrepriseInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
    task?: taskUpdateManyWithoutUserAMNestedInput
  }

  export type usersUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
    task?: taskUncheckedUpdateManyWithoutUserAMNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    mail?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    idRole?: NullableIntFieldUpdateOperationsInput | number | null
    idCreatedpar?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type taskUpdateWithoutEntrepriseInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    typetask?: typetaskUpdateOneWithoutTaskNestedInput
    userAM?: usersUpdateOneWithoutTaskNestedInput
  }

  export type taskUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idUser?: NullableIntFieldUpdateOperationsInput | number | null
    idType?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type taskUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idUser?: NullableIntFieldUpdateOperationsInput | number | null
    idType?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type commandeCreateManyRecetteInput = {
    id?: number
    idIngredient?: number | null
    quantity: string
  }

  export type recetteingrCreateManyRecetteInput = {
    idIngredient: number
    quantity?: string | null
  }

  export type commandeUpdateWithoutRecetteInput = {
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type commandeUncheckedUpdateWithoutRecetteInput = {
    id?: IntFieldUpdateOperationsInput | number
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type commandeUncheckedUpdateManyWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    idIngredient?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type recetteingrUpdateWithoutRecetteInput = {
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteingrUncheckedUpdateWithoutRecetteInput = {
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recetteingrUncheckedUpdateManyWithoutRecetteingrInput = {
    idIngredient?: IntFieldUpdateOperationsInput | number
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taskCreateManyUserAMInput = {
    id?: number
    idDistr: number
    idEntre: number
    idType: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskUpdateWithoutUserAMInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    typetask?: typetaskUpdateOneWithoutTaskNestedInput
    entreprise?: entrepiseUpdateOneWithoutTaskNestedInput
  }

  export type taskUncheckedUpdateWithoutUserAMInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idEntre?: IntFieldUpdateOperationsInput | number
    idType?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type taskCreateManyTypetaskInput = {
    id?: number
    idDistr: number
    idUser?: number | null
    idEntre: number
    isDone?: boolean
    isOpen?: boolean
    date: string
    time: string
    message: string
  }

  export type taskUpdateWithoutTypetaskInput = {
    idDistr?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userAM?: usersUpdateOneWithoutTaskNestedInput
    entreprise?: entrepiseUpdateOneWithoutTaskNestedInput
  }

  export type taskUncheckedUpdateWithoutTypetaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    idDistr?: IntFieldUpdateOperationsInput | number
    idUser?: NullableIntFieldUpdateOperationsInput | number | null
    idEntre?: IntFieldUpdateOperationsInput | number
    isDone?: BoolFieldUpdateOperationsInput | boolean
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}